// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"4hJLU":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "3a348df4af4559fd";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && ![
        'localhost',
        '127.0.0.1',
        '0.0.0.0'
    ].includes(hostname) ? 'wss' : 'ws';
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        disposedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === 'reload') fullReload();
        else if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
                await hmrApplyUpdates(assets);
                hmrDisposeQueue();
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                let processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ('reload' in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"5NY2J":[function(require,module,exports,__globalThis) {
var _sdkTraceBase = require("@opentelemetry/sdk-trace-base");
var _sdkTraceWeb = require("@opentelemetry/sdk-trace-web");
var _instrumentationDocumentLoad = require("@opentelemetry/instrumentation-document-load");
var _contextZone = require("@opentelemetry/context-zone");
var _instrumentation = require("@opentelemetry/instrumentation");
var _instrumentationXmlHttpRequest = require("@opentelemetry/instrumentation-xml-http-request");
var _instrumentationUserInteraction = require("@opentelemetry/instrumentation-user-interaction");
var _sdkMetrics = require("@opentelemetry/sdk-metrics");
const provider = new (0, _sdkTraceWeb.WebTracerProvider)({
    spanProcessors: [
        new (0, _sdkTraceBase.SimpleSpanProcessor)(new (0, _sdkTraceBase.ConsoleSpanExporter)())
    ]
});
provider.register({
    // Changing default contextManager to use ZoneContextManager - supports asynchronous operations - optional
    contextManager: new (0, _contextZone.ZoneContextManager)()
});
// Registering instrumentations
(0, _instrumentation.registerInstrumentations)({
    instrumentations: [
        new (0, _instrumentationDocumentLoad.DocumentLoadInstrumentation)(),
        new (0, _instrumentationUserInteraction.UserInteractionInstrumentation)(),
        new (0, _instrumentationXmlHttpRequest.XMLHttpRequestInstrumentation)()
    ]
});
// Set up the MeterProvider with the exporter
const meterProvider = new (0, _sdkMetrics.MeterProvider)({
    readers: [
        new (0, _sdkMetrics.PeriodicExportingMetricReader)({
            exporter: new (0, _sdkMetrics.ConsoleMetricExporter)(),
            exportIntervalMillis: 1000
        })
    ]
});
// Initialize meter provider (this is where you collect custom metrics)
const meter = meterProvider.getMeter('browser-metrics');
// Example of creating a simple counter metric
/*const pageLoadCounter = meter.createCounter('page_loads', {description: 'Counts the number of page loads',});*/ // Optional: Example of adding more metrics, like duration or custom timing
const pageLoadDuration = meter.createHistogram('page_load_duration', {
    description: 'Measures the time it takes to load the page'
});
// Simulate recording a metric (since we can't use `window` in Node.js)
const simulateLoadTime = ()=>{
    const loadTime = Math.random() * 1000; // Simulate a random page load time between 0 and 1000ms
    pageLoadDuration.record(loadTime);
    console.log(`Simulated page load in ${loadTime.toFixed(2)} milliseconds`);
    console.log(`Metric Recorded: page_load_duration = ${loadTime.toFixed(2)} ms`);
};
// Simulate a load event every 5 seconds
setInterval(simulateLoadTime, 10000); /*// Example of tracking page loads as a metric
window.addEventListener('load', () => {
  pageLoadCounter.add(1); // Increment the counter by 1 every time the page is loaded
});*/  // Start measuring page load duration
 /*const startTime = performance.now();

// Example of recording the time it takes for the page to load
window.addEventListener('load', () => {
  const endTime = performance.now();
  durationHistogram.record(endTime - startTime);
});*/  /*// Set up the OTLP exporter
const exporter = new OTLPMetricExporter({
  url: 'http://localhost:4318/v1/metrics', // Replace with your OTLP endpoint
});

// Create custom metrics for browser performance
const fcpHistogram = meter.createHistogram('fcp', {description: 'First Contentful Paint time',});
const lcpHistogram = meter.createHistogram('lcp', {description: 'Largest Contentful Paint time',});
const ttiHistogram = meter.createHistogram('tti', {description: 'Time to Interactive',});

// Use the PerformanceObserver API to collect and record browser performance
if (typeof window !== 'undefined') {
  // Track First Contentful Paint (FCP)
  new PerformanceObserver((entryList) => {
    entryList.getEntriesByName('first-contentful-paint').forEach((entry) => {
      fcpHistogram.record(entry.startTime);
    });
  }).observe({ type: 'paint', buffered: true });

  // Track Largest Contentful Paint (LCP)
  new PerformanceObserver((entryList) => {
    entryList.getEntriesByName('largest-contentful-paint').forEach((entry) => {
      lcpHistogram.record(entry.startTime);
    });
  }).observe({ type: 'largest-contentful-paint', buffered: true });

  // Track Time to Interactive (TTI)
  new PerformanceObserver((entryList) => {
    entryList.getEntriesByName('interactive').forEach((entry) => {
      ttiHistogram.record(entry.startTime);
    });
  }).observe({ type: 'navigation', buffered: true });
}
*/ 

},{"@opentelemetry/sdk-trace-base":"jj5uM","@opentelemetry/sdk-trace-web":"eXZZL","@opentelemetry/instrumentation-document-load":"exbkI","@opentelemetry/context-zone":"cmUfS","@opentelemetry/instrumentation":"3OTpd","@opentelemetry/sdk-metrics":"kKfrn","@opentelemetry/instrumentation-xml-http-request":"jYPe9","@opentelemetry/instrumentation-user-interaction":"lOen7"}],"jj5uM":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Tracer", ()=>(0, _tracer.Tracer));
parcelHelpers.export(exports, "BasicTracerProvider", ()=>(0, _basicTracerProvider.BasicTracerProvider));
parcelHelpers.export(exports, "ForceFlushState", ()=>(0, _basicTracerProvider.ForceFlushState));
parcelHelpers.export(exports, "BatchSpanProcessor", ()=>(0, _platform.BatchSpanProcessor));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _platform.RandomIdGenerator));
parcelHelpers.export(exports, "ConsoleSpanExporter", ()=>(0, _consoleSpanExporter.ConsoleSpanExporter));
parcelHelpers.export(exports, "InMemorySpanExporter", ()=>(0, _inMemorySpanExporter.InMemorySpanExporter));
parcelHelpers.export(exports, "SimpleSpanProcessor", ()=>(0, _simpleSpanProcessor.SimpleSpanProcessor));
parcelHelpers.export(exports, "NoopSpanProcessor", ()=>(0, _noopSpanProcessor.NoopSpanProcessor));
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>(0, _alwaysOffSampler.AlwaysOffSampler));
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>(0, _alwaysOnSampler.AlwaysOnSampler));
parcelHelpers.export(exports, "ParentBasedSampler", ()=>(0, _parentBasedSampler.ParentBasedSampler));
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>(0, _traceIdRatioBasedSampler.TraceIdRatioBasedSampler));
parcelHelpers.export(exports, "SamplingDecision", ()=>(0, _sampler.SamplingDecision));
parcelHelpers.export(exports, "Span", ()=>(0, _span.Span));
var _tracer = require("./Tracer");
var _basicTracerProvider = require("./BasicTracerProvider");
var _platform = require("./platform");
var _consoleSpanExporter = require("./export/ConsoleSpanExporter");
var _inMemorySpanExporter = require("./export/InMemorySpanExporter");
var _simpleSpanProcessor = require("./export/SimpleSpanProcessor");
var _noopSpanProcessor = require("./export/NoopSpanProcessor");
var _alwaysOffSampler = require("./sampler/AlwaysOffSampler");
var _alwaysOnSampler = require("./sampler/AlwaysOnSampler");
var _parentBasedSampler = require("./sampler/ParentBasedSampler");
var _traceIdRatioBasedSampler = require("./sampler/TraceIdRatioBasedSampler");
var _sampler = require("./Sampler");
var _span = require("./Span");

},{"./Tracer":false,"./BasicTracerProvider":false,"./platform":false,"./export/ConsoleSpanExporter":"hWVp2","./export/InMemorySpanExporter":false,"./export/SimpleSpanProcessor":"Nq2MM","./export/NoopSpanProcessor":false,"./sampler/AlwaysOffSampler":false,"./sampler/AlwaysOnSampler":false,"./sampler/ParentBasedSampler":false,"./sampler/TraceIdRatioBasedSampler":false,"./Sampler":false,"./Span":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hWVp2":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConsoleSpanExporter", ()=>ConsoleSpanExporter);
var _core = require("@opentelemetry/core");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * This is implementation of {@link SpanExporter} that prints spans to the
 * console. This class can be used for diagnostic purposes.
 *
 * NOTE: This {@link SpanExporter} is intended for diagnostics use only, output rendered to the console may change at any time.
 */ /* eslint-disable no-console */ var ConsoleSpanExporter = /** @class */ function() {
    function ConsoleSpanExporter() {}
    /**
     * Export spans.
     * @param spans
     * @param resultCallback
     */ ConsoleSpanExporter.prototype.export = function(spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
    };
    /**
     * Shutdown the exporter.
     */ ConsoleSpanExporter.prototype.shutdown = function() {
        this._sendSpans([]);
        return this.forceFlush();
    };
    /**
     * Exports any pending spans in exporter
     */ ConsoleSpanExporter.prototype.forceFlush = function() {
        return Promise.resolve();
    };
    /**
     * converts span info into more readable format
     * @param span
     */ ConsoleSpanExporter.prototype._exportInfo = function(span) {
        var _a;
        return {
            resource: {
                attributes: span.resource.attributes
            },
            instrumentationScope: span.instrumentationLibrary,
            traceId: span.spanContext().traceId,
            parentId: span.parentSpanId,
            traceState: (_a = span.spanContext().traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
            name: span.name,
            id: span.spanContext().spanId,
            kind: span.kind,
            timestamp: (0, _core.hrTimeToMicroseconds)(span.startTime),
            duration: (0, _core.hrTimeToMicroseconds)(span.duration),
            attributes: span.attributes,
            status: span.status,
            events: span.events,
            links: span.links
        };
    };
    /**
     * Showing spans in console
     * @param spans
     * @param done
     */ ConsoleSpanExporter.prototype._sendSpans = function(spans, done) {
        var e_1, _a;
        try {
            for(var spans_1 = __values(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()){
                var span = spans_1_1.value;
                console.dir(this._exportInfo(span), {
                    depth: 3
                });
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (spans_1_1 && !spans_1_1.done && (_a = spans_1.return)) _a.call(spans_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        if (done) return done({
            code: (0, _core.ExportResultCode).SUCCESS
        });
    };
    return ConsoleSpanExporter;
}();

},{"@opentelemetry/core":"dBsXh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dBsXh":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "W3CBaggagePropagator", ()=>(0, _w3CbaggagePropagator.W3CBaggagePropagator));
parcelHelpers.export(exports, "AnchoredClock", ()=>(0, _anchoredClock.AnchoredClock));
parcelHelpers.export(exports, "isAttributeKey", ()=>(0, _attributes.isAttributeKey));
parcelHelpers.export(exports, "isAttributeValue", ()=>(0, _attributes.isAttributeValue));
parcelHelpers.export(exports, "sanitizeAttributes", ()=>(0, _attributes.sanitizeAttributes));
parcelHelpers.export(exports, "globalErrorHandler", ()=>(0, _globalErrorHandler.globalErrorHandler));
parcelHelpers.export(exports, "setGlobalErrorHandler", ()=>(0, _globalErrorHandler.setGlobalErrorHandler));
parcelHelpers.export(exports, "loggingErrorHandler", ()=>(0, _loggingErrorHandler.loggingErrorHandler));
parcelHelpers.export(exports, "addHrTimes", ()=>(0, _time.addHrTimes));
parcelHelpers.export(exports, "getTimeOrigin", ()=>(0, _time.getTimeOrigin));
parcelHelpers.export(exports, "hrTime", ()=>(0, _time.hrTime));
parcelHelpers.export(exports, "hrTimeDuration", ()=>(0, _time.hrTimeDuration));
parcelHelpers.export(exports, "hrTimeToMicroseconds", ()=>(0, _time.hrTimeToMicroseconds));
parcelHelpers.export(exports, "hrTimeToMilliseconds", ()=>(0, _time.hrTimeToMilliseconds));
parcelHelpers.export(exports, "hrTimeToNanoseconds", ()=>(0, _time.hrTimeToNanoseconds));
parcelHelpers.export(exports, "hrTimeToTimeStamp", ()=>(0, _time.hrTimeToTimeStamp));
parcelHelpers.export(exports, "isTimeInput", ()=>(0, _time.isTimeInput));
parcelHelpers.export(exports, "isTimeInputHrTime", ()=>(0, _time.isTimeInputHrTime));
parcelHelpers.export(exports, "millisToHrTime", ()=>(0, _time.millisToHrTime));
parcelHelpers.export(exports, "timeInputToHrTime", ()=>(0, _time.timeInputToHrTime));
parcelHelpers.export(exports, "hexToBinary", ()=>(0, _hexToBinary.hexToBinary));
parcelHelpers.export(exports, "ExportResultCode", ()=>(0, _exportResult.ExportResultCode));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _platform.RandomIdGenerator));
parcelHelpers.export(exports, "SDK_INFO", ()=>(0, _platform.SDK_INFO));
parcelHelpers.export(exports, "_globalThis", ()=>(0, _platform._globalThis));
parcelHelpers.export(exports, "getEnv", ()=>(0, _platform.getEnv));
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>(0, _platform.getEnvWithoutDefaults));
parcelHelpers.export(exports, "hexToBase64", ()=>(0, _platform.hexToBase64));
parcelHelpers.export(exports, "otperformance", ()=>(0, _platform.otperformance));
parcelHelpers.export(exports, "unrefTimer", ()=>(0, _platform.unrefTimer));
parcelHelpers.export(exports, "CompositePropagator", ()=>(0, _composite.CompositePropagator));
parcelHelpers.export(exports, "TRACE_PARENT_HEADER", ()=>(0, _w3CtraceContextPropagator.TRACE_PARENT_HEADER));
parcelHelpers.export(exports, "TRACE_STATE_HEADER", ()=>(0, _w3CtraceContextPropagator.TRACE_STATE_HEADER));
parcelHelpers.export(exports, "W3CTraceContextPropagator", ()=>(0, _w3CtraceContextPropagator.W3CTraceContextPropagator));
parcelHelpers.export(exports, "parseTraceParent", ()=>(0, _w3CtraceContextPropagator.parseTraceParent));
parcelHelpers.export(exports, "RPCType", ()=>(0, _rpcMetadata.RPCType));
parcelHelpers.export(exports, "deleteRPCMetadata", ()=>(0, _rpcMetadata.deleteRPCMetadata));
parcelHelpers.export(exports, "getRPCMetadata", ()=>(0, _rpcMetadata.getRPCMetadata));
parcelHelpers.export(exports, "setRPCMetadata", ()=>(0, _rpcMetadata.setRPCMetadata));
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>(0, _alwaysOffSampler.AlwaysOffSampler));
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>(0, _alwaysOnSampler.AlwaysOnSampler));
parcelHelpers.export(exports, "ParentBasedSampler", ()=>(0, _parentBasedSampler.ParentBasedSampler));
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>(0, _traceIdRatioBasedSampler.TraceIdRatioBasedSampler));
parcelHelpers.export(exports, "isTracingSuppressed", ()=>(0, _suppressTracing.isTracingSuppressed));
parcelHelpers.export(exports, "suppressTracing", ()=>(0, _suppressTracing.suppressTracing));
parcelHelpers.export(exports, "unsuppressTracing", ()=>(0, _suppressTracing.unsuppressTracing));
parcelHelpers.export(exports, "TraceState", ()=>(0, _traceState.TraceState));
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_ATTRIBUTE_COUNT_LIMIT));
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", ()=>(0, _environment.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT));
parcelHelpers.export(exports, "DEFAULT_ENVIRONMENT", ()=>(0, _environment.DEFAULT_ENVIRONMENT));
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT));
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT));
parcelHelpers.export(exports, "parseEnvironment", ()=>(0, _environment.parseEnvironment));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "TracesSamplerValues", ()=>(0, _sampling.TracesSamplerValues));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _timeout.TimeoutError));
parcelHelpers.export(exports, "callWithTimeout", ()=>(0, _timeout.callWithTimeout));
parcelHelpers.export(exports, "isUrlIgnored", ()=>(0, _url.isUrlIgnored));
parcelHelpers.export(exports, "urlMatches", ()=>(0, _url.urlMatches));
parcelHelpers.export(exports, "isWrapped", ()=>(0, _wrap.isWrapped));
parcelHelpers.export(exports, "BindOnceFuture", ()=>(0, _callback.BindOnceFuture));
parcelHelpers.export(exports, "VERSION", ()=>(0, _version.VERSION));
parcelHelpers.export(exports, "baggageUtils", ()=>baggageUtils);
parcelHelpers.export(exports, "internal", ()=>internal);
var _w3CbaggagePropagator = require("./baggage/propagation/W3CBaggagePropagator");
var _anchoredClock = require("./common/anchored-clock");
var _attributes = require("./common/attributes");
var _globalErrorHandler = require("./common/global-error-handler");
var _loggingErrorHandler = require("./common/logging-error-handler");
var _time = require("./common/time");
var _hexToBinary = require("./common/hex-to-binary");
var _exportResult = require("./ExportResult");
var _utils = require("./baggage/utils");
var _platform = require("./platform");
var _composite = require("./propagation/composite");
var _w3CtraceContextPropagator = require("./trace/W3CTraceContextPropagator");
var _rpcMetadata = require("./trace/rpc-metadata");
var _alwaysOffSampler = require("./trace/sampler/AlwaysOffSampler");
var _alwaysOnSampler = require("./trace/sampler/AlwaysOnSampler");
var _parentBasedSampler = require("./trace/sampler/ParentBasedSampler");
var _traceIdRatioBasedSampler = require("./trace/sampler/TraceIdRatioBasedSampler");
var _suppressTracing = require("./trace/suppress-tracing");
var _traceState = require("./trace/TraceState");
var _environment = require("./utils/environment");
var _merge = require("./utils/merge");
var _sampling = require("./utils/sampling");
var _timeout = require("./utils/timeout");
var _url = require("./utils/url");
var _wrap = require("./utils/wrap");
var _callback = require("./utils/callback");
var _version = require("./version");
var _exporter = require("./internal/exporter");
var baggageUtils = {
    getKeyPairs: (0, _utils.getKeyPairs),
    serializeKeyPairs: (0, _utils.serializeKeyPairs),
    parseKeyPairsIntoRecord: (0, _utils.parseKeyPairsIntoRecord),
    parsePairKeyValue: (0, _utils.parsePairKeyValue)
};
var internal = {
    _export: (0, _exporter._export)
};

},{"./baggage/propagation/W3CBaggagePropagator":false,"./common/anchored-clock":false,"./common/attributes":false,"./common/global-error-handler":"hKz5C","./common/logging-error-handler":false,"./common/time":"oOZeC","./common/hex-to-binary":false,"./ExportResult":"2fJSh","./baggage/utils":"kLEpF","./platform":"a3NCV","./propagation/composite":false,"./trace/W3CTraceContextPropagator":"j30mQ","./trace/rpc-metadata":false,"./trace/sampler/AlwaysOffSampler":false,"./trace/sampler/AlwaysOnSampler":false,"./trace/sampler/ParentBasedSampler":false,"./trace/sampler/TraceIdRatioBasedSampler":false,"./trace/suppress-tracing":false,"./trace/TraceState":false,"./utils/environment":false,"./utils/merge":false,"./utils/sampling":false,"./utils/timeout":false,"./utils/url":false,"./utils/wrap":false,"./utils/callback":"Wira8","./version":false,"./internal/exporter":"4s27R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hKz5C":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */ parcelHelpers.export(exports, "setGlobalErrorHandler", ()=>setGlobalErrorHandler);
/**
 * Return the global error handler
 * @param {Exception} ex
 */ parcelHelpers.export(exports, "globalErrorHandler", ()=>globalErrorHandler);
var _loggingErrorHandler = require("./logging-error-handler");
/** The global error handler delegate */ var delegateHandler = (0, _loggingErrorHandler.loggingErrorHandler)();
function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
}
function globalErrorHandler(ex) {
    try {
        delegateHandler(ex);
    } catch (_a) {} // eslint-disable-line no-empty
}

},{"./logging-error-handler":"8D49l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8D49l":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */ parcelHelpers.export(exports, "loggingErrorHandler", ()=>loggingErrorHandler);
var _api = require("@opentelemetry/api");
function loggingErrorHandler() {
    return function(ex) {
        (0, _api.diag).error(stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */ function stringifyException(ex) {
    if (typeof ex === 'string') return ex;
    else return JSON.stringify(flattenException(ex));
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */ function flattenException(ex) {
    var result = {};
    var current = ex;
    while(current !== null){
        Object.getOwnPropertyNames(current).forEach(function(propertyName) {
            if (result[propertyName]) return;
            var value = current[propertyName];
            if (value) result[propertyName] = String(value);
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6AC4z":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "baggageEntryMetadataFromString", ()=>(0, _utils.baggageEntryMetadataFromString));
// Context APIs
parcelHelpers.export(exports, "createContextKey", ()=>(0, _context.createContextKey));
parcelHelpers.export(exports, "ROOT_CONTEXT", ()=>(0, _context.ROOT_CONTEXT));
// Diag APIs
parcelHelpers.export(exports, "DiagConsoleLogger", ()=>(0, _consoleLogger.DiagConsoleLogger));
parcelHelpers.export(exports, "DiagLogLevel", ()=>(0, _types.DiagLogLevel));
// Metrics APIs
parcelHelpers.export(exports, "createNoopMeter", ()=>(0, _noopMeter.createNoopMeter));
parcelHelpers.export(exports, "ValueType", ()=>(0, _metric.ValueType));
// Propagation APIs
parcelHelpers.export(exports, "defaultTextMapGetter", ()=>(0, _textMapPropagator.defaultTextMapGetter));
parcelHelpers.export(exports, "defaultTextMapSetter", ()=>(0, _textMapPropagator.defaultTextMapSetter));
parcelHelpers.export(exports, "ProxyTracer", ()=>(0, _proxyTracer.ProxyTracer));
parcelHelpers.export(exports, "ProxyTracerProvider", ()=>(0, _proxyTracerProvider.ProxyTracerProvider));
parcelHelpers.export(exports, "SamplingDecision", ()=>(0, _samplingResult.SamplingDecision));
parcelHelpers.export(exports, "SpanKind", ()=>(0, _spanKind.SpanKind));
parcelHelpers.export(exports, "SpanStatusCode", ()=>(0, _status.SpanStatusCode));
parcelHelpers.export(exports, "TraceFlags", ()=>(0, _traceFlags.TraceFlags));
parcelHelpers.export(exports, "createTraceState", ()=>(0, _utils1.createTraceState));
parcelHelpers.export(exports, "isSpanContextValid", ()=>(0, _spancontextUtils.isSpanContextValid));
parcelHelpers.export(exports, "isValidTraceId", ()=>(0, _spancontextUtils.isValidTraceId));
parcelHelpers.export(exports, "isValidSpanId", ()=>(0, _spancontextUtils.isValidSpanId));
parcelHelpers.export(exports, "INVALID_SPANID", ()=>(0, _invalidSpanConstants.INVALID_SPANID));
parcelHelpers.export(exports, "INVALID_TRACEID", ()=>(0, _invalidSpanConstants.INVALID_TRACEID));
parcelHelpers.export(exports, "INVALID_SPAN_CONTEXT", ()=>(0, _invalidSpanConstants.INVALID_SPAN_CONTEXT));
// Named export.
parcelHelpers.export(exports, "context", ()=>(0, _contextApi.context));
parcelHelpers.export(exports, "diag", ()=>(0, _diagApi.diag));
parcelHelpers.export(exports, "metrics", ()=>(0, _metricsApi.metrics));
parcelHelpers.export(exports, "propagation", ()=>(0, _propagationApi.propagation));
parcelHelpers.export(exports, "trace", ()=>(0, _traceApi.trace));
var _utils = require("./baggage/utils");
var _context = require("./context/context");
var _consoleLogger = require("./diag/consoleLogger");
var _types = require("./diag/types");
var _noopMeter = require("./metrics/NoopMeter");
var _metric = require("./metrics/Metric");
var _textMapPropagator = require("./propagation/TextMapPropagator");
var _proxyTracer = require("./trace/ProxyTracer");
var _proxyTracerProvider = require("./trace/ProxyTracerProvider");
var _samplingResult = require("./trace/SamplingResult");
var _spanKind = require("./trace/span_kind");
var _status = require("./trace/status");
var _traceFlags = require("./trace/trace_flags");
var _utils1 = require("./trace/internal/utils");
var _spancontextUtils = require("./trace/spancontext-utils");
var _invalidSpanConstants = require("./trace/invalid-span-constants");
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
var _contextApi = require("./context-api");
var _diagApi = require("./diag-api");
var _metricsApi = require("./metrics-api");
var _propagationApi = require("./propagation-api");
var _traceApi = require("./trace-api");
// Default export.
exports.default = {
    context: (0, _contextApi.context),
    diag: (0, _diagApi.diag),
    metrics: (0, _metricsApi.metrics),
    propagation: (0, _propagationApi.propagation),
    trace: (0, _traceApi.trace)
};

},{"./baggage/utils":"1FtTJ","./context/context":"8Hj8X","./diag/consoleLogger":"cqEiU","./diag/types":"f917i","./metrics/NoopMeter":"fl46x","./metrics/Metric":"hbEfG","./propagation/TextMapPropagator":"fbpGl","./trace/ProxyTracer":"4RJSP","./trace/ProxyTracerProvider":"5OsDv","./trace/SamplingResult":"9hHpb","./trace/span_kind":"8JdQL","./trace/status":"caBJ1","./trace/trace_flags":"58Fpe","./trace/internal/utils":"43yZb","./trace/spancontext-utils":"g40FB","./trace/invalid-span-constants":"9v7Cm","./context-api":"5ZkHn","./diag-api":"3Hdm6","./metrics-api":"dKL2F","./propagation-api":"Nd6jQ","./trace-api":"hMrLV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FtTJ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a new Baggage with optional entries
 *
 * @param entries An array of baggage entries the new baggage should contain
 */ parcelHelpers.export(exports, "createBaggage", ()=>createBaggage);
/**
 * Create a serializable BaggageEntryMetadata object from a string.
 *
 * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
 *
 */ parcelHelpers.export(exports, "baggageEntryMetadataFromString", ()=>baggageEntryMetadataFromString);
var _diag = require("../api/diag");
var _baggageImpl = require("./internal/baggage-impl");
var _symbol = require("./internal/symbol");
var diag = (0, _diag.DiagAPI).instance();
function createBaggage(entries) {
    if (entries === void 0) entries = {};
    return new (0, _baggageImpl.BaggageImpl)(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
    if (typeof str !== 'string') {
        diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
        str = '';
    }
    return {
        __TYPE__: (0, _symbol.baggageEntryMetadataSymbol),
        toString: function() {
            return str;
        }
    };
}

},{"../api/diag":"gZAmK","./internal/baggage-impl":"1JRmx","./internal/symbol":"bwKBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZAmK":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DiagAPI", ()=>DiagAPI);
var _componentLogger = require("../diag/ComponentLogger");
var _logLevelLogger = require("../diag/internal/logLevelLogger");
var _types = require("../diag/types");
var _globalUtils = require("../internal/global-utils");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = 'diag';
/**
 * Singleton object which represents the entry point to the OpenTelemetry internal
 * diagnostic API
 */ var DiagAPI = /** @class */ function() {
    /**
     * Private internal constructor
     * @private
     */ function DiagAPI() {
        function _logProxy(funcName) {
            return function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                var logger = (0, _globalUtils.getGlobal)('diag');
                // shortcut if logger not set
                if (!logger) return;
                return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
            };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        var setLogger = function(logger, optionsOrLogLevel) {
            var _a, _b, _c;
            if (optionsOrLogLevel === void 0) optionsOrLogLevel = {
                logLevel: (0, _types.DiagLogLevel).INFO
            };
            if (logger === self) {
                // There isn't much we can do here.
                // Logging to the console might break the user application.
                // Try to log to self. If a logger was previously registered it will receive the log.
                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === 'number') optionsOrLogLevel = {
                logLevel: optionsOrLogLevel
            };
            var oldLogger = (0, _globalUtils.getGlobal)('diag');
            var newLogger = (0, _logLevelLogger.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : (0, _types.DiagLogLevel).INFO, logger);
            // There already is an logger registered. We'll let it know before overwriting it.
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : '<failed to generate stacktrace>';
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return (0, _globalUtils.registerGlobal)('diag', newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
            (0, _globalUtils.unregisterGlobal)(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
            return new (0, _componentLogger.DiagComponentLogger)(options);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
    }
    /** Get the singleton instance of the DiagAPI API */ DiagAPI.instance = function() {
        if (!this._instance) this._instance = new DiagAPI();
        return this._instance;
    };
    return DiagAPI;
}();

},{"../diag/ComponentLogger":"3nsjJ","../diag/internal/logLevelLogger":"d3Qu4","../diag/types":"f917i","../internal/global-utils":"h4XAN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3nsjJ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DiagComponentLogger", ()=>DiagComponentLogger);
var _globalUtils = require("../internal/global-utils");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Component Logger which is meant to be used as part of any component which
 * will add automatically additional namespace in front of the log message.
 * It will then forward all message to global diag logger
 * @example
 * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
 * cLogger.debug('test');
 * // @opentelemetry/instrumentation-http test
 */ var DiagComponentLogger = /** @class */ function() {
    function DiagComponentLogger(props) {
        this._namespace = props.namespace || 'DiagComponentLogger';
    }
    DiagComponentLogger.prototype.debug = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        return logProxy('debug', this._namespace, args);
    };
    DiagComponentLogger.prototype.error = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        return logProxy('error', this._namespace, args);
    };
    DiagComponentLogger.prototype.info = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        return logProxy('info', this._namespace, args);
    };
    DiagComponentLogger.prototype.warn = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        return logProxy('warn', this._namespace, args);
    };
    DiagComponentLogger.prototype.verbose = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        return logProxy('verbose', this._namespace, args);
    };
    return DiagComponentLogger;
}();
function logProxy(funcName, namespace, args) {
    var logger = (0, _globalUtils.getGlobal)('diag');
    // shortcut if logger not set
    if (!logger) return;
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}

},{"../internal/global-utils":"h4XAN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4XAN":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerGlobal", ()=>registerGlobal);
parcelHelpers.export(exports, "getGlobal", ()=>getGlobal);
parcelHelpers.export(exports, "unregisterGlobal", ()=>unregisterGlobal);
var _platform = require("../platform");
var _version = require("../version");
var _semver = require("./semver");
var major = (0, _version.VERSION).split('.')[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = (0, _platform._globalThis);
function registerGlobal(type, instance, diag, allowOverride) {
    var _a;
    if (allowOverride === void 0) allowOverride = false;
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: (0, _version.VERSION)
    };
    if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== (0, _version.VERSION)) {
        // All registered APIs must be of the same version exactly
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + (0, _version.VERSION));
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + (0, _version.VERSION) + ".");
    return true;
}
function getGlobal(type) {
    var _a, _b;
    var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
    if (!globalVersion || !(0, _semver.isCompatible)(globalVersion)) return;
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + (0, _version.VERSION) + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) delete api[type];
}

},{"../platform":"dO2ZQ","../version":"k412A","./semver":"9IXna","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dO2ZQ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _globalThis = require("./globalThis");
parcelHelpers.exportAll(_globalThis, exports);

},{"./globalThis":"dRquK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dRquK":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Updates to this file should also be replicated to @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */ /** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>_globalThis);
var global = arguments[3];
var _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"k412A":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // this is autogenerated file, see scripts/version-update.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
var VERSION = '1.9.0';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9IXna":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
 *
 * The returned function has the following semantics:
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param ownVersion version which should be checked against
 */ parcelHelpers.export(exports, "_makeCompatibilityCheck", ()=>_makeCompatibilityCheck);
parcelHelpers.export(exports, "isCompatible", ()=>isCompatible);
var _version = require("../version");
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = new Set([
        ownVersion
    ]);
    var rejectedVersions = new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) // we cannot guarantee compatibility so we always return noop
    return function() {
        return false;
    };
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
    };
    // if ownVersion has a prerelease tag, versions must match exactly
    if (ownVersionParsed.prerelease != null) return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
    };
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) return true;
        if (rejectedVersions.has(globalVersion)) return false;
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) // cannot parse other version
        // we cannot guarantee compatibility so we always noop
        return _reject(globalVersion);
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4]
        };
        // if globalVersion has a prerelease tag, versions must match exactly
        if (globalVersionParsed.prerelease != null) return _reject(globalVersion);
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) return _reject(globalVersion);
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) return _accept(globalVersion);
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) return _accept(globalVersion);
        return _reject(globalVersion);
    };
}
var isCompatible = _makeCompatibilityCheck((0, _version.VERSION));

},{"../version":"k412A","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d3Qu4":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createLogLevelDiagLogger", ()=>createLogLevelDiagLogger);
var _types = require("../types");
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < (0, _types.DiagLogLevel).NONE) maxLevel = (0, _types.DiagLogLevel).NONE;
    else if (maxLevel > (0, _types.DiagLogLevel).ALL) maxLevel = (0, _types.DiagLogLevel).ALL;
    // In case the logger is null or undefined
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) return theFunc.bind(logger);
        return function() {};
    }
    return {
        error: _filterFunc('error', (0, _types.DiagLogLevel).ERROR),
        warn: _filterFunc('warn', (0, _types.DiagLogLevel).WARN),
        info: _filterFunc('info', (0, _types.DiagLogLevel).INFO),
        debug: _filterFunc('debug', (0, _types.DiagLogLevel).DEBUG),
        verbose: _filterFunc('verbose', (0, _types.DiagLogLevel).VERBOSE)
    };
}

},{"../types":"f917i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f917i":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DiagLogLevel", ()=>DiagLogLevel);
var DiagLogLevel;
(function(DiagLogLevel) {
    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */ DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
    /** Identifies an error scenario */ DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
    /** Identifies a warning scenario */ DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
    /** General informational log message */ DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
    /** General debug log message */ DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
    /**
     * Detailed trace level logging should only be used for development, should only be set
     * in a development environment.
     */ DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
    /** Used to set the logging level to include all logging */ DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1JRmx":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaggageImpl", ()=>BaggageImpl);
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = /** @class */ function() {
    function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
    }
    BaggageImpl.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) return undefined;
        return Object.assign({}, entry);
    };
    BaggageImpl.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
            var _b = __read(_a, 2), k = _b[0], v = _b[1];
            return [
                k,
                v
            ];
        });
    };
    BaggageImpl.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntries = function() {
        var e_1, _a;
        var keys = [];
        for(var _i = 0; _i < arguments.length; _i++)keys[_i] = arguments[_i];
        var newBaggage = new BaggageImpl(this._entries);
        try {
            for(var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()){
                var key = keys_1_1.value;
                newBaggage._entries.delete(key);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return newBaggage;
    };
    BaggageImpl.prototype.clear = function() {
        return new BaggageImpl();
    };
    return BaggageImpl;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bwKBN":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Symbol used to make BaggageEntryMetadata an opaque type
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "baggageEntryMetadataSymbol", ()=>baggageEntryMetadataSymbol);
var baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Hj8X":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Get a key to uniquely identify a context value */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createContextKey", ()=>createContextKey);
parcelHelpers.export(exports, "ROOT_CONTEXT", ()=>ROOT_CONTEXT);
function createContextKey(description) {
    // The specification states that for the same input, multiple calls should
    // return different keys. Due to the nature of the JS dependency management
    // system, this creates problems where multiple versions of some package
    // could hold different keys for the same property.
    //
    // Therefore, we use Symbol.for which returns the same key for the same input.
    return Symbol.for(description);
}
var BaseContext = /** @class */ function() {
    /**
     * Construct a new context which inherits values from an optional parent context.
     *
     * @param parentContext a context from which to inherit values
     */ function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function(key) {
            return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function(key) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext;
}();
var ROOT_CONTEXT = new BaseContext();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cqEiU":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DiagConsoleLogger", ()=>DiagConsoleLogger);
var consoleMap = [
    {
        n: 'error',
        c: 'error'
    },
    {
        n: 'warn',
        c: 'warn'
    },
    {
        n: 'info',
        c: 'info'
    },
    {
        n: 'debug',
        c: 'debug'
    },
    {
        n: 'verbose',
        c: 'trace'
    }
];
/**
 * A simple Immutable Console based diagnostic logger which will output any messages to the Console.
 * If you want to limit the amount of logging to a specific level or lower use the
 * {@link createLogLevelDiagLogger}
 */ var DiagConsoleLogger = /** @class */ function() {
    function DiagConsoleLogger() {
        function _consoleFunc(funcName) {
            return function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                if (console) {
                    // Some environments only expose the console when the F12 developer console is open
                    // eslint-disable-next-line no-console
                    var theFunc = console[funcName];
                    if (typeof theFunc !== 'function') // Not all environments support all functions
                    // eslint-disable-next-line no-console
                    theFunc = console.log;
                    // One last final check
                    if (typeof theFunc === 'function') return theFunc.apply(console, args);
                }
            };
        }
        for(var i = 0; i < consoleMap.length; i++)this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
    }
    return DiagConsoleLogger;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fl46x":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopMeter", ()=>NoopMeter);
parcelHelpers.export(exports, "NoopMetric", ()=>NoopMetric);
parcelHelpers.export(exports, "NoopCounterMetric", ()=>NoopCounterMetric);
parcelHelpers.export(exports, "NoopUpDownCounterMetric", ()=>NoopUpDownCounterMetric);
parcelHelpers.export(exports, "NoopGaugeMetric", ()=>NoopGaugeMetric);
parcelHelpers.export(exports, "NoopHistogramMetric", ()=>NoopHistogramMetric);
parcelHelpers.export(exports, "NoopObservableMetric", ()=>NoopObservableMetric);
parcelHelpers.export(exports, "NoopObservableCounterMetric", ()=>NoopObservableCounterMetric);
parcelHelpers.export(exports, "NoopObservableGaugeMetric", ()=>NoopObservableGaugeMetric);
parcelHelpers.export(exports, "NoopObservableUpDownCounterMetric", ()=>NoopObservableUpDownCounterMetric);
parcelHelpers.export(exports, "NOOP_METER", ()=>NOOP_METER);
parcelHelpers.export(exports, "NOOP_COUNTER_METRIC", ()=>NOOP_COUNTER_METRIC);
parcelHelpers.export(exports, "NOOP_GAUGE_METRIC", ()=>NOOP_GAUGE_METRIC);
parcelHelpers.export(exports, "NOOP_HISTOGRAM_METRIC", ()=>NOOP_HISTOGRAM_METRIC);
parcelHelpers.export(exports, "NOOP_UP_DOWN_COUNTER_METRIC", ()=>NOOP_UP_DOWN_COUNTER_METRIC);
parcelHelpers.export(exports, "NOOP_OBSERVABLE_COUNTER_METRIC", ()=>NOOP_OBSERVABLE_COUNTER_METRIC);
parcelHelpers.export(exports, "NOOP_OBSERVABLE_GAUGE_METRIC", ()=>NOOP_OBSERVABLE_GAUGE_METRIC);
parcelHelpers.export(exports, "NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC", ()=>NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC);
/**
 * Create a no-op Meter
 */ parcelHelpers.export(exports, "createNoopMeter", ()=>createNoopMeter);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
 * constant NoopMetrics for all of its methods.
 */ var NoopMeter = /** @class */ function() {
    function NoopMeter() {}
    /**
     * @see {@link Meter.createGauge}
     */ NoopMeter.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
    };
    /**
     * @see {@link Meter.createHistogram}
     */ NoopMeter.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
    };
    /**
     * @see {@link Meter.createCounter}
     */ NoopMeter.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createUpDownCounter}
     */ NoopMeter.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableGauge}
     */ NoopMeter.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    /**
     * @see {@link Meter.createObservableCounter}
     */ NoopMeter.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableUpDownCounter}
     */ NoopMeter.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.addBatchObservableCallback}
     */ NoopMeter.prototype.addBatchObservableCallback = function(_callback, _observables) {};
    /**
     * @see {@link Meter.removeBatchObservableCallback}
     */ NoopMeter.prototype.removeBatchObservableCallback = function(_callback) {};
    return NoopMeter;
}();
var NoopMetric = /** @class */ function() {
    function NoopMetric() {}
    return NoopMetric;
}();
var NoopCounterMetric = /** @class */ function(_super) {
    __extends(NoopCounterMetric, _super);
    function NoopCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric.prototype.add = function(_value, _attributes) {};
    return NoopCounterMetric;
}(NoopMetric);
var NoopUpDownCounterMetric = /** @class */ function(_super) {
    __extends(NoopUpDownCounterMetric, _super);
    function NoopUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric.prototype.add = function(_value, _attributes) {};
    return NoopUpDownCounterMetric;
}(NoopMetric);
var NoopGaugeMetric = /** @class */ function(_super) {
    __extends(NoopGaugeMetric, _super);
    function NoopGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopGaugeMetric.prototype.record = function(_value, _attributes) {};
    return NoopGaugeMetric;
}(NoopMetric);
var NoopHistogramMetric = /** @class */ function(_super) {
    __extends(NoopHistogramMetric, _super);
    function NoopHistogramMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric.prototype.record = function(_value, _attributes) {};
    return NoopHistogramMetric;
}(NoopMetric);
var NoopObservableMetric = /** @class */ function() {
    function NoopObservableMetric() {}
    NoopObservableMetric.prototype.addCallback = function(_callback) {};
    NoopObservableMetric.prototype.removeCallback = function(_callback) {};
    return NoopObservableMetric;
}();
var NoopObservableCounterMetric = /** @class */ function(_super) {
    __extends(NoopObservableCounterMetric, _super);
    function NoopObservableCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric;
}(NoopObservableMetric);
var NoopObservableGaugeMetric = /** @class */ function(_super) {
    __extends(NoopObservableGaugeMetric, _super);
    function NoopObservableGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric;
}(NoopObservableMetric);
var NoopObservableUpDownCounterMetric = /** @class */ function(_super) {
    __extends(NoopObservableUpDownCounterMetric, _super);
    function NoopObservableUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric;
}(NoopObservableMetric);
var NOOP_METER = new NoopMeter();
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
function createNoopMeter() {
    return NOOP_METER;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hbEfG":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** The Type of value. It describes how the data is reported. */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ValueType", ()=>ValueType);
var ValueType;
(function(ValueType) {
    ValueType[ValueType["INT"] = 0] = "INT";
    ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
})(ValueType || (ValueType = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fbpGl":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultTextMapGetter", ()=>defaultTextMapGetter);
parcelHelpers.export(exports, "defaultTextMapSetter", ()=>defaultTextMapSetter);
var defaultTextMapGetter = {
    get: function(carrier, key) {
        if (carrier == null) return undefined;
        return carrier[key];
    },
    keys: function(carrier) {
        if (carrier == null) return [];
        return Object.keys(carrier);
    }
};
var defaultTextMapSetter = {
    set: function(carrier, key, value) {
        if (carrier == null) return;
        carrier[key] = value;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4RJSP":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProxyTracer", ()=>ProxyTracer);
var _noopTracer = require("./NoopTracer");
var NOOP_TRACER = new (0, _noopTracer.NoopTracer)();
/**
 * Proxy tracer provided by the proxy tracer provider
 */ var ProxyTracer = /** @class */ function() {
    function ProxyTracer(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    ProxyTracer.prototype.startSpan = function(name, options, context) {
        return this._getTracer().startSpan(name, options, context);
    };
    ProxyTracer.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    /**
     * Try to get a tracer from the proxy tracer provider.
     * If the proxy tracer provider has no delegate, return a noop tracer.
     */ ProxyTracer.prototype._getTracer = function() {
        if (this._delegate) return this._delegate;
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) return NOOP_TRACER;
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer;
}();

},{"./NoopTracer":"ciEOJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ciEOJ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopTracer", ()=>NoopTracer);
var _context = require("../api/context");
var _contextUtils = require("../trace/context-utils");
var _nonRecordingSpan = require("./NonRecordingSpan");
var _spancontextUtils = require("./spancontext-utils");
var contextApi = (0, _context.ContextAPI).getInstance();
/**
 * No-op implementations of {@link Tracer}.
 */ var NoopTracer = /** @class */ function() {
    function NoopTracer() {}
    // startSpan starts a noop span.
    NoopTracer.prototype.startSpan = function(name, options, context) {
        if (context === void 0) context = contextApi.active();
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) return new (0, _nonRecordingSpan.NonRecordingSpan)();
        var parentFromContext = context && (0, _contextUtils.getSpanContext)(context);
        if (isSpanContext(parentFromContext) && (0, _spancontextUtils.isSpanContextValid)(parentFromContext)) return new (0, _nonRecordingSpan.NonRecordingSpan)(parentFromContext);
        else return new (0, _nonRecordingSpan.NonRecordingSpan)();
    };
    NoopTracer.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) return;
        else if (arguments.length === 2) fn = arg2;
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        } else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = (0, _contextUtils.setSpan)(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, undefined, span);
    };
    return NoopTracer;
}();
function isSpanContext(spanContext) {
    return typeof spanContext === 'object' && typeof spanContext['spanId'] === 'string' && typeof spanContext['traceId'] === 'string' && typeof spanContext['traceFlags'] === 'number';
}

},{"../api/context":"1ZQ7h","../trace/context-utils":"c8keb","./NonRecordingSpan":"80R4i","./spancontext-utils":"g40FB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ZQ7h":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContextAPI", ()=>ContextAPI);
var _noopContextManager = require("../context/NoopContextManager");
var _globalUtils = require("../internal/global-utils");
var _diag = require("./diag");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = 'context';
var NOOP_CONTEXT_MANAGER = new (0, _noopContextManager.NoopContextManager)();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */ var ContextAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function ContextAPI() {}
    /** Get the singleton instance of the Context API */ ContextAPI.getInstance = function() {
        if (!this._instance) this._instance = new ContextAPI();
        return this._instance;
    };
    /**
     * Set the current context manager.
     *
     * @returns true if the context manager was successfully registered, else false
     */ ContextAPI.prototype.setGlobalContextManager = function(contextManager) {
        return (0, _globalUtils.registerGlobal)(API_NAME, contextManager, (0, _diag.DiagAPI).instance());
    };
    /**
     * Get the currently active context
     */ ContextAPI.prototype.active = function() {
        return this._getContextManager().active();
    };
    /**
     * Execute a function with an active context
     *
     * @param context context to be active during function execution
     * @param fn function to execute in a context
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */ ContextAPI.prototype.with = function(context, fn, thisArg) {
        var _a;
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++)args[_i - 3] = arguments[_i];
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray([
            context,
            fn,
            thisArg
        ], __read(args), false));
    };
    /**
     * Bind a context to a target function or event emitter
     *
     * @param context context to bind to the event emitter or function. Defaults to the currently active context
     * @param target function or event emitter to bind
     */ ContextAPI.prototype.bind = function(context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI.prototype._getContextManager = function() {
        return (0, _globalUtils.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    };
    /** Disable and remove the global context manager */ ContextAPI.prototype.disable = function() {
        this._getContextManager().disable();
        (0, _globalUtils.unregisterGlobal)(API_NAME, (0, _diag.DiagAPI).instance());
    };
    return ContextAPI;
}();

},{"../context/NoopContextManager":"gHU7f","../internal/global-utils":"h4XAN","./diag":"gZAmK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gHU7f":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopContextManager", ()=>NoopContextManager);
var _context = require("./context");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = /** @class */ function() {
    function NoopContextManager() {}
    NoopContextManager.prototype.active = function() {
        return 0, _context.ROOT_CONTEXT;
    };
    NoopContextManager.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++)args[_i - 3] = arguments[_i];
        return fn.call.apply(fn, __spreadArray([
            thisArg
        ], __read(args), false));
    };
    NoopContextManager.prototype.bind = function(_context, target) {
        return target;
    };
    NoopContextManager.prototype.enable = function() {
        return this;
    };
    NoopContextManager.prototype.disable = function() {
        return this;
    };
    return NoopContextManager;
}();

},{"./context":"8Hj8X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c8keb":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return the span if one exists
 *
 * @param context context to get span from
 */ parcelHelpers.export(exports, "getSpan", ()=>getSpan);
/**
 * Gets the span from the current context, if one exists.
 */ parcelHelpers.export(exports, "getActiveSpan", ()=>getActiveSpan);
/**
 * Set the span on a context
 *
 * @param context context to use as parent
 * @param span span to set active
 */ parcelHelpers.export(exports, "setSpan", ()=>setSpan);
/**
 * Remove current span stored in the context
 *
 * @param context context to delete span from
 */ parcelHelpers.export(exports, "deleteSpan", ()=>deleteSpan);
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context context to set active span on
 * @param spanContext span context to be wrapped
 */ parcelHelpers.export(exports, "setSpanContext", ()=>setSpanContext);
/**
 * Get the span context of the span if it exists.
 *
 * @param context context to get values from
 */ parcelHelpers.export(exports, "getSpanContext", ()=>getSpanContext);
var _context = require("../context/context");
var _nonRecordingSpan = require("./NonRecordingSpan");
var _context1 = require("../api/context");
/**
 * span key
 */ var SPAN_KEY = (0, _context.createContextKey)('OpenTelemetry Context Key SPAN');
function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
}
function getActiveSpan() {
    return getSpan((0, _context1.ContextAPI).getInstance().active());
}
function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
}
function setSpanContext(context, spanContext) {
    return setSpan(context, new (0, _nonRecordingSpan.NonRecordingSpan)(spanContext));
}
function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
}

},{"../context/context":"8Hj8X","./NonRecordingSpan":"80R4i","../api/context":"1ZQ7h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"80R4i":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NonRecordingSpan", ()=>NonRecordingSpan);
var _invalidSpanConstants = require("./invalid-span-constants");
/**
 * The NonRecordingSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */ var NonRecordingSpan = /** @class */ function() {
    function NonRecordingSpan(_spanContext) {
        if (_spanContext === void 0) _spanContext = (0, _invalidSpanConstants.INVALID_SPAN_CONTEXT);
        this._spanContext = _spanContext;
    }
    // Returns a SpanContext.
    NonRecordingSpan.prototype.spanContext = function() {
        return this._spanContext;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttribute = function(_key, _value) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttributes = function(_attributes) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.addEvent = function(_name, _attributes) {
        return this;
    };
    NonRecordingSpan.prototype.addLink = function(_link) {
        return this;
    };
    NonRecordingSpan.prototype.addLinks = function(_links) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setStatus = function(_status) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.updateName = function(_name) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.end = function(_endTime) {};
    // isRecording always returns false for NonRecordingSpan.
    NonRecordingSpan.prototype.isRecording = function() {
        return false;
    };
    // By default does nothing
    NonRecordingSpan.prototype.recordException = function(_exception, _time) {};
    return NonRecordingSpan;
}();

},{"./invalid-span-constants":"9v7Cm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9v7Cm":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "INVALID_SPANID", ()=>INVALID_SPANID);
parcelHelpers.export(exports, "INVALID_TRACEID", ()=>INVALID_TRACEID);
parcelHelpers.export(exports, "INVALID_SPAN_CONTEXT", ()=>INVALID_SPAN_CONTEXT);
var _traceFlags = require("./trace_flags");
var INVALID_SPANID = '0000000000000000';
var INVALID_TRACEID = '00000000000000000000000000000000';
var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: (0, _traceFlags.TraceFlags).NONE
};

},{"./trace_flags":"58Fpe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"58Fpe":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceFlags", ()=>TraceFlags);
var TraceFlags;
(function(TraceFlags) {
    /** Represents no flag set. */ TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
    /** Bit to represent whether trace is sampled in trace flags. */ TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g40FB":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isValidTraceId", ()=>isValidTraceId);
parcelHelpers.export(exports, "isValidSpanId", ()=>isValidSpanId);
/**
 * Returns true if this {@link SpanContext} is valid.
 * @return true if this {@link SpanContext} is valid.
 */ parcelHelpers.export(exports, "isSpanContextValid", ()=>isSpanContextValid);
/**
 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
 *
 * @param spanContext span context to be wrapped
 * @returns a new non-recording {@link Span} with the provided context
 */ parcelHelpers.export(exports, "wrapSpanContext", ()=>wrapSpanContext);
var _invalidSpanConstants = require("./invalid-span-constants");
var _nonRecordingSpan = require("./NonRecordingSpan");
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== (0, _invalidSpanConstants.INVALID_TRACEID);
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== (0, _invalidSpanConstants.INVALID_SPANID);
}
function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
    return new (0, _nonRecordingSpan.NonRecordingSpan)(spanContext);
}

},{"./invalid-span-constants":"9v7Cm","./NonRecordingSpan":"80R4i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5OsDv":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProxyTracerProvider", ()=>ProxyTracerProvider);
var _proxyTracer = require("./ProxyTracer");
var _noopTracerProvider = require("./NoopTracerProvider");
var NOOP_TRACER_PROVIDER = new (0, _noopTracerProvider.NoopTracerProvider)();
/**
 * Tracer provider which provides {@link ProxyTracer}s.
 *
 * Before a delegate is set, tracers provided are NoOp.
 *   When a delegate is set, traces are provided from the delegate.
 *   When a delegate is set after tracers have already been provided,
 *   all tracers already provided will use the provided delegate implementation.
 */ var ProxyTracerProvider = /** @class */ function() {
    function ProxyTracerProvider() {}
    /**
     * Get a {@link ProxyTracer}
     */ ProxyTracerProvider.prototype.getTracer = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new (0, _proxyTracer.ProxyTracer)(this, name, version, options);
    };
    ProxyTracerProvider.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
    };
    /**
     * Set the delegate tracer provider
     */ ProxyTracerProvider.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider.prototype.getDelegateTracer = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider;
}();

},{"./ProxyTracer":"4RJSP","./NoopTracerProvider":"j8CJP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j8CJP":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopTracerProvider", ()=>NoopTracerProvider);
var _noopTracer = require("./NoopTracer");
/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */ var NoopTracerProvider = /** @class */ function() {
    function NoopTracerProvider() {}
    NoopTracerProvider.prototype.getTracer = function(_name, _version, _options) {
        return new (0, _noopTracer.NoopTracer)();
    };
    return NoopTracerProvider;
}();

},{"./NoopTracer":"ciEOJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hHpb":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SamplingDecision", ()=>SamplingDecision);
var SamplingDecision;
(function(SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */ SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */ SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */ SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8JdQL":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpanKind", ()=>SpanKind);
var SpanKind;
(function(SpanKind) {
    /** Default value. Indicates that the span is used internally. */ SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */ SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */ SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */ SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */ SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"caBJ1":[function(require,module,exports,__globalThis) {
/**
 * An enumeration of status codes.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpanStatusCode", ()=>SpanStatusCode);
var SpanStatusCode;
(function(SpanStatusCode) {
    /**
     * The default status.
     */ SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */ SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
    /**
     * The operation contains an error.
     */ SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"43yZb":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createTraceState", ()=>createTraceState);
var _tracestateImpl = require("./tracestate-impl");
function createTraceState(rawTraceState) {
    return new (0, _tracestateImpl.TraceStateImpl)(rawTraceState);
}

},{"./tracestate-impl":"c2Tax","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c2Tax":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceStateImpl", ()=>TraceStateImpl);
var _tracestateValidators = require("./tracestate-validators");
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ',';
var LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */ var TraceStateImpl = /** @class */ function() {
    function TraceStateImpl(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState) this._parse(rawTraceState);
    }
    TraceStateImpl.prototype.set = function(key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) traceState._internalState.delete(key);
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceStateImpl.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceStateImpl.prototype.get = function(key) {
        return this._internalState.get(key);
    };
    TraceStateImpl.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
    };
    TraceStateImpl.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
        .reduce(function(agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if ((0, _tracestateValidators.validateKey)(key) && (0, _tracestateValidators.validateValue)(value)) agg.set(key, value);
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain
        .slice(0, MAX_TRACE_STATE_ITEMS));
    };
    TraceStateImpl.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceStateImpl.prototype._clone = function() {
        var traceState = new TraceStateImpl();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceStateImpl;
}();

},{"./tracestate-validators":"2Nd45","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Nd45":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */ parcelHelpers.export(exports, "validateKey", ()=>validateKey);
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */ parcelHelpers.export(exports, "validateValue", ()=>validateValue);
var VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ZkHn":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "context", ()=>context);
var _context = require("./api/context");
var context = (0, _context.ContextAPI).getInstance();

},{"./api/context":"1ZQ7h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Hdm6":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "diag", ()=>diag);
var _diag = require("./api/diag");
var diag = (0, _diag.DiagAPI).instance();

},{"./api/diag":"gZAmK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dKL2F":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "metrics", ()=>metrics);
var _metrics = require("./api/metrics");
var metrics = (0, _metrics.MetricsAPI).getInstance();

},{"./api/metrics":"hjL4Z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hjL4Z":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricsAPI", ()=>MetricsAPI);
var _noopMeterProvider = require("../metrics/NoopMeterProvider");
var _globalUtils = require("../internal/global-utils");
var _diag = require("./diag");
var API_NAME = 'metrics';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
 */ var MetricsAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function MetricsAPI() {}
    /** Get the singleton instance of the Metrics API */ MetricsAPI.getInstance = function() {
        if (!this._instance) this._instance = new MetricsAPI();
        return this._instance;
    };
    /**
     * Set the current global meter provider.
     * Returns true if the meter provider was successfully registered, else false.
     */ MetricsAPI.prototype.setGlobalMeterProvider = function(provider) {
        return (0, _globalUtils.registerGlobal)(API_NAME, provider, (0, _diag.DiagAPI).instance());
    };
    /**
     * Returns the global meter provider.
     */ MetricsAPI.prototype.getMeterProvider = function() {
        return (0, _globalUtils.getGlobal)(API_NAME) || (0, _noopMeterProvider.NOOP_METER_PROVIDER);
    };
    /**
     * Returns a meter from the global meter provider.
     */ MetricsAPI.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
    };
    /** Remove the global meter provider */ MetricsAPI.prototype.disable = function() {
        (0, _globalUtils.unregisterGlobal)(API_NAME, (0, _diag.DiagAPI).instance());
    };
    return MetricsAPI;
}();

},{"../metrics/NoopMeterProvider":"jPYvF","../internal/global-utils":"h4XAN","./diag":"gZAmK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jPYvF":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopMeterProvider", ()=>NoopMeterProvider);
parcelHelpers.export(exports, "NOOP_METER_PROVIDER", ()=>NOOP_METER_PROVIDER);
var _noopMeter = require("./NoopMeter");
/**
 * An implementation of the {@link MeterProvider} which returns an impotent Meter
 * for all calls to `getMeter`
 */ var NoopMeterProvider = /** @class */ function() {
    function NoopMeterProvider() {}
    NoopMeterProvider.prototype.getMeter = function(_name, _version, _options) {
        return 0, _noopMeter.NOOP_METER;
    };
    return NoopMeterProvider;
}();
var NOOP_METER_PROVIDER = new NoopMeterProvider();

},{"./NoopMeter":"fl46x","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Nd6jQ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "propagation", ()=>propagation);
var _propagation = require("./api/propagation");
var propagation = (0, _propagation.PropagationAPI).getInstance();

},{"./api/propagation":"9PDZ8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9PDZ8":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PropagationAPI", ()=>PropagationAPI);
var _globalUtils = require("../internal/global-utils");
var _noopTextMapPropagator = require("../propagation/NoopTextMapPropagator");
var _textMapPropagator = require("../propagation/TextMapPropagator");
var _contextHelpers = require("../baggage/context-helpers");
var _utils = require("../baggage/utils");
var _diag = require("./diag");
var API_NAME = 'propagation';
var NOOP_TEXT_MAP_PROPAGATOR = new (0, _noopTextMapPropagator.NoopTextMapPropagator)();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */ var PropagationAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function PropagationAPI() {
        this.createBaggage = (0, _utils.createBaggage);
        this.getBaggage = (0, _contextHelpers.getBaggage);
        this.getActiveBaggage = (0, _contextHelpers.getActiveBaggage);
        this.setBaggage = (0, _contextHelpers.setBaggage);
        this.deleteBaggage = (0, _contextHelpers.deleteBaggage);
    }
    /** Get the singleton instance of the Propagator API */ PropagationAPI.getInstance = function() {
        if (!this._instance) this._instance = new PropagationAPI();
        return this._instance;
    };
    /**
     * Set the current propagator.
     *
     * @returns true if the propagator was successfully registered, else false
     */ PropagationAPI.prototype.setGlobalPropagator = function(propagator) {
        return (0, _globalUtils.registerGlobal)(API_NAME, propagator, (0, _diag.DiagAPI).instance());
    };
    /**
     * Inject context into a carrier to be propagated inter-process
     *
     * @param context Context carrying tracing data to inject
     * @param carrier carrier to inject context into
     * @param setter Function used to set values on the carrier
     */ PropagationAPI.prototype.inject = function(context, carrier, setter) {
        if (setter === void 0) setter = (0, _textMapPropagator.defaultTextMapSetter);
        return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    /**
     * Extract context from a carrier
     *
     * @param context Context which the newly created context will inherit from
     * @param carrier Carrier to extract context from
     * @param getter Function used to extract keys from a carrier
     */ PropagationAPI.prototype.extract = function(context, carrier, getter) {
        if (getter === void 0) getter = (0, _textMapPropagator.defaultTextMapGetter);
        return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    /**
     * Return a list of all fields which may be used by the propagator.
     */ PropagationAPI.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
    };
    /** Remove the global propagator */ PropagationAPI.prototype.disable = function() {
        (0, _globalUtils.unregisterGlobal)(API_NAME, (0, _diag.DiagAPI).instance());
    };
    PropagationAPI.prototype._getGlobalPropagator = function() {
        return (0, _globalUtils.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI;
}();

},{"../internal/global-utils":"h4XAN","../propagation/NoopTextMapPropagator":"5aVXl","../propagation/TextMapPropagator":"fbpGl","../baggage/context-helpers":"lnCoA","../baggage/utils":"1FtTJ","./diag":"gZAmK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5aVXl":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * No-op implementations of {@link TextMapPropagator}.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopTextMapPropagator", ()=>NoopTextMapPropagator);
var NoopTextMapPropagator = /** @class */ function() {
    function NoopTextMapPropagator() {}
    /** Noop inject function does nothing */ NoopTextMapPropagator.prototype.inject = function(_context, _carrier) {};
    /** Noop extract function does nothing and returns the input context */ NoopTextMapPropagator.prototype.extract = function(context, _carrier) {
        return context;
    };
    NoopTextMapPropagator.prototype.fields = function() {
        return [];
    };
    return NoopTextMapPropagator;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lnCoA":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Retrieve the current baggage from the given context
 *
 * @param {Context} Context that manage all context values
 * @returns {Baggage} Extracted baggage from the context
 */ parcelHelpers.export(exports, "getBaggage", ()=>getBaggage);
/**
 * Retrieve the current baggage from the active/current context
 *
 * @returns {Baggage} Extracted baggage from the context
 */ parcelHelpers.export(exports, "getActiveBaggage", ()=>getActiveBaggage);
/**
 * Store a baggage in the given context
 *
 * @param {Context} Context that manage all context values
 * @param {Baggage} baggage that will be set in the actual context
 */ parcelHelpers.export(exports, "setBaggage", ()=>setBaggage);
/**
 * Delete the baggage stored in the given context
 *
 * @param {Context} Context that manage all context values
 */ parcelHelpers.export(exports, "deleteBaggage", ()=>deleteBaggage);
var _context = require("../api/context");
var _context1 = require("../context/context");
/**
 * Baggage key
 */ var BAGGAGE_KEY = (0, _context1.createContextKey)('OpenTelemetry Baggage Key');
function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
}
function getActiveBaggage() {
    return getBaggage((0, _context.ContextAPI).getInstance().active());
}
function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
}

},{"../api/context":"1ZQ7h","../context/context":"8Hj8X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hMrLV":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "trace", ()=>trace);
var _trace = require("./api/trace");
var trace = (0, _trace.TraceAPI).getInstance();

},{"./api/trace":"9U6uF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9U6uF":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceAPI", ()=>TraceAPI);
var _globalUtils = require("../internal/global-utils");
var _proxyTracerProvider = require("../trace/ProxyTracerProvider");
var _spancontextUtils = require("../trace/spancontext-utils");
var _contextUtils = require("../trace/context-utils");
var _diag = require("./diag");
var API_NAME = 'trace';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */ var TraceAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function TraceAPI() {
        this._proxyTracerProvider = new (0, _proxyTracerProvider.ProxyTracerProvider)();
        this.wrapSpanContext = (0, _spancontextUtils.wrapSpanContext);
        this.isSpanContextValid = (0, _spancontextUtils.isSpanContextValid);
        this.deleteSpan = (0, _contextUtils.deleteSpan);
        this.getSpan = (0, _contextUtils.getSpan);
        this.getActiveSpan = (0, _contextUtils.getActiveSpan);
        this.getSpanContext = (0, _contextUtils.getSpanContext);
        this.setSpan = (0, _contextUtils.setSpan);
        this.setSpanContext = (0, _contextUtils.setSpanContext);
    }
    /** Get the singleton instance of the Trace API */ TraceAPI.getInstance = function() {
        if (!this._instance) this._instance = new TraceAPI();
        return this._instance;
    };
    /**
     * Set the current global tracer.
     *
     * @returns true if the tracer provider was successfully registered, else false
     */ TraceAPI.prototype.setGlobalTracerProvider = function(provider) {
        var success = (0, _globalUtils.registerGlobal)(API_NAME, this._proxyTracerProvider, (0, _diag.DiagAPI).instance());
        if (success) this._proxyTracerProvider.setDelegate(provider);
        return success;
    };
    /**
     * Returns the global tracer provider.
     */ TraceAPI.prototype.getTracerProvider = function() {
        return (0, _globalUtils.getGlobal)(API_NAME) || this._proxyTracerProvider;
    };
    /**
     * Returns a tracer from the global tracer provider.
     */ TraceAPI.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
    };
    /** Remove the global tracer provider */ TraceAPI.prototype.disable = function() {
        (0, _globalUtils.unregisterGlobal)(API_NAME, (0, _diag.DiagAPI).instance());
        this._proxyTracerProvider = new (0, _proxyTracerProvider.ProxyTracerProvider)();
    };
    return TraceAPI;
}();

},{"../internal/global-utils":"h4XAN","../trace/ProxyTracerProvider":"5OsDv","../trace/spancontext-utils":"g40FB","../trace/context-utils":"c8keb","./diag":"gZAmK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"oOZeC":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */ parcelHelpers.export(exports, "millisToHrTime", ()=>millisToHrTime);
parcelHelpers.export(exports, "getTimeOrigin", ()=>getTimeOrigin);
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */ parcelHelpers.export(exports, "hrTime", ()=>hrTime);
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */ parcelHelpers.export(exports, "timeInputToHrTime", ()=>timeInputToHrTime);
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */ parcelHelpers.export(exports, "hrTimeDuration", ()=>hrTimeDuration);
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToTimeStamp", ()=>hrTimeToTimeStamp);
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToNanoseconds", ()=>hrTimeToNanoseconds);
/**
 * Convert hrTime to milliseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToMilliseconds", ()=>hrTimeToMilliseconds);
/**
 * Convert hrTime to microseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToMicroseconds", ()=>hrTimeToMicroseconds);
/**
 * check if time is HrTime
 * @param value
 */ parcelHelpers.export(exports, "isTimeInputHrTime", ()=>isTimeInputHrTime);
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */ parcelHelpers.export(exports, "isTimeInput", ()=>isTimeInput);
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */ parcelHelpers.export(exports, "addHrTimes", ()=>addHrTimes);
var _platform = require("../platform");
var NANOSECOND_DIGITS = 9;
var NANOSECOND_DIGITS_IN_MILLIS = 6;
var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
function millisToHrTime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
    return [
        seconds,
        nanos
    ];
}
function getTimeOrigin() {
    var timeOrigin = (0, _platform.otperformance).timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = (0, _platform.otperformance);
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
function hrTime(performanceNow) {
    var timeOrigin = millisToHrTime(getTimeOrigin());
    var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : (0, _platform.otperformance).now());
    return addHrTimes(timeOrigin, now);
}
function timeInputToHrTime(time) {
    // process.hrtime
    if (isTimeInputHrTime(time)) return time;
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < getTimeOrigin()) return hrTime(time);
        else // epoch milliseconds or performance.timeOrigin
        return millisToHrTime(time);
    } else if (time instanceof Date) return millisToHrTime(time.getTime());
    else throw TypeError('Invalid input type');
}
function hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS;
    }
    return [
        seconds,
        nanos
    ];
}
function hrTimeToTimeStamp(time) {
    var precision = NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substr(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
function hrTimeToMilliseconds(time) {
    return time[0] * 1e3 + time[1] / 1e6;
}
function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1e3;
}
function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
}
function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;
}
function addHrTimes(time1, time2) {
    var out = [
        time1[0] + time2[0],
        time1[1] + time2[1]
    ];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
    }
    return out;
}

},{"../platform":"a3NCV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3NCV":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>(0, _environment.getEnvWithoutDefaults));
parcelHelpers.export(exports, "getEnv", ()=>(0, _environment.getEnv));
parcelHelpers.export(exports, "_globalThis", ()=>(0, _globalThis._globalThis));
parcelHelpers.export(exports, "hexToBase64", ()=>(0, _hexToBase64.hexToBase64));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _randomIdGenerator.RandomIdGenerator));
parcelHelpers.export(exports, "otperformance", ()=>(0, _performance.otperformance));
parcelHelpers.export(exports, "SDK_INFO", ()=>(0, _sdkInfo.SDK_INFO));
parcelHelpers.export(exports, "unrefTimer", ()=>(0, _timerUtil.unrefTimer));
var _environment = require("./environment");
var _globalThis = require("./globalThis");
var _hexToBase64 = require("./hex-to-base64");
var _randomIdGenerator = require("./RandomIdGenerator");
var _performance = require("./performance");
var _sdkInfo = require("./sdk-info");
var _timerUtil = require("./timer-util");

},{"./environment":false,"./globalThis":false,"./hex-to-base64":false,"./RandomIdGenerator":false,"./performance":"3XRRP","./sdk-info":false,"./timer-util":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3XRRP":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "otperformance", ()=>otperformance);
var otperformance = performance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2fJSh":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExportResultCode", ()=>ExportResultCode);
var ExportResultCode;
(function(ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kLEpF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeKeyPairs", ()=>serializeKeyPairs);
parcelHelpers.export(exports, "getKeyPairs", ()=>getKeyPairs);
parcelHelpers.export(exports, "parsePairKeyValue", ()=>parsePairKeyValue);
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */ parcelHelpers.export(exports, "parseKeyPairsIntoRecord", ()=>parseKeyPairsIntoRecord);
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var _api = require("@opentelemetry/api");
var _constants = require("./constants");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function(hValue, current) {
        var value = "" + hValue + (hValue !== '' ? (0, _constants.BAGGAGE_ITEMS_SEPARATOR) : '') + current;
        return value.length > (0, _constants.BAGGAGE_MAX_TOTAL_LENGTH) ? hValue : value;
    }, '');
}
function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) entry += (0, _constants.BAGGAGE_PROPERTIES_SEPARATOR) + value.metadata.toString();
        return entry;
    });
}
function parsePairKeyValue(entry) {
    var valueProps = entry.split((0, _constants.BAGGAGE_PROPERTIES_SEPARATOR));
    if (valueProps.length <= 0) return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart) return;
    var separatorIndex = keyPairPart.indexOf((0, _constants.BAGGAGE_KEY_PAIR_SEPARATOR));
    if (separatorIndex <= 0) return;
    var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    var metadata;
    if (valueProps.length > 0) metadata = (0, _api.baggageEntryMetadataFromString)(valueProps.join((0, _constants.BAGGAGE_PROPERTIES_SEPARATOR)));
    return {
        key: key,
        value: value,
        metadata: metadata
    };
}
function parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0) return {};
    return value.split((0, _constants.BAGGAGE_ITEMS_SEPARATOR)).map(function(entry) {
        return parsePairKeyValue(entry);
    }).filter(function(keyPair) {
        return keyPair !== undefined && keyPair.value.length > 0;
    }).reduce(function(headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}

},{"@opentelemetry/api":"6AC4z","./constants":"bxSBV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bxSBV":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BAGGAGE_KEY_PAIR_SEPARATOR", ()=>BAGGAGE_KEY_PAIR_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_PROPERTIES_SEPARATOR", ()=>BAGGAGE_PROPERTIES_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_ITEMS_SEPARATOR", ()=>BAGGAGE_ITEMS_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_HEADER", ()=>BAGGAGE_HEADER);
parcelHelpers.export(exports, "BAGGAGE_MAX_NAME_VALUE_PAIRS", ()=>BAGGAGE_MAX_NAME_VALUE_PAIRS);
parcelHelpers.export(exports, "BAGGAGE_MAX_PER_NAME_VALUE_PAIRS", ()=>BAGGAGE_MAX_PER_NAME_VALUE_PAIRS);
parcelHelpers.export(exports, "BAGGAGE_MAX_TOTAL_LENGTH", ()=>BAGGAGE_MAX_TOTAL_LENGTH);
var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var BAGGAGE_PROPERTIES_SEPARATOR = ';';
var BAGGAGE_ITEMS_SEPARATOR = ',';
var BAGGAGE_HEADER = 'baggage';
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j30mQ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TRACE_PARENT_HEADER", ()=>TRACE_PARENT_HEADER);
parcelHelpers.export(exports, "TRACE_STATE_HEADER", ()=>TRACE_STATE_HEADER);
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */ parcelHelpers.export(exports, "parseTraceParent", ()=>parseTraceParent);
parcelHelpers.export(exports, "W3CTraceContextPropagator", ()=>W3CTraceContextPropagator);
var _api = require("@opentelemetry/api");
var _suppressTracing = require("./suppress-tracing");
var _traceState = require("./TraceState");
var TRACE_PARENT_HEADER = 'traceparent';
var TRACE_STATE_HEADER = 'tracestate';
var VERSION = '00';
var VERSION_PART = '(?!ff)[\\da-f]{2}';
var TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var FLAGS_PART = '[\\da-f]{2}';
var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
function parseTraceParent(traceParent) {
    var match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match) return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5]) return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */ var W3CTraceContextPropagator = /** @class */ function() {
    function W3CTraceContextPropagator() {}
    W3CTraceContextPropagator.prototype.inject = function(context, carrier, setter) {
        var spanContext = (0, _api.trace).getSpanContext(context);
        if (!spanContext || (0, _suppressTracing.isTracingSuppressed)(context) || !(0, _api.isSpanContextValid)(spanContext)) return;
        var traceParent = VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || (0, _api.TraceFlags).NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
    };
    W3CTraceContextPropagator.prototype.extract = function(context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader) return context;
        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== 'string') return context;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext) return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(',') : traceStateHeader;
            spanContext.traceState = new (0, _traceState.TraceState)(typeof state === 'string' ? state : undefined);
        }
        return (0, _api.trace).setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function() {
        return [
            TRACE_PARENT_HEADER,
            TRACE_STATE_HEADER
        ];
    };
    return W3CTraceContextPropagator;
}();

},{"@opentelemetry/api":"6AC4z","./suppress-tracing":"51l3B","./TraceState":"9sU1J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"51l3B":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "suppressTracing", ()=>suppressTracing);
parcelHelpers.export(exports, "unsuppressTracing", ()=>unsuppressTracing);
parcelHelpers.export(exports, "isTracingSuppressed", ()=>isTracingSuppressed);
var _api = require("@opentelemetry/api");
var SUPPRESS_TRACING_KEY = (0, _api.createContextKey)('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
}
function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
}
function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9sU1J":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceState", ()=>TraceState);
var _validators = require("../internal/validators");
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ',';
var LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */ var TraceState = /** @class */ function() {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState) this._parse(rawTraceState);
    }
    TraceState.prototype.set = function(key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) traceState._internalState.delete(key);
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function(key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
        .reduce(function(agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if ((0, _validators.validateKey)(key) && (0, _validators.validateValue)(value)) agg.set(key, value);
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain
        .slice(0, MAX_TRACE_STATE_ITEMS));
    };
    TraceState.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function() {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}();

},{"../internal/validators":"kdvPR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kdvPR":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */ parcelHelpers.export(exports, "validateKey", ()=>validateKey);
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */ parcelHelpers.export(exports, "validateValue", ()=>validateValue);
var VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Wira8":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BindOnceFuture", ()=>BindOnceFuture);
var _promise = require("./promise");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */ var BindOnceFuture = /** @class */ function() {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new (0, _promise.Deferred)();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function() {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function() {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function() {
        var _a;
        var _this = this;
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, __spreadArray([
                    this._that
                ], __read(args), false))).then(function(val) {
                    return _this._deferred.resolve(val);
                }, function(err) {
                    return _this._deferred.reject(err);
                });
            } catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}();

},{"./promise":"ei2cy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ei2cy":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Deferred", ()=>Deferred);
var Deferred = /** @class */ function() {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function(resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function() {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function(val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function(err) {
        this._reject(err);
    };
    return Deferred;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4s27R":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @internal
 * Shared functionality used by Exporters while exporting data, including suppression of Traces.
 */ parcelHelpers.export(exports, "_export", ()=>_export);
var _api = require("@opentelemetry/api");
var _suppressTracing = require("../trace/suppress-tracing");
function _export(exporter, arg) {
    return new Promise(function(resolve) {
        // prevent downstream exporter calls from generating spans
        (0, _api.context).with((0, _suppressTracing.suppressTracing)((0, _api.context).active()), function() {
            exporter.export(arg, function(result) {
                resolve(result);
            });
        });
    });
}

},{"@opentelemetry/api":"6AC4z","../trace/suppress-tracing":"51l3B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Nq2MM":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SimpleSpanProcessor", ()=>SimpleSpanProcessor);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
/**
 * An implementation of the {@link SpanProcessor} that converts the {@link Span}
 * to {@link ReadableSpan} and passes it to the configured exporter.
 *
 * Only spans that are sampled are converted.
 *
 * NOTE: This {@link SpanProcessor} exports every ended span individually instead of batching spans together, which causes significant performance overhead with most exporters. For production use, please consider using the {@link BatchSpanProcessor} instead.
 */ var SimpleSpanProcessor = /** @class */ function() {
    function SimpleSpanProcessor(_exporter) {
        this._exporter = _exporter;
        this._shutdownOnce = new (0, _core.BindOnceFuture)(this._shutdown, this);
        this._unresolvedExports = new Set();
    }
    SimpleSpanProcessor.prototype.forceFlush = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        // await unresolved resources before resolving
                        return [
                            4 /*yield*/ ,
                            Promise.all(Array.from(this._unresolvedExports))
                        ];
                    case 1:
                        // await unresolved resources before resolving
                        _a.sent();
                        if (!this._exporter.forceFlush) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this._exporter.forceFlush()
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SimpleSpanProcessor.prototype.onStart = function(_span, _parentContext) {};
    SimpleSpanProcessor.prototype.onEnd = function(span) {
        var _this = this;
        var _a, _b;
        if (this._shutdownOnce.isCalled) return;
        if ((span.spanContext().traceFlags & (0, _api.TraceFlags).SAMPLED) === 0) return;
        var doExport = function() {
            return (0, _core.internal)._export(_this._exporter, [
                span
            ]).then(function(result) {
                var _a;
                if (result.code !== (0, _core.ExportResultCode).SUCCESS) (0, _core.globalErrorHandler)((_a = result.error) !== null && _a !== void 0 ? _a : new Error("SimpleSpanProcessor: span export failed (status " + result + ")"));
            }).catch(function(error) {
                (0, _core.globalErrorHandler)(error);
            });
        };
        // Avoid scheduling a promise to make the behavior more predictable and easier to test
        if (span.resource.asyncAttributesPending) {
            var exportPromise_1 = (_b = (_a = span.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a).then(function() {
                if (exportPromise_1 != null) _this._unresolvedExports.delete(exportPromise_1);
                return doExport();
            }, function(err) {
                return (0, _core.globalErrorHandler)(err);
            });
            // store the unresolved exports
            if (exportPromise_1 != null) this._unresolvedExports.add(exportPromise_1);
        } else doExport();
    };
    SimpleSpanProcessor.prototype.shutdown = function() {
        return this._shutdownOnce.call();
    };
    SimpleSpanProcessor.prototype._shutdown = function() {
        return this._exporter.shutdown();
    };
    return SimpleSpanProcessor;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"dBsXh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eXZZL":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WebTracerProvider", ()=>(0, _webTracerProvider.WebTracerProvider));
parcelHelpers.export(exports, "StackContextManager", ()=>(0, _stackContextManager.StackContextManager));
parcelHelpers.export(exports, "PerformanceTimingNames", ()=>(0, _performanceTimingNames.PerformanceTimingNames));
parcelHelpers.export(exports, "addSpanNetworkEvent", ()=>(0, _utils.addSpanNetworkEvent));
parcelHelpers.export(exports, "addSpanNetworkEvents", ()=>(0, _utils.addSpanNetworkEvents));
parcelHelpers.export(exports, "getElementXPath", ()=>(0, _utils.getElementXPath));
parcelHelpers.export(exports, "getResource", ()=>(0, _utils.getResource));
parcelHelpers.export(exports, "hasKey", ()=>(0, _utils.hasKey));
parcelHelpers.export(exports, "normalizeUrl", ()=>(0, _utils.normalizeUrl));
parcelHelpers.export(exports, "parseUrl", ()=>(0, _utils.parseUrl));
parcelHelpers.export(exports, "shouldPropagateTraceHeaders", ()=>(0, _utils.shouldPropagateTraceHeaders));
parcelHelpers.export(exports, "sortResources", ()=>(0, _utils.sortResources));
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>(0, _sdkTraceBase.AlwaysOffSampler));
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>(0, _sdkTraceBase.AlwaysOnSampler));
parcelHelpers.export(exports, "BasicTracerProvider", ()=>(0, _sdkTraceBase.BasicTracerProvider));
parcelHelpers.export(exports, "BatchSpanProcessor", ()=>(0, _sdkTraceBase.BatchSpanProcessor));
parcelHelpers.export(exports, "ConsoleSpanExporter", ()=>(0, _sdkTraceBase.ConsoleSpanExporter));
parcelHelpers.export(exports, "ForceFlushState", ()=>(0, _sdkTraceBase.ForceFlushState));
parcelHelpers.export(exports, "InMemorySpanExporter", ()=>(0, _sdkTraceBase.InMemorySpanExporter));
parcelHelpers.export(exports, "NoopSpanProcessor", ()=>(0, _sdkTraceBase.NoopSpanProcessor));
parcelHelpers.export(exports, "ParentBasedSampler", ()=>(0, _sdkTraceBase.ParentBasedSampler));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _sdkTraceBase.RandomIdGenerator));
parcelHelpers.export(exports, "SamplingDecision", ()=>(0, _sdkTraceBase.SamplingDecision));
parcelHelpers.export(exports, "SimpleSpanProcessor", ()=>(0, _sdkTraceBase.SimpleSpanProcessor));
parcelHelpers.export(exports, "Span", ()=>(0, _sdkTraceBase.Span));
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>(0, _sdkTraceBase.TraceIdRatioBasedSampler));
parcelHelpers.export(exports, "Tracer", ()=>(0, _sdkTraceBase.Tracer));
var _webTracerProvider = require("./WebTracerProvider");
var _stackContextManager = require("./StackContextManager");
var _performanceTimingNames = require("./enums/PerformanceTimingNames");
var _utils = require("./utils");
var _sdkTraceBase = require("@opentelemetry/sdk-trace-base");

},{"./WebTracerProvider":"gYn17","./StackContextManager":false,"./enums/PerformanceTimingNames":"eNyqo","./utils":"ccAWO","@opentelemetry/sdk-trace-base":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gYn17":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WebTracerProvider", ()=>WebTracerProvider);
var _sdkTraceBase = require("@opentelemetry/sdk-trace-base");
var _stackContextManager = require("./StackContextManager");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * This class represents a web tracer with {@link StackContextManager}
 */ var WebTracerProvider = /** @class */ function(_super) {
    __extends(WebTracerProvider, _super);
    /**
     * Constructs a new Tracer instance.
     * @param config Web Tracer config
     */ function WebTracerProvider(config) {
        if (config === void 0) config = {};
        var _this = _super.call(this, config) || this;
        if (config.contextManager) throw "contextManager should be defined in register method not in constructor";
        if (config.propagator) throw 'propagator should be defined in register method not in constructor';
        return _this;
    }
    /**
     * Register this TracerProvider for use with the OpenTelemetry API.
     * Undefined values may be replaced with defaults, and
     * null values will be skipped.
     *
     * @param config Configuration object for SDK registration
     */ WebTracerProvider.prototype.register = function(config) {
        if (config === void 0) config = {};
        if (config.contextManager === undefined) config.contextManager = new (0, _stackContextManager.StackContextManager)();
        if (config.contextManager) config.contextManager.enable();
        _super.prototype.register.call(this, config);
    };
    return WebTracerProvider;
}((0, _sdkTraceBase.BasicTracerProvider));

},{"@opentelemetry/sdk-trace-base":"1KkHk","./StackContextManager":"dXLQl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1KkHk":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Tracer", ()=>(0, _tracer.Tracer));
parcelHelpers.export(exports, "BasicTracerProvider", ()=>(0, _basicTracerProvider.BasicTracerProvider));
parcelHelpers.export(exports, "ForceFlushState", ()=>(0, _basicTracerProvider.ForceFlushState));
parcelHelpers.export(exports, "BatchSpanProcessor", ()=>(0, _platform.BatchSpanProcessor));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _platform.RandomIdGenerator));
parcelHelpers.export(exports, "ConsoleSpanExporter", ()=>(0, _consoleSpanExporter.ConsoleSpanExporter));
parcelHelpers.export(exports, "InMemorySpanExporter", ()=>(0, _inMemorySpanExporter.InMemorySpanExporter));
parcelHelpers.export(exports, "SimpleSpanProcessor", ()=>(0, _simpleSpanProcessor.SimpleSpanProcessor));
parcelHelpers.export(exports, "NoopSpanProcessor", ()=>(0, _noopSpanProcessor.NoopSpanProcessor));
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>(0, _alwaysOffSampler.AlwaysOffSampler));
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>(0, _alwaysOnSampler.AlwaysOnSampler));
parcelHelpers.export(exports, "ParentBasedSampler", ()=>(0, _parentBasedSampler.ParentBasedSampler));
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>(0, _traceIdRatioBasedSampler.TraceIdRatioBasedSampler));
parcelHelpers.export(exports, "SamplingDecision", ()=>(0, _sampler.SamplingDecision));
parcelHelpers.export(exports, "Span", ()=>(0, _span.Span));
var _tracer = require("./Tracer");
var _basicTracerProvider = require("./BasicTracerProvider");
var _platform = require("./platform");
var _consoleSpanExporter = require("./export/ConsoleSpanExporter");
var _inMemorySpanExporter = require("./export/InMemorySpanExporter");
var _simpleSpanProcessor = require("./export/SimpleSpanProcessor");
var _noopSpanProcessor = require("./export/NoopSpanProcessor");
var _alwaysOffSampler = require("./sampler/AlwaysOffSampler");
var _alwaysOnSampler = require("./sampler/AlwaysOnSampler");
var _parentBasedSampler = require("./sampler/ParentBasedSampler");
var _traceIdRatioBasedSampler = require("./sampler/TraceIdRatioBasedSampler");
var _sampler = require("./Sampler");
var _span = require("./Span");

},{"./Tracer":"7ld0E","./BasicTracerProvider":"252wY","./platform":false,"./export/ConsoleSpanExporter":false,"./export/InMemorySpanExporter":false,"./export/SimpleSpanProcessor":false,"./export/NoopSpanProcessor":false,"./sampler/AlwaysOffSampler":false,"./sampler/AlwaysOnSampler":false,"./sampler/ParentBasedSampler":false,"./sampler/TraceIdRatioBasedSampler":false,"./Sampler":false,"./Span":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7ld0E":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Tracer", ()=>Tracer);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var _span = require("./Span");
var _utility = require("./utility");
var _platform = require("./platform");
/**
 * This class represents a basic tracer.
 */ var Tracer = /** @class */ function() {
    /**
     * Constructs a new Tracer instance.
     */ function Tracer(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        var localConfig = (0, _utility.mergeConfig)(config);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config.idGenerator || new (0, _platform.RandomIdGenerator)();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
    }
    /**
     * Starts a new Span or returns the default NoopSpan based on the sampling
     * decision.
     */ Tracer.prototype.startSpan = function(name, options, context) {
        var _a, _b, _c;
        if (options === void 0) options = {};
        if (context === void 0) context = _api.context.active();
        // remove span from context in case a root span is requested via options
        if (options.root) context = _api.trace.deleteSpan(context);
        var parentSpan = _api.trace.getSpan(context);
        if ((0, _core.isTracingSuppressed)(context)) {
            _api.diag.debug('Instrumentation suppressed, returning Noop Span');
            var nonRecordingSpan = _api.trace.wrapSpanContext(_api.INVALID_SPAN_CONTEXT);
            return nonRecordingSpan;
        }
        var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
        var spanId = this._idGenerator.generateSpanId();
        var traceId;
        var traceState;
        var parentSpanId;
        if (!parentSpanContext || !_api.trace.isSpanContextValid(parentSpanContext)) // New root span.
        traceId = this._idGenerator.generateTraceId();
        else {
            // New child span.
            traceId = parentSpanContext.traceId;
            traceState = parentSpanContext.traceState;
            parentSpanId = parentSpanContext.spanId;
        }
        var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : _api.SpanKind.INTERNAL;
        var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function(link) {
            return {
                context: link.context,
                attributes: (0, _core.sanitizeAttributes)(link.attributes)
            };
        });
        var attributes = (0, _core.sanitizeAttributes)(options.attributes);
        // make sampling decision
        var samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);
        traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;
        var traceFlags = samplingResult.decision === _api.SamplingDecision.RECORD_AND_SAMPLED ? _api.TraceFlags.SAMPLED : _api.TraceFlags.NONE;
        var spanContext = {
            traceId: traceId,
            spanId: spanId,
            traceFlags: traceFlags,
            traceState: traceState
        };
        if (samplingResult.decision === _api.SamplingDecision.NOT_RECORD) {
            _api.diag.debug('Recording is off, propagating context in a non-recording span');
            var nonRecordingSpan = _api.trace.wrapSpanContext(spanContext);
            return nonRecordingSpan;
        }
        // Set initial span attributes. The attributes object may have been mutated
        // by the sampler, so we sanitize the merged attributes before setting them.
        var initAttributes = (0, _core.sanitizeAttributes)(Object.assign(attributes, samplingResult.attributes));
        var span = new (0, _span.Span)(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime, undefined, initAttributes);
        return span;
    };
    Tracer.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) return;
        else if (arguments.length === 2) fn = arg2;
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        } else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : _api.context.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = _api.trace.setSpan(parentContext, span);
        return _api.context.with(contextWithSpanSet, fn, undefined, span);
    };
    /** Returns the active {@link GeneralLimits}. */ Tracer.prototype.getGeneralLimits = function() {
        return this._generalLimits;
    };
    /** Returns the active {@link SpanLimits}. */ Tracer.prototype.getSpanLimits = function() {
        return this._spanLimits;
    };
    Tracer.prototype.getActiveSpanProcessor = function() {
        return this._tracerProvider.getActiveSpanProcessor();
    };
    return Tracer;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"1eVry","./Span":"bkokT","./utility":"7cAWa","./platform":"kpW1w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1eVry":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "W3CBaggagePropagator", ()=>(0, _w3CbaggagePropagator.W3CBaggagePropagator));
parcelHelpers.export(exports, "AnchoredClock", ()=>(0, _anchoredClock.AnchoredClock));
parcelHelpers.export(exports, "isAttributeKey", ()=>(0, _attributes.isAttributeKey));
parcelHelpers.export(exports, "isAttributeValue", ()=>(0, _attributes.isAttributeValue));
parcelHelpers.export(exports, "sanitizeAttributes", ()=>(0, _attributes.sanitizeAttributes));
parcelHelpers.export(exports, "globalErrorHandler", ()=>(0, _globalErrorHandler.globalErrorHandler));
parcelHelpers.export(exports, "setGlobalErrorHandler", ()=>(0, _globalErrorHandler.setGlobalErrorHandler));
parcelHelpers.export(exports, "loggingErrorHandler", ()=>(0, _loggingErrorHandler.loggingErrorHandler));
parcelHelpers.export(exports, "addHrTimes", ()=>(0, _time.addHrTimes));
parcelHelpers.export(exports, "getTimeOrigin", ()=>(0, _time.getTimeOrigin));
parcelHelpers.export(exports, "hrTime", ()=>(0, _time.hrTime));
parcelHelpers.export(exports, "hrTimeDuration", ()=>(0, _time.hrTimeDuration));
parcelHelpers.export(exports, "hrTimeToMicroseconds", ()=>(0, _time.hrTimeToMicroseconds));
parcelHelpers.export(exports, "hrTimeToMilliseconds", ()=>(0, _time.hrTimeToMilliseconds));
parcelHelpers.export(exports, "hrTimeToNanoseconds", ()=>(0, _time.hrTimeToNanoseconds));
parcelHelpers.export(exports, "hrTimeToTimeStamp", ()=>(0, _time.hrTimeToTimeStamp));
parcelHelpers.export(exports, "isTimeInput", ()=>(0, _time.isTimeInput));
parcelHelpers.export(exports, "isTimeInputHrTime", ()=>(0, _time.isTimeInputHrTime));
parcelHelpers.export(exports, "millisToHrTime", ()=>(0, _time.millisToHrTime));
parcelHelpers.export(exports, "timeInputToHrTime", ()=>(0, _time.timeInputToHrTime));
parcelHelpers.export(exports, "hexToBinary", ()=>(0, _hexToBinary.hexToBinary));
parcelHelpers.export(exports, "ExportResultCode", ()=>(0, _exportResult.ExportResultCode));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _platform.RandomIdGenerator));
parcelHelpers.export(exports, "SDK_INFO", ()=>(0, _platform.SDK_INFO));
parcelHelpers.export(exports, "_globalThis", ()=>(0, _platform._globalThis));
parcelHelpers.export(exports, "getEnv", ()=>(0, _platform.getEnv));
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>(0, _platform.getEnvWithoutDefaults));
parcelHelpers.export(exports, "hexToBase64", ()=>(0, _platform.hexToBase64));
parcelHelpers.export(exports, "otperformance", ()=>(0, _platform.otperformance));
parcelHelpers.export(exports, "unrefTimer", ()=>(0, _platform.unrefTimer));
parcelHelpers.export(exports, "CompositePropagator", ()=>(0, _composite.CompositePropagator));
parcelHelpers.export(exports, "TRACE_PARENT_HEADER", ()=>(0, _w3CtraceContextPropagator.TRACE_PARENT_HEADER));
parcelHelpers.export(exports, "TRACE_STATE_HEADER", ()=>(0, _w3CtraceContextPropagator.TRACE_STATE_HEADER));
parcelHelpers.export(exports, "W3CTraceContextPropagator", ()=>(0, _w3CtraceContextPropagator.W3CTraceContextPropagator));
parcelHelpers.export(exports, "parseTraceParent", ()=>(0, _w3CtraceContextPropagator.parseTraceParent));
parcelHelpers.export(exports, "RPCType", ()=>(0, _rpcMetadata.RPCType));
parcelHelpers.export(exports, "deleteRPCMetadata", ()=>(0, _rpcMetadata.deleteRPCMetadata));
parcelHelpers.export(exports, "getRPCMetadata", ()=>(0, _rpcMetadata.getRPCMetadata));
parcelHelpers.export(exports, "setRPCMetadata", ()=>(0, _rpcMetadata.setRPCMetadata));
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>(0, _alwaysOffSampler.AlwaysOffSampler));
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>(0, _alwaysOnSampler.AlwaysOnSampler));
parcelHelpers.export(exports, "ParentBasedSampler", ()=>(0, _parentBasedSampler.ParentBasedSampler));
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>(0, _traceIdRatioBasedSampler.TraceIdRatioBasedSampler));
parcelHelpers.export(exports, "isTracingSuppressed", ()=>(0, _suppressTracing.isTracingSuppressed));
parcelHelpers.export(exports, "suppressTracing", ()=>(0, _suppressTracing.suppressTracing));
parcelHelpers.export(exports, "unsuppressTracing", ()=>(0, _suppressTracing.unsuppressTracing));
parcelHelpers.export(exports, "TraceState", ()=>(0, _traceState.TraceState));
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_ATTRIBUTE_COUNT_LIMIT));
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", ()=>(0, _environment.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT));
parcelHelpers.export(exports, "DEFAULT_ENVIRONMENT", ()=>(0, _environment.DEFAULT_ENVIRONMENT));
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT));
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT));
parcelHelpers.export(exports, "parseEnvironment", ()=>(0, _environment.parseEnvironment));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "TracesSamplerValues", ()=>(0, _sampling.TracesSamplerValues));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _timeout.TimeoutError));
parcelHelpers.export(exports, "callWithTimeout", ()=>(0, _timeout.callWithTimeout));
parcelHelpers.export(exports, "isUrlIgnored", ()=>(0, _url.isUrlIgnored));
parcelHelpers.export(exports, "urlMatches", ()=>(0, _url.urlMatches));
parcelHelpers.export(exports, "isWrapped", ()=>(0, _wrap.isWrapped));
parcelHelpers.export(exports, "BindOnceFuture", ()=>(0, _callback.BindOnceFuture));
parcelHelpers.export(exports, "VERSION", ()=>(0, _version.VERSION));
parcelHelpers.export(exports, "baggageUtils", ()=>baggageUtils);
parcelHelpers.export(exports, "internal", ()=>internal);
var _w3CbaggagePropagator = require("./baggage/propagation/W3CBaggagePropagator");
var _anchoredClock = require("./common/anchored-clock");
var _attributes = require("./common/attributes");
var _globalErrorHandler = require("./common/global-error-handler");
var _loggingErrorHandler = require("./common/logging-error-handler");
var _time = require("./common/time");
var _hexToBinary = require("./common/hex-to-binary");
var _exportResult = require("./ExportResult");
var _utils = require("./baggage/utils");
var _platform = require("./platform");
var _composite = require("./propagation/composite");
var _w3CtraceContextPropagator = require("./trace/W3CTraceContextPropagator");
var _rpcMetadata = require("./trace/rpc-metadata");
var _alwaysOffSampler = require("./trace/sampler/AlwaysOffSampler");
var _alwaysOnSampler = require("./trace/sampler/AlwaysOnSampler");
var _parentBasedSampler = require("./trace/sampler/ParentBasedSampler");
var _traceIdRatioBasedSampler = require("./trace/sampler/TraceIdRatioBasedSampler");
var _suppressTracing = require("./trace/suppress-tracing");
var _traceState = require("./trace/TraceState");
var _environment = require("./utils/environment");
var _merge = require("./utils/merge");
var _sampling = require("./utils/sampling");
var _timeout = require("./utils/timeout");
var _url = require("./utils/url");
var _wrap = require("./utils/wrap");
var _callback = require("./utils/callback");
var _version = require("./version");
var _exporter = require("./internal/exporter");
var baggageUtils = {
    getKeyPairs: (0, _utils.getKeyPairs),
    serializeKeyPairs: (0, _utils.serializeKeyPairs),
    parseKeyPairsIntoRecord: (0, _utils.parseKeyPairsIntoRecord),
    parsePairKeyValue: (0, _utils.parsePairKeyValue)
};
var internal = {
    _export: (0, _exporter._export)
};

},{"./baggage/propagation/W3CBaggagePropagator":"eY9hp","./common/anchored-clock":"bUoQd","./common/attributes":"bkMxS","./common/global-error-handler":"b1oZ8","./common/logging-error-handler":"9zffm","./common/time":"kSaST","./common/hex-to-binary":"gSIpD","./ExportResult":"7QfVE","./baggage/utils":"lPOms","./platform":"7sxyM","./propagation/composite":"4CGBJ","./trace/W3CTraceContextPropagator":"jB4ew","./trace/rpc-metadata":"9NR3d","./trace/sampler/AlwaysOffSampler":"9TtvJ","./trace/sampler/AlwaysOnSampler":"ecqzX","./trace/sampler/ParentBasedSampler":"hPtIf","./trace/sampler/TraceIdRatioBasedSampler":"ahYGO","./trace/suppress-tracing":"1rhvC","./trace/TraceState":"6OqHS","./utils/environment":"cRahx","./utils/merge":"asyWF","./utils/sampling":"3EQFm","./utils/timeout":"iWKYy","./utils/url":"6x22z","./utils/wrap":"lzw4N","./utils/callback":"96fEi","./version":"frfej","./internal/exporter":"1BxU4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eY9hp":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "W3CBaggagePropagator", ()=>W3CBaggagePropagator);
var _api = require("@opentelemetry/api");
var _suppressTracing = require("../../trace/suppress-tracing");
var _constants = require("../constants");
var _utils = require("../utils");
/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */ var W3CBaggagePropagator = /** @class */ function() {
    function W3CBaggagePropagator() {}
    W3CBaggagePropagator.prototype.inject = function(context, carrier, setter) {
        var baggage = (0, _api.propagation).getBaggage(context);
        if (!baggage || (0, _suppressTracing.isTracingSuppressed)(context)) return;
        var keyPairs = (0, _utils.getKeyPairs)(baggage).filter(function(pair) {
            return pair.length <= (0, _constants.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS);
        }).slice(0, (0, _constants.BAGGAGE_MAX_NAME_VALUE_PAIRS));
        var headerValue = (0, _utils.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) setter.set(carrier, (0, _constants.BAGGAGE_HEADER), headerValue);
    };
    W3CBaggagePropagator.prototype.extract = function(context, carrier, getter) {
        var headerValue = getter.get(carrier, (0, _constants.BAGGAGE_HEADER));
        var baggageString = Array.isArray(headerValue) ? headerValue.join((0, _constants.BAGGAGE_ITEMS_SEPARATOR)) : headerValue;
        if (!baggageString) return context;
        var baggage = {};
        if (baggageString.length === 0) return context;
        var pairs = baggageString.split((0, _constants.BAGGAGE_ITEMS_SEPARATOR));
        pairs.forEach(function(entry) {
            var keyPair = (0, _utils.parsePairKeyValue)(entry);
            if (keyPair) {
                var baggageEntry = {
                    value: keyPair.value
                };
                if (keyPair.metadata) baggageEntry.metadata = keyPair.metadata;
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) return context;
        return (0, _api.propagation).setBaggage(context, (0, _api.propagation).createBaggage(baggage));
    };
    W3CBaggagePropagator.prototype.fields = function() {
        return [
            (0, _constants.BAGGAGE_HEADER)
        ];
    };
    return W3CBaggagePropagator;
}();

},{"@opentelemetry/api":"6AC4z","../../trace/suppress-tracing":"1rhvC","../constants":"4X1Un","../utils":"lPOms","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1rhvC":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "suppressTracing", ()=>suppressTracing);
parcelHelpers.export(exports, "unsuppressTracing", ()=>unsuppressTracing);
parcelHelpers.export(exports, "isTracingSuppressed", ()=>isTracingSuppressed);
var _api = require("@opentelemetry/api");
var SUPPRESS_TRACING_KEY = (0, _api.createContextKey)('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
}
function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
}
function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4X1Un":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BAGGAGE_KEY_PAIR_SEPARATOR", ()=>BAGGAGE_KEY_PAIR_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_PROPERTIES_SEPARATOR", ()=>BAGGAGE_PROPERTIES_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_ITEMS_SEPARATOR", ()=>BAGGAGE_ITEMS_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_HEADER", ()=>BAGGAGE_HEADER);
parcelHelpers.export(exports, "BAGGAGE_MAX_NAME_VALUE_PAIRS", ()=>BAGGAGE_MAX_NAME_VALUE_PAIRS);
parcelHelpers.export(exports, "BAGGAGE_MAX_PER_NAME_VALUE_PAIRS", ()=>BAGGAGE_MAX_PER_NAME_VALUE_PAIRS);
parcelHelpers.export(exports, "BAGGAGE_MAX_TOTAL_LENGTH", ()=>BAGGAGE_MAX_TOTAL_LENGTH);
var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var BAGGAGE_PROPERTIES_SEPARATOR = ';';
var BAGGAGE_ITEMS_SEPARATOR = ',';
var BAGGAGE_HEADER = 'baggage';
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPOms":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeKeyPairs", ()=>serializeKeyPairs);
parcelHelpers.export(exports, "getKeyPairs", ()=>getKeyPairs);
parcelHelpers.export(exports, "parsePairKeyValue", ()=>parsePairKeyValue);
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */ parcelHelpers.export(exports, "parseKeyPairsIntoRecord", ()=>parseKeyPairsIntoRecord);
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var _api = require("@opentelemetry/api");
var _constants = require("./constants");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function(hValue, current) {
        var value = "" + hValue + (hValue !== '' ? (0, _constants.BAGGAGE_ITEMS_SEPARATOR) : '') + current;
        return value.length > (0, _constants.BAGGAGE_MAX_TOTAL_LENGTH) ? hValue : value;
    }, '');
}
function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) entry += (0, _constants.BAGGAGE_PROPERTIES_SEPARATOR) + value.metadata.toString();
        return entry;
    });
}
function parsePairKeyValue(entry) {
    var valueProps = entry.split((0, _constants.BAGGAGE_PROPERTIES_SEPARATOR));
    if (valueProps.length <= 0) return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart) return;
    var separatorIndex = keyPairPart.indexOf((0, _constants.BAGGAGE_KEY_PAIR_SEPARATOR));
    if (separatorIndex <= 0) return;
    var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    var metadata;
    if (valueProps.length > 0) metadata = (0, _api.baggageEntryMetadataFromString)(valueProps.join((0, _constants.BAGGAGE_PROPERTIES_SEPARATOR)));
    return {
        key: key,
        value: value,
        metadata: metadata
    };
}
function parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0) return {};
    return value.split((0, _constants.BAGGAGE_ITEMS_SEPARATOR)).map(function(entry) {
        return parsePairKeyValue(entry);
    }).filter(function(keyPair) {
        return keyPair !== undefined && keyPair.value.length > 0;
    }).reduce(function(headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}

},{"@opentelemetry/api":"6AC4z","./constants":"4X1Un","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bUoQd":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A utility for returning wall times anchored to a given point in time. Wall time measurements will
 * not be taken from the system, but instead are computed by adding a monotonic clock time
 * to the anchor point.
 *
 * This is needed because the system time can change and result in unexpected situations like
 * spans ending before they are started. Creating an anchored clock for each local root span
 * ensures that span timings and durations are accurate while preventing span times from drifting
 * too far from the system clock.
 *
 * Only creating an anchored clock once per local trace ensures span times are correct relative
 * to each other. For example, a child span will never have a start time before its parent even
 * if the system clock is corrected during the local trace.
 *
 * Heavily inspired by the OTel Java anchored clock
 * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/AnchoredClock.java
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnchoredClock", ()=>AnchoredClock);
var AnchoredClock = /** @class */ function() {
    /**
     * Create a new AnchoredClock anchored to the current time returned by systemClock.
     *
     * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
     * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
     */ function AnchoredClock(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
    }
    /**
     * Returns the current time by adding the number of milliseconds since the
     * AnchoredClock was created to the creation epoch time
     */ AnchoredClock.prototype.now = function() {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
    };
    return AnchoredClock;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bkMxS":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sanitizeAttributes", ()=>sanitizeAttributes);
parcelHelpers.export(exports, "isAttributeKey", ()=>isAttributeKey);
parcelHelpers.export(exports, "isAttributeValue", ()=>isAttributeValue);
var _api = require("@opentelemetry/api");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
function sanitizeAttributes(attributes) {
    var e_1, _a;
    var out = {};
    if (typeof attributes !== 'object' || attributes == null) return out;
    try {
        for(var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()){
            var _d = __read(_c.value, 2), key = _d[0], val = _d[1];
            if (!isAttributeKey(key)) {
                (0, _api.diag).warn("Invalid attribute key: " + key);
                continue;
            }
            if (!isAttributeValue(val)) {
                (0, _api.diag).warn("Invalid attribute value set for key: " + key);
                continue;
            }
            if (Array.isArray(val)) out[key] = val.slice();
            else out[key] = val;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return out;
}
function isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function isAttributeValue(val) {
    if (val == null) return true;
    if (Array.isArray(val)) return isHomogeneousAttributeValueArray(val);
    return isValidPrimitiveAttributeValue(val);
}
function isHomogeneousAttributeValueArray(arr) {
    var e_2, _a;
    var type;
    try {
        for(var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()){
            var element = arr_1_1.value;
            // null/undefined elements are allowed
            if (element == null) continue;
            if (!type) {
                if (isValidPrimitiveAttributeValue(element)) {
                    type = typeof element;
                    continue;
                }
                // encountered an invalid primitive
                return false;
            }
            if (typeof element === type) continue;
            return false;
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return true;
}
function isValidPrimitiveAttributeValue(val) {
    switch(typeof val){
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b1oZ8":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */ parcelHelpers.export(exports, "setGlobalErrorHandler", ()=>setGlobalErrorHandler);
/**
 * Return the global error handler
 * @param {Exception} ex
 */ parcelHelpers.export(exports, "globalErrorHandler", ()=>globalErrorHandler);
var _loggingErrorHandler = require("./logging-error-handler");
/** The global error handler delegate */ var delegateHandler = (0, _loggingErrorHandler.loggingErrorHandler)();
function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
}
function globalErrorHandler(ex) {
    try {
        delegateHandler(ex);
    } catch (_a) {} // eslint-disable-line no-empty
}

},{"./logging-error-handler":"9zffm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9zffm":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */ parcelHelpers.export(exports, "loggingErrorHandler", ()=>loggingErrorHandler);
var _api = require("@opentelemetry/api");
function loggingErrorHandler() {
    return function(ex) {
        (0, _api.diag).error(stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */ function stringifyException(ex) {
    if (typeof ex === 'string') return ex;
    else return JSON.stringify(flattenException(ex));
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */ function flattenException(ex) {
    var result = {};
    var current = ex;
    while(current !== null){
        Object.getOwnPropertyNames(current).forEach(function(propertyName) {
            if (result[propertyName]) return;
            var value = current[propertyName];
            if (value) result[propertyName] = String(value);
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kSaST":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */ parcelHelpers.export(exports, "millisToHrTime", ()=>millisToHrTime);
parcelHelpers.export(exports, "getTimeOrigin", ()=>getTimeOrigin);
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */ parcelHelpers.export(exports, "hrTime", ()=>hrTime);
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */ parcelHelpers.export(exports, "timeInputToHrTime", ()=>timeInputToHrTime);
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */ parcelHelpers.export(exports, "hrTimeDuration", ()=>hrTimeDuration);
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToTimeStamp", ()=>hrTimeToTimeStamp);
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToNanoseconds", ()=>hrTimeToNanoseconds);
/**
 * Convert hrTime to milliseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToMilliseconds", ()=>hrTimeToMilliseconds);
/**
 * Convert hrTime to microseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToMicroseconds", ()=>hrTimeToMicroseconds);
/**
 * check if time is HrTime
 * @param value
 */ parcelHelpers.export(exports, "isTimeInputHrTime", ()=>isTimeInputHrTime);
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */ parcelHelpers.export(exports, "isTimeInput", ()=>isTimeInput);
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */ parcelHelpers.export(exports, "addHrTimes", ()=>addHrTimes);
var _platform = require("../platform");
var NANOSECOND_DIGITS = 9;
var NANOSECOND_DIGITS_IN_MILLIS = 6;
var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
function millisToHrTime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
    return [
        seconds,
        nanos
    ];
}
function getTimeOrigin() {
    var timeOrigin = (0, _platform.otperformance).timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = (0, _platform.otperformance);
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
function hrTime(performanceNow) {
    var timeOrigin = millisToHrTime(getTimeOrigin());
    var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : (0, _platform.otperformance).now());
    return addHrTimes(timeOrigin, now);
}
function timeInputToHrTime(time) {
    // process.hrtime
    if (isTimeInputHrTime(time)) return time;
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < getTimeOrigin()) return hrTime(time);
        else // epoch milliseconds or performance.timeOrigin
        return millisToHrTime(time);
    } else if (time instanceof Date) return millisToHrTime(time.getTime());
    else throw TypeError('Invalid input type');
}
function hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS;
    }
    return [
        seconds,
        nanos
    ];
}
function hrTimeToTimeStamp(time) {
    var precision = NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substring(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
function hrTimeToMilliseconds(time) {
    return time[0] * 1e3 + time[1] / 1e6;
}
function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1e3;
}
function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
}
function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;
}
function addHrTimes(time1, time2) {
    var out = [
        time1[0] + time2[0],
        time1[1] + time2[1]
    ];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
    }
    return out;
}

},{"../platform":"7sxyM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7sxyM":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>(0, _environment.getEnvWithoutDefaults));
parcelHelpers.export(exports, "getEnv", ()=>(0, _environment.getEnv));
parcelHelpers.export(exports, "_globalThis", ()=>(0, _globalThis._globalThis));
parcelHelpers.export(exports, "hexToBase64", ()=>(0, _hexToBase64.hexToBase64));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _randomIdGenerator.RandomIdGenerator));
parcelHelpers.export(exports, "otperformance", ()=>(0, _performance.otperformance));
parcelHelpers.export(exports, "SDK_INFO", ()=>(0, _sdkInfo.SDK_INFO));
parcelHelpers.export(exports, "unrefTimer", ()=>(0, _timerUtil.unrefTimer));
var _environment = require("./environment");
var _globalThis = require("./globalThis");
var _hexToBase64 = require("./hex-to-base64");
var _randomIdGenerator = require("./RandomIdGenerator");
var _performance = require("./performance");
var _sdkInfo = require("./sdk-info");
var _timerUtil = require("./timer-util");

},{"./environment":"5tMb1","./globalThis":"hnRkc","./hex-to-base64":"frfq2","./RandomIdGenerator":"gAKiY","./performance":"hfmw7","./sdk-info":"cg2Nk","./timer-util":"3bJW6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5tMb1":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the environment variables
 */ parcelHelpers.export(exports, "getEnv", ()=>getEnv);
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>getEnvWithoutDefaults);
var _environment = require("../../utils/environment");
var _globalThis = require("./globalThis");
function getEnv() {
    var globalEnv = (0, _environment.parseEnvironment)((0, _globalThis._globalThis));
    return Object.assign({}, (0, _environment.DEFAULT_ENVIRONMENT), globalEnv);
}
function getEnvWithoutDefaults() {
    return (0, _environment.parseEnvironment)((0, _globalThis._globalThis));
}

},{"../../utils/environment":"cRahx","./globalThis":"hnRkc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cRahx":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", ()=>DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT);
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", ()=>DEFAULT_ATTRIBUTE_COUNT_LIMIT);
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", ()=>DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT);
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", ()=>DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT);
parcelHelpers.export(exports, "DEFAULT_ENVIRONMENT", ()=>DEFAULT_ENVIRONMENT);
/**
 * Parses environment values
 * @param values
 */ parcelHelpers.export(exports, "parseEnvironment", ()=>parseEnvironment);
var _api = require("@opentelemetry/api");
var _sampling = require("./sampling");
var DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */ var ENVIRONMENT_BOOLEAN_KEYS = [
    'OTEL_SDK_DISABLED'
];
function isEnvVarABoolean(key) {
    return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_NUMBERS_KEYS = [
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_BLRP_EXPORT_TIMEOUT',
    'OTEL_BLRP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BLRP_MAX_QUEUE_SIZE',
    'OTEL_BLRP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT'
];
function isEnvVarANumber(key) {
    return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_LISTS_KEYS = [
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
    'OTEL_SEMCONV_STABILITY_OPT_IN'
];
function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
var DEFAULT_ENVIRONMENT = {
    OTEL_SDK_DISABLED: false,
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_BLRP_EXPORT_TIMEOUT: 30000,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: (0, _api.DiagLogLevel).INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: [
        'tracecontext',
        'baggage'
    ],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    OTEL_TRACES_EXPORTER: '',
    OTEL_TRACES_SAMPLER: (0, _sampling.TracesSamplerValues).ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_LOGS_EXPORTER: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative',
    OTEL_SEMCONV_STABILITY_OPT_IN: []
};
/**
 * @param key
 * @param environment
 * @param values
 */ function parseBoolean(key, environment, values) {
    if (typeof values[key] === 'undefined') return;
    var value = String(values[key]);
    // support case-insensitive "true"
    environment[key] = value.toLowerCase() === 'true';
}
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */ function parseNumber(name, environment, values, min, max) {
    if (min === void 0) min = -Infinity;
    if (max === void 0) max = Infinity;
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) environment[name] = min;
            else if (value > max) environment[name] = max;
            else environment[name] = value;
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */ function parseStringList(name, output, input, separator) {
    if (separator === void 0) separator = DEFAULT_LIST_SEPARATOR;
    var givenValue = input[name];
    if (typeof givenValue === 'string') output[name] = givenValue.split(separator).map(function(v) {
        return v.trim();
    });
}
// The support string -> DiagLogLevel mappings
var logLevelMap = {
    ALL: (0, _api.DiagLogLevel).ALL,
    VERBOSE: (0, _api.DiagLogLevel).VERBOSE,
    DEBUG: (0, _api.DiagLogLevel).DEBUG,
    INFO: (0, _api.DiagLogLevel).INFO,
    WARN: (0, _api.DiagLogLevel).WARN,
    ERROR: (0, _api.DiagLogLevel).ERROR,
    NONE: (0, _api.DiagLogLevel).NONE
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */ function setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) environment[key] = theLevel;
    }
}
function parseEnvironment(values) {
    var environment = {};
    for(var env in DEFAULT_ENVIRONMENT){
        var key = env;
        switch(key){
            case 'OTEL_LOG_LEVEL':
                setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (isEnvVarABoolean(key)) parseBoolean(key, environment, values);
                else if (isEnvVarANumber(key)) parseNumber(key, environment, values);
                else if (isEnvVarAList(key)) parseStringList(key, environment, values);
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) environment[key] = String(value);
                }
        }
    }
    return environment;
}

},{"@opentelemetry/api":"6AC4z","./sampling":"3EQFm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3EQFm":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TracesSamplerValues", ()=>TracesSamplerValues);
var TracesSamplerValues;
(function(TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues || (TracesSamplerValues = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hnRkc":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Updates to this file should also be replicated to @opentelemetry/api too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */ /** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>_globalThis);
var global = arguments[3];
var _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"frfq2":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hexToBase64", ()=>hexToBase64);
var _hexToBinary = require("../../common/hex-to-binary");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
function hexToBase64(hexStr) {
    return btoa(String.fromCharCode.apply(String, __spreadArray([], __read((0, _hexToBinary.hexToBinary)(hexStr)), false)));
}

},{"../../common/hex-to-binary":"gSIpD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gSIpD":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hexToBinary", ()=>hexToBinary);
function intValue(charCode) {
    // 0-9
    if (charCode >= 48 && charCode <= 57) return charCode - 48;
    // a-f
    if (charCode >= 97 && charCode <= 102) return charCode - 87;
    // A-F
    return charCode - 55;
}
function hexToBinary(hexStr) {
    var buf = new Uint8Array(hexStr.length / 2);
    var offset = 0;
    for(var i = 0; i < hexStr.length; i += 2){
        var hi = intValue(hexStr.charCodeAt(i));
        var lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = hi << 4 | lo;
    }
    return buf;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gAKiY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RandomIdGenerator", ()=>RandomIdGenerator);
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 */ var RandomIdGenerator = /** @class */ function() {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */ this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */ this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}();
var SHARED_CHAR_CODES_ARRAY = Array(32);
function getIdGenerator(bytes) {
    return function generateId() {
        for(var i = 0; i < bytes * 2; i++){
            SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (SHARED_CHAR_CODES_ARRAY[i] >= 58) SHARED_CHAR_CODES_ARRAY[i] += 39;
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hfmw7":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "otperformance", ()=>otperformance);
var otperformance = performance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cg2Nk":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SDK_INFO", ()=>SDK_INFO);
var _version = require("../../version");
var _semanticConventions = require("@opentelemetry/semantic-conventions");
var _a;
var SDK_INFO = (_a = {}, _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_NAME] = 'opentelemetry', _a[0, _semanticConventions.SEMRESATTRS_PROCESS_RUNTIME_NAME] = 'browser', _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = (0, _semanticConventions.TELEMETRYSDKLANGUAGEVALUES_WEBJS), _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_VERSION] = (0, _version.VERSION), _a);

},{"../../version":"frfej","@opentelemetry/semantic-conventions":"lCgfj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"frfej":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // this is autogenerated file, see scripts/version-update.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
var VERSION = '1.29.0';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lCgfj":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* eslint-disable no-restricted-syntax --
 * These re-exports are only of constants, only two-levels deep, and
 * should not cause problems for tree-shakers.
 */ // Deprecated. These are kept around for compatibility purposes
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _trace = require("./trace");
parcelHelpers.exportAll(_trace, exports);
var _resource = require("./resource");
parcelHelpers.exportAll(_resource, exports);
// Use these instead
var _stableAttributes = require("./stable_attributes");
parcelHelpers.exportAll(_stableAttributes, exports);
var _stableMetrics = require("./stable_metrics");
parcelHelpers.exportAll(_stableMetrics, exports);

},{"./trace":"9Fj5N","./resource":"6gLs0","./stable_attributes":"iely6","./stable_metrics":"67SQ6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Fj5N":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* eslint-disable no-restricted-syntax --
 * These re-exports are only of constants, only one-level deep at this point,
 * and should not cause problems for tree-shakers.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _semanticAttributes = require("./SemanticAttributes");
parcelHelpers.exportAll(_semanticAttributes, exports);

},{"./SemanticAttributes":"jqkBD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jqkBD":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SEMATTRS_AWS_LAMBDA_INVOKED_ARN", ()=>SEMATTRS_AWS_LAMBDA_INVOKED_ARN);
parcelHelpers.export(exports, "SEMATTRS_DB_SYSTEM", ()=>SEMATTRS_DB_SYSTEM);
parcelHelpers.export(exports, "SEMATTRS_DB_CONNECTION_STRING", ()=>SEMATTRS_DB_CONNECTION_STRING);
parcelHelpers.export(exports, "SEMATTRS_DB_USER", ()=>SEMATTRS_DB_USER);
parcelHelpers.export(exports, "SEMATTRS_DB_JDBC_DRIVER_CLASSNAME", ()=>SEMATTRS_DB_JDBC_DRIVER_CLASSNAME);
parcelHelpers.export(exports, "SEMATTRS_DB_NAME", ()=>SEMATTRS_DB_NAME);
parcelHelpers.export(exports, "SEMATTRS_DB_STATEMENT", ()=>SEMATTRS_DB_STATEMENT);
parcelHelpers.export(exports, "SEMATTRS_DB_OPERATION", ()=>SEMATTRS_DB_OPERATION);
parcelHelpers.export(exports, "SEMATTRS_DB_MSSQL_INSTANCE_NAME", ()=>SEMATTRS_DB_MSSQL_INSTANCE_NAME);
parcelHelpers.export(exports, "SEMATTRS_DB_CASSANDRA_KEYSPACE", ()=>SEMATTRS_DB_CASSANDRA_KEYSPACE);
parcelHelpers.export(exports, "SEMATTRS_DB_CASSANDRA_PAGE_SIZE", ()=>SEMATTRS_DB_CASSANDRA_PAGE_SIZE);
parcelHelpers.export(exports, "SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL", ()=>SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL);
parcelHelpers.export(exports, "SEMATTRS_DB_CASSANDRA_TABLE", ()=>SEMATTRS_DB_CASSANDRA_TABLE);
parcelHelpers.export(exports, "SEMATTRS_DB_CASSANDRA_IDEMPOTENCE", ()=>SEMATTRS_DB_CASSANDRA_IDEMPOTENCE);
parcelHelpers.export(exports, "SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT", ()=>SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT);
parcelHelpers.export(exports, "SEMATTRS_DB_CASSANDRA_COORDINATOR_ID", ()=>SEMATTRS_DB_CASSANDRA_COORDINATOR_ID);
parcelHelpers.export(exports, "SEMATTRS_DB_CASSANDRA_COORDINATOR_DC", ()=>SEMATTRS_DB_CASSANDRA_COORDINATOR_DC);
parcelHelpers.export(exports, "SEMATTRS_DB_HBASE_NAMESPACE", ()=>SEMATTRS_DB_HBASE_NAMESPACE);
parcelHelpers.export(exports, "SEMATTRS_DB_REDIS_DATABASE_INDEX", ()=>SEMATTRS_DB_REDIS_DATABASE_INDEX);
parcelHelpers.export(exports, "SEMATTRS_DB_MONGODB_COLLECTION", ()=>SEMATTRS_DB_MONGODB_COLLECTION);
parcelHelpers.export(exports, "SEMATTRS_DB_SQL_TABLE", ()=>SEMATTRS_DB_SQL_TABLE);
parcelHelpers.export(exports, "SEMATTRS_EXCEPTION_TYPE", ()=>SEMATTRS_EXCEPTION_TYPE);
parcelHelpers.export(exports, "SEMATTRS_EXCEPTION_MESSAGE", ()=>SEMATTRS_EXCEPTION_MESSAGE);
parcelHelpers.export(exports, "SEMATTRS_EXCEPTION_STACKTRACE", ()=>SEMATTRS_EXCEPTION_STACKTRACE);
parcelHelpers.export(exports, "SEMATTRS_EXCEPTION_ESCAPED", ()=>SEMATTRS_EXCEPTION_ESCAPED);
parcelHelpers.export(exports, "SEMATTRS_FAAS_TRIGGER", ()=>SEMATTRS_FAAS_TRIGGER);
parcelHelpers.export(exports, "SEMATTRS_FAAS_EXECUTION", ()=>SEMATTRS_FAAS_EXECUTION);
parcelHelpers.export(exports, "SEMATTRS_FAAS_DOCUMENT_COLLECTION", ()=>SEMATTRS_FAAS_DOCUMENT_COLLECTION);
parcelHelpers.export(exports, "SEMATTRS_FAAS_DOCUMENT_OPERATION", ()=>SEMATTRS_FAAS_DOCUMENT_OPERATION);
parcelHelpers.export(exports, "SEMATTRS_FAAS_DOCUMENT_TIME", ()=>SEMATTRS_FAAS_DOCUMENT_TIME);
parcelHelpers.export(exports, "SEMATTRS_FAAS_DOCUMENT_NAME", ()=>SEMATTRS_FAAS_DOCUMENT_NAME);
parcelHelpers.export(exports, "SEMATTRS_FAAS_TIME", ()=>SEMATTRS_FAAS_TIME);
parcelHelpers.export(exports, "SEMATTRS_FAAS_CRON", ()=>SEMATTRS_FAAS_CRON);
parcelHelpers.export(exports, "SEMATTRS_FAAS_COLDSTART", ()=>SEMATTRS_FAAS_COLDSTART);
parcelHelpers.export(exports, "SEMATTRS_FAAS_INVOKED_NAME", ()=>SEMATTRS_FAAS_INVOKED_NAME);
parcelHelpers.export(exports, "SEMATTRS_FAAS_INVOKED_PROVIDER", ()=>SEMATTRS_FAAS_INVOKED_PROVIDER);
parcelHelpers.export(exports, "SEMATTRS_FAAS_INVOKED_REGION", ()=>SEMATTRS_FAAS_INVOKED_REGION);
parcelHelpers.export(exports, "SEMATTRS_NET_TRANSPORT", ()=>SEMATTRS_NET_TRANSPORT);
parcelHelpers.export(exports, "SEMATTRS_NET_PEER_IP", ()=>SEMATTRS_NET_PEER_IP);
parcelHelpers.export(exports, "SEMATTRS_NET_PEER_PORT", ()=>SEMATTRS_NET_PEER_PORT);
parcelHelpers.export(exports, "SEMATTRS_NET_PEER_NAME", ()=>SEMATTRS_NET_PEER_NAME);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_IP", ()=>SEMATTRS_NET_HOST_IP);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_PORT", ()=>SEMATTRS_NET_HOST_PORT);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_NAME", ()=>SEMATTRS_NET_HOST_NAME);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_CONNECTION_TYPE", ()=>SEMATTRS_NET_HOST_CONNECTION_TYPE);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_CONNECTION_SUBTYPE", ()=>SEMATTRS_NET_HOST_CONNECTION_SUBTYPE);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_CARRIER_NAME", ()=>SEMATTRS_NET_HOST_CARRIER_NAME);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_CARRIER_MCC", ()=>SEMATTRS_NET_HOST_CARRIER_MCC);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_CARRIER_MNC", ()=>SEMATTRS_NET_HOST_CARRIER_MNC);
parcelHelpers.export(exports, "SEMATTRS_NET_HOST_CARRIER_ICC", ()=>SEMATTRS_NET_HOST_CARRIER_ICC);
parcelHelpers.export(exports, "SEMATTRS_PEER_SERVICE", ()=>SEMATTRS_PEER_SERVICE);
parcelHelpers.export(exports, "SEMATTRS_ENDUSER_ID", ()=>SEMATTRS_ENDUSER_ID);
parcelHelpers.export(exports, "SEMATTRS_ENDUSER_ROLE", ()=>SEMATTRS_ENDUSER_ROLE);
parcelHelpers.export(exports, "SEMATTRS_ENDUSER_SCOPE", ()=>SEMATTRS_ENDUSER_SCOPE);
parcelHelpers.export(exports, "SEMATTRS_THREAD_ID", ()=>SEMATTRS_THREAD_ID);
parcelHelpers.export(exports, "SEMATTRS_THREAD_NAME", ()=>SEMATTRS_THREAD_NAME);
parcelHelpers.export(exports, "SEMATTRS_CODE_FUNCTION", ()=>SEMATTRS_CODE_FUNCTION);
parcelHelpers.export(exports, "SEMATTRS_CODE_NAMESPACE", ()=>SEMATTRS_CODE_NAMESPACE);
parcelHelpers.export(exports, "SEMATTRS_CODE_FILEPATH", ()=>SEMATTRS_CODE_FILEPATH);
parcelHelpers.export(exports, "SEMATTRS_CODE_LINENO", ()=>SEMATTRS_CODE_LINENO);
parcelHelpers.export(exports, "SEMATTRS_HTTP_METHOD", ()=>SEMATTRS_HTTP_METHOD);
parcelHelpers.export(exports, "SEMATTRS_HTTP_URL", ()=>SEMATTRS_HTTP_URL);
parcelHelpers.export(exports, "SEMATTRS_HTTP_TARGET", ()=>SEMATTRS_HTTP_TARGET);
parcelHelpers.export(exports, "SEMATTRS_HTTP_HOST", ()=>SEMATTRS_HTTP_HOST);
parcelHelpers.export(exports, "SEMATTRS_HTTP_SCHEME", ()=>SEMATTRS_HTTP_SCHEME);
parcelHelpers.export(exports, "SEMATTRS_HTTP_STATUS_CODE", ()=>SEMATTRS_HTTP_STATUS_CODE);
parcelHelpers.export(exports, "SEMATTRS_HTTP_FLAVOR", ()=>SEMATTRS_HTTP_FLAVOR);
parcelHelpers.export(exports, "SEMATTRS_HTTP_USER_AGENT", ()=>SEMATTRS_HTTP_USER_AGENT);
parcelHelpers.export(exports, "SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH", ()=>SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH);
parcelHelpers.export(exports, "SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED", ()=>SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED);
parcelHelpers.export(exports, "SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH", ()=>SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH);
parcelHelpers.export(exports, "SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED", ()=>SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED);
parcelHelpers.export(exports, "SEMATTRS_HTTP_SERVER_NAME", ()=>SEMATTRS_HTTP_SERVER_NAME);
parcelHelpers.export(exports, "SEMATTRS_HTTP_ROUTE", ()=>SEMATTRS_HTTP_ROUTE);
parcelHelpers.export(exports, "SEMATTRS_HTTP_CLIENT_IP", ()=>SEMATTRS_HTTP_CLIENT_IP);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_TABLE_NAMES", ()=>SEMATTRS_AWS_DYNAMODB_TABLE_NAMES);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY", ()=>SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS", ()=>SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY", ()=>SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY", ()=>SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ", ()=>SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_PROJECTION", ()=>SEMATTRS_AWS_DYNAMODB_PROJECTION);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_LIMIT", ()=>SEMATTRS_AWS_DYNAMODB_LIMIT);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET", ()=>SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_INDEX_NAME", ()=>SEMATTRS_AWS_DYNAMODB_INDEX_NAME);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_SELECT", ()=>SEMATTRS_AWS_DYNAMODB_SELECT);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES", ()=>SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES", ()=>SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE", ()=>SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_TABLE_COUNT", ()=>SEMATTRS_AWS_DYNAMODB_TABLE_COUNT);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD", ()=>SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_SEGMENT", ()=>SEMATTRS_AWS_DYNAMODB_SEGMENT);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS", ()=>SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_COUNT", ()=>SEMATTRS_AWS_DYNAMODB_COUNT);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT", ()=>SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS", ()=>SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS);
parcelHelpers.export(exports, "SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES", ()=>SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_SYSTEM", ()=>SEMATTRS_MESSAGING_SYSTEM);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_DESTINATION", ()=>SEMATTRS_MESSAGING_DESTINATION);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_DESTINATION_KIND", ()=>SEMATTRS_MESSAGING_DESTINATION_KIND);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_TEMP_DESTINATION", ()=>SEMATTRS_MESSAGING_TEMP_DESTINATION);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_PROTOCOL", ()=>SEMATTRS_MESSAGING_PROTOCOL);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_PROTOCOL_VERSION", ()=>SEMATTRS_MESSAGING_PROTOCOL_VERSION);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_URL", ()=>SEMATTRS_MESSAGING_URL);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_MESSAGE_ID", ()=>SEMATTRS_MESSAGING_MESSAGE_ID);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_CONVERSATION_ID", ()=>SEMATTRS_MESSAGING_CONVERSATION_ID);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES", ()=>SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES", ()=>SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_OPERATION", ()=>SEMATTRS_MESSAGING_OPERATION);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_CONSUMER_ID", ()=>SEMATTRS_MESSAGING_CONSUMER_ID);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY", ()=>SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY", ()=>SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP", ()=>SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_KAFKA_CLIENT_ID", ()=>SEMATTRS_MESSAGING_KAFKA_CLIENT_ID);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_KAFKA_PARTITION", ()=>SEMATTRS_MESSAGING_KAFKA_PARTITION);
parcelHelpers.export(exports, "SEMATTRS_MESSAGING_KAFKA_TOMBSTONE", ()=>SEMATTRS_MESSAGING_KAFKA_TOMBSTONE);
parcelHelpers.export(exports, "SEMATTRS_RPC_SYSTEM", ()=>SEMATTRS_RPC_SYSTEM);
parcelHelpers.export(exports, "SEMATTRS_RPC_SERVICE", ()=>SEMATTRS_RPC_SERVICE);
parcelHelpers.export(exports, "SEMATTRS_RPC_METHOD", ()=>SEMATTRS_RPC_METHOD);
parcelHelpers.export(exports, "SEMATTRS_RPC_GRPC_STATUS_CODE", ()=>SEMATTRS_RPC_GRPC_STATUS_CODE);
parcelHelpers.export(exports, "SEMATTRS_RPC_JSONRPC_VERSION", ()=>SEMATTRS_RPC_JSONRPC_VERSION);
parcelHelpers.export(exports, "SEMATTRS_RPC_JSONRPC_REQUEST_ID", ()=>SEMATTRS_RPC_JSONRPC_REQUEST_ID);
parcelHelpers.export(exports, "SEMATTRS_RPC_JSONRPC_ERROR_CODE", ()=>SEMATTRS_RPC_JSONRPC_ERROR_CODE);
parcelHelpers.export(exports, "SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE", ()=>SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE);
parcelHelpers.export(exports, "SEMATTRS_MESSAGE_TYPE", ()=>SEMATTRS_MESSAGE_TYPE);
parcelHelpers.export(exports, "SEMATTRS_MESSAGE_ID", ()=>SEMATTRS_MESSAGE_ID);
parcelHelpers.export(exports, "SEMATTRS_MESSAGE_COMPRESSED_SIZE", ()=>SEMATTRS_MESSAGE_COMPRESSED_SIZE);
parcelHelpers.export(exports, "SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE", ()=>SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE);
parcelHelpers.export(exports, "SemanticAttributes", ()=>SemanticAttributes);
parcelHelpers.export(exports, "DBSYSTEMVALUES_OTHER_SQL", ()=>DBSYSTEMVALUES_OTHER_SQL);
parcelHelpers.export(exports, "DBSYSTEMVALUES_MSSQL", ()=>DBSYSTEMVALUES_MSSQL);
parcelHelpers.export(exports, "DBSYSTEMVALUES_MYSQL", ()=>DBSYSTEMVALUES_MYSQL);
parcelHelpers.export(exports, "DBSYSTEMVALUES_ORACLE", ()=>DBSYSTEMVALUES_ORACLE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_DB2", ()=>DBSYSTEMVALUES_DB2);
parcelHelpers.export(exports, "DBSYSTEMVALUES_POSTGRESQL", ()=>DBSYSTEMVALUES_POSTGRESQL);
parcelHelpers.export(exports, "DBSYSTEMVALUES_REDSHIFT", ()=>DBSYSTEMVALUES_REDSHIFT);
parcelHelpers.export(exports, "DBSYSTEMVALUES_HIVE", ()=>DBSYSTEMVALUES_HIVE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_CLOUDSCAPE", ()=>DBSYSTEMVALUES_CLOUDSCAPE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_HSQLDB", ()=>DBSYSTEMVALUES_HSQLDB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_PROGRESS", ()=>DBSYSTEMVALUES_PROGRESS);
parcelHelpers.export(exports, "DBSYSTEMVALUES_MAXDB", ()=>DBSYSTEMVALUES_MAXDB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_HANADB", ()=>DBSYSTEMVALUES_HANADB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_INGRES", ()=>DBSYSTEMVALUES_INGRES);
parcelHelpers.export(exports, "DBSYSTEMVALUES_FIRSTSQL", ()=>DBSYSTEMVALUES_FIRSTSQL);
parcelHelpers.export(exports, "DBSYSTEMVALUES_EDB", ()=>DBSYSTEMVALUES_EDB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_CACHE", ()=>DBSYSTEMVALUES_CACHE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_ADABAS", ()=>DBSYSTEMVALUES_ADABAS);
parcelHelpers.export(exports, "DBSYSTEMVALUES_FIREBIRD", ()=>DBSYSTEMVALUES_FIREBIRD);
parcelHelpers.export(exports, "DBSYSTEMVALUES_DERBY", ()=>DBSYSTEMVALUES_DERBY);
parcelHelpers.export(exports, "DBSYSTEMVALUES_FILEMAKER", ()=>DBSYSTEMVALUES_FILEMAKER);
parcelHelpers.export(exports, "DBSYSTEMVALUES_INFORMIX", ()=>DBSYSTEMVALUES_INFORMIX);
parcelHelpers.export(exports, "DBSYSTEMVALUES_INSTANTDB", ()=>DBSYSTEMVALUES_INSTANTDB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_INTERBASE", ()=>DBSYSTEMVALUES_INTERBASE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_MARIADB", ()=>DBSYSTEMVALUES_MARIADB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_NETEZZA", ()=>DBSYSTEMVALUES_NETEZZA);
parcelHelpers.export(exports, "DBSYSTEMVALUES_PERVASIVE", ()=>DBSYSTEMVALUES_PERVASIVE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_POINTBASE", ()=>DBSYSTEMVALUES_POINTBASE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_SQLITE", ()=>DBSYSTEMVALUES_SQLITE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_SYBASE", ()=>DBSYSTEMVALUES_SYBASE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_TERADATA", ()=>DBSYSTEMVALUES_TERADATA);
parcelHelpers.export(exports, "DBSYSTEMVALUES_VERTICA", ()=>DBSYSTEMVALUES_VERTICA);
parcelHelpers.export(exports, "DBSYSTEMVALUES_H2", ()=>DBSYSTEMVALUES_H2);
parcelHelpers.export(exports, "DBSYSTEMVALUES_COLDFUSION", ()=>DBSYSTEMVALUES_COLDFUSION);
parcelHelpers.export(exports, "DBSYSTEMVALUES_CASSANDRA", ()=>DBSYSTEMVALUES_CASSANDRA);
parcelHelpers.export(exports, "DBSYSTEMVALUES_HBASE", ()=>DBSYSTEMVALUES_HBASE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_MONGODB", ()=>DBSYSTEMVALUES_MONGODB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_REDIS", ()=>DBSYSTEMVALUES_REDIS);
parcelHelpers.export(exports, "DBSYSTEMVALUES_COUCHBASE", ()=>DBSYSTEMVALUES_COUCHBASE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_COUCHDB", ()=>DBSYSTEMVALUES_COUCHDB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_COSMOSDB", ()=>DBSYSTEMVALUES_COSMOSDB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_DYNAMODB", ()=>DBSYSTEMVALUES_DYNAMODB);
parcelHelpers.export(exports, "DBSYSTEMVALUES_NEO4J", ()=>DBSYSTEMVALUES_NEO4J);
parcelHelpers.export(exports, "DBSYSTEMVALUES_GEODE", ()=>DBSYSTEMVALUES_GEODE);
parcelHelpers.export(exports, "DBSYSTEMVALUES_ELASTICSEARCH", ()=>DBSYSTEMVALUES_ELASTICSEARCH);
parcelHelpers.export(exports, "DBSYSTEMVALUES_MEMCACHED", ()=>DBSYSTEMVALUES_MEMCACHED);
parcelHelpers.export(exports, "DBSYSTEMVALUES_COCKROACHDB", ()=>DBSYSTEMVALUES_COCKROACHDB);
parcelHelpers.export(exports, "DbSystemValues", ()=>DbSystemValues);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_ALL", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_ALL);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_ONE", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_ONE);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_TWO", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_TWO);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_THREE", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_THREE);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_ANY", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_ANY);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL);
parcelHelpers.export(exports, "DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL", ()=>DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL);
parcelHelpers.export(exports, "DbCassandraConsistencyLevelValues", ()=>DbCassandraConsistencyLevelValues);
parcelHelpers.export(exports, "FAASTRIGGERVALUES_DATASOURCE", ()=>FAASTRIGGERVALUES_DATASOURCE);
parcelHelpers.export(exports, "FAASTRIGGERVALUES_HTTP", ()=>FAASTRIGGERVALUES_HTTP);
parcelHelpers.export(exports, "FAASTRIGGERVALUES_PUBSUB", ()=>FAASTRIGGERVALUES_PUBSUB);
parcelHelpers.export(exports, "FAASTRIGGERVALUES_TIMER", ()=>FAASTRIGGERVALUES_TIMER);
parcelHelpers.export(exports, "FAASTRIGGERVALUES_OTHER", ()=>FAASTRIGGERVALUES_OTHER);
parcelHelpers.export(exports, "FaasTriggerValues", ()=>FaasTriggerValues);
parcelHelpers.export(exports, "FAASDOCUMENTOPERATIONVALUES_INSERT", ()=>FAASDOCUMENTOPERATIONVALUES_INSERT);
parcelHelpers.export(exports, "FAASDOCUMENTOPERATIONVALUES_EDIT", ()=>FAASDOCUMENTOPERATIONVALUES_EDIT);
parcelHelpers.export(exports, "FAASDOCUMENTOPERATIONVALUES_DELETE", ()=>FAASDOCUMENTOPERATIONVALUES_DELETE);
parcelHelpers.export(exports, "FaasDocumentOperationValues", ()=>FaasDocumentOperationValues);
parcelHelpers.export(exports, "FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD", ()=>FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD);
parcelHelpers.export(exports, "FAASINVOKEDPROVIDERVALUES_AWS", ()=>FAASINVOKEDPROVIDERVALUES_AWS);
parcelHelpers.export(exports, "FAASINVOKEDPROVIDERVALUES_AZURE", ()=>FAASINVOKEDPROVIDERVALUES_AZURE);
parcelHelpers.export(exports, "FAASINVOKEDPROVIDERVALUES_GCP", ()=>FAASINVOKEDPROVIDERVALUES_GCP);
parcelHelpers.export(exports, "FaasInvokedProviderValues", ()=>FaasInvokedProviderValues);
parcelHelpers.export(exports, "NETTRANSPORTVALUES_IP_TCP", ()=>NETTRANSPORTVALUES_IP_TCP);
parcelHelpers.export(exports, "NETTRANSPORTVALUES_IP_UDP", ()=>NETTRANSPORTVALUES_IP_UDP);
parcelHelpers.export(exports, "NETTRANSPORTVALUES_IP", ()=>NETTRANSPORTVALUES_IP);
parcelHelpers.export(exports, "NETTRANSPORTVALUES_UNIX", ()=>NETTRANSPORTVALUES_UNIX);
parcelHelpers.export(exports, "NETTRANSPORTVALUES_PIPE", ()=>NETTRANSPORTVALUES_PIPE);
parcelHelpers.export(exports, "NETTRANSPORTVALUES_INPROC", ()=>NETTRANSPORTVALUES_INPROC);
parcelHelpers.export(exports, "NETTRANSPORTVALUES_OTHER", ()=>NETTRANSPORTVALUES_OTHER);
parcelHelpers.export(exports, "NetTransportValues", ()=>NetTransportValues);
parcelHelpers.export(exports, "NETHOSTCONNECTIONTYPEVALUES_WIFI", ()=>NETHOSTCONNECTIONTYPEVALUES_WIFI);
parcelHelpers.export(exports, "NETHOSTCONNECTIONTYPEVALUES_WIRED", ()=>NETHOSTCONNECTIONTYPEVALUES_WIRED);
parcelHelpers.export(exports, "NETHOSTCONNECTIONTYPEVALUES_CELL", ()=>NETHOSTCONNECTIONTYPEVALUES_CELL);
parcelHelpers.export(exports, "NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE", ()=>NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE);
parcelHelpers.export(exports, "NETHOSTCONNECTIONTYPEVALUES_UNKNOWN", ()=>NETHOSTCONNECTIONTYPEVALUES_UNKNOWN);
parcelHelpers.export(exports, "NetHostConnectionTypeValues", ()=>NetHostConnectionTypeValues);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_GPRS", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_GPRS);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_EDGE", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_EDGE);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_UMTS", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_UMTS);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_CDMA", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_CDMA);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_HSPA", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_HSPA);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_IDEN", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_IDEN);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_LTE", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_LTE);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_GSM", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_GSM);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_NR", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_NR);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA);
parcelHelpers.export(exports, "NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA", ()=>NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA);
parcelHelpers.export(exports, "NetHostConnectionSubtypeValues", ()=>NetHostConnectionSubtypeValues);
parcelHelpers.export(exports, "HTTPFLAVORVALUES_HTTP_1_0", ()=>HTTPFLAVORVALUES_HTTP_1_0);
parcelHelpers.export(exports, "HTTPFLAVORVALUES_HTTP_1_1", ()=>HTTPFLAVORVALUES_HTTP_1_1);
parcelHelpers.export(exports, "HTTPFLAVORVALUES_HTTP_2_0", ()=>HTTPFLAVORVALUES_HTTP_2_0);
parcelHelpers.export(exports, "HTTPFLAVORVALUES_SPDY", ()=>HTTPFLAVORVALUES_SPDY);
parcelHelpers.export(exports, "HTTPFLAVORVALUES_QUIC", ()=>HTTPFLAVORVALUES_QUIC);
parcelHelpers.export(exports, "HttpFlavorValues", ()=>HttpFlavorValues);
parcelHelpers.export(exports, "MESSAGINGDESTINATIONKINDVALUES_QUEUE", ()=>MESSAGINGDESTINATIONKINDVALUES_QUEUE);
parcelHelpers.export(exports, "MESSAGINGDESTINATIONKINDVALUES_TOPIC", ()=>MESSAGINGDESTINATIONKINDVALUES_TOPIC);
parcelHelpers.export(exports, "MessagingDestinationKindValues", ()=>MessagingDestinationKindValues);
parcelHelpers.export(exports, "MESSAGINGOPERATIONVALUES_RECEIVE", ()=>MESSAGINGOPERATIONVALUES_RECEIVE);
parcelHelpers.export(exports, "MESSAGINGOPERATIONVALUES_PROCESS", ()=>MESSAGINGOPERATIONVALUES_PROCESS);
parcelHelpers.export(exports, "MessagingOperationValues", ()=>MessagingOperationValues);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_OK", ()=>RPCGRPCSTATUSCODEVALUES_OK);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_CANCELLED", ()=>RPCGRPCSTATUSCODEVALUES_CANCELLED);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_UNKNOWN", ()=>RPCGRPCSTATUSCODEVALUES_UNKNOWN);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT", ()=>RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED", ()=>RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_NOT_FOUND", ()=>RPCGRPCSTATUSCODEVALUES_NOT_FOUND);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS", ()=>RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED", ()=>RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED", ()=>RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION", ()=>RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_ABORTED", ()=>RPCGRPCSTATUSCODEVALUES_ABORTED);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE", ()=>RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED", ()=>RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_INTERNAL", ()=>RPCGRPCSTATUSCODEVALUES_INTERNAL);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_UNAVAILABLE", ()=>RPCGRPCSTATUSCODEVALUES_UNAVAILABLE);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_DATA_LOSS", ()=>RPCGRPCSTATUSCODEVALUES_DATA_LOSS);
parcelHelpers.export(exports, "RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED", ()=>RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED);
parcelHelpers.export(exports, "RpcGrpcStatusCodeValues", ()=>RpcGrpcStatusCodeValues);
parcelHelpers.export(exports, "MESSAGETYPEVALUES_SENT", ()=>MESSAGETYPEVALUES_SENT);
parcelHelpers.export(exports, "MESSAGETYPEVALUES_RECEIVED", ()=>MESSAGETYPEVALUES_RECEIVED);
parcelHelpers.export(exports, "MessageTypeValues", ()=>MessageTypeValues);
var _utils = require("../internal/utils");
//----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
// Constant values for SemanticAttributes
//----------------------------------------------------------------------------------------------------------
// Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_AWS_LAMBDA_INVOKED_ARN = 'aws.lambda.invoked_arn';
var TMP_DB_SYSTEM = 'db.system';
var TMP_DB_CONNECTION_STRING = 'db.connection_string';
var TMP_DB_USER = 'db.user';
var TMP_DB_JDBC_DRIVER_CLASSNAME = 'db.jdbc.driver_classname';
var TMP_DB_NAME = 'db.name';
var TMP_DB_STATEMENT = 'db.statement';
var TMP_DB_OPERATION = 'db.operation';
var TMP_DB_MSSQL_INSTANCE_NAME = 'db.mssql.instance_name';
var TMP_DB_CASSANDRA_KEYSPACE = 'db.cassandra.keyspace';
var TMP_DB_CASSANDRA_PAGE_SIZE = 'db.cassandra.page_size';
var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = 'db.cassandra.consistency_level';
var TMP_DB_CASSANDRA_TABLE = 'db.cassandra.table';
var TMP_DB_CASSANDRA_IDEMPOTENCE = 'db.cassandra.idempotence';
var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = 'db.cassandra.speculative_execution_count';
var TMP_DB_CASSANDRA_COORDINATOR_ID = 'db.cassandra.coordinator.id';
var TMP_DB_CASSANDRA_COORDINATOR_DC = 'db.cassandra.coordinator.dc';
var TMP_DB_HBASE_NAMESPACE = 'db.hbase.namespace';
var TMP_DB_REDIS_DATABASE_INDEX = 'db.redis.database_index';
var TMP_DB_MONGODB_COLLECTION = 'db.mongodb.collection';
var TMP_DB_SQL_TABLE = 'db.sql.table';
var TMP_EXCEPTION_TYPE = 'exception.type';
var TMP_EXCEPTION_MESSAGE = 'exception.message';
var TMP_EXCEPTION_STACKTRACE = 'exception.stacktrace';
var TMP_EXCEPTION_ESCAPED = 'exception.escaped';
var TMP_FAAS_TRIGGER = 'faas.trigger';
var TMP_FAAS_EXECUTION = 'faas.execution';
var TMP_FAAS_DOCUMENT_COLLECTION = 'faas.document.collection';
var TMP_FAAS_DOCUMENT_OPERATION = 'faas.document.operation';
var TMP_FAAS_DOCUMENT_TIME = 'faas.document.time';
var TMP_FAAS_DOCUMENT_NAME = 'faas.document.name';
var TMP_FAAS_TIME = 'faas.time';
var TMP_FAAS_CRON = 'faas.cron';
var TMP_FAAS_COLDSTART = 'faas.coldstart';
var TMP_FAAS_INVOKED_NAME = 'faas.invoked_name';
var TMP_FAAS_INVOKED_PROVIDER = 'faas.invoked_provider';
var TMP_FAAS_INVOKED_REGION = 'faas.invoked_region';
var TMP_NET_TRANSPORT = 'net.transport';
var TMP_NET_PEER_IP = 'net.peer.ip';
var TMP_NET_PEER_PORT = 'net.peer.port';
var TMP_NET_PEER_NAME = 'net.peer.name';
var TMP_NET_HOST_IP = 'net.host.ip';
var TMP_NET_HOST_PORT = 'net.host.port';
var TMP_NET_HOST_NAME = 'net.host.name';
var TMP_NET_HOST_CONNECTION_TYPE = 'net.host.connection.type';
var TMP_NET_HOST_CONNECTION_SUBTYPE = 'net.host.connection.subtype';
var TMP_NET_HOST_CARRIER_NAME = 'net.host.carrier.name';
var TMP_NET_HOST_CARRIER_MCC = 'net.host.carrier.mcc';
var TMP_NET_HOST_CARRIER_MNC = 'net.host.carrier.mnc';
var TMP_NET_HOST_CARRIER_ICC = 'net.host.carrier.icc';
var TMP_PEER_SERVICE = 'peer.service';
var TMP_ENDUSER_ID = 'enduser.id';
var TMP_ENDUSER_ROLE = 'enduser.role';
var TMP_ENDUSER_SCOPE = 'enduser.scope';
var TMP_THREAD_ID = 'thread.id';
var TMP_THREAD_NAME = 'thread.name';
var TMP_CODE_FUNCTION = 'code.function';
var TMP_CODE_NAMESPACE = 'code.namespace';
var TMP_CODE_FILEPATH = 'code.filepath';
var TMP_CODE_LINENO = 'code.lineno';
var TMP_HTTP_METHOD = 'http.method';
var TMP_HTTP_URL = 'http.url';
var TMP_HTTP_TARGET = 'http.target';
var TMP_HTTP_HOST = 'http.host';
var TMP_HTTP_SCHEME = 'http.scheme';
var TMP_HTTP_STATUS_CODE = 'http.status_code';
var TMP_HTTP_FLAVOR = 'http.flavor';
var TMP_HTTP_USER_AGENT = 'http.user_agent';
var TMP_HTTP_REQUEST_CONTENT_LENGTH = 'http.request_content_length';
var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = 'http.request_content_length_uncompressed';
var TMP_HTTP_RESPONSE_CONTENT_LENGTH = 'http.response_content_length';
var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = 'http.response_content_length_uncompressed';
var TMP_HTTP_SERVER_NAME = 'http.server_name';
var TMP_HTTP_ROUTE = 'http.route';
var TMP_HTTP_CLIENT_IP = 'http.client_ip';
var TMP_AWS_DYNAMODB_TABLE_NAMES = 'aws.dynamodb.table_names';
var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = 'aws.dynamodb.consumed_capacity';
var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = 'aws.dynamodb.item_collection_metrics';
var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = 'aws.dynamodb.provisioned_read_capacity';
var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = 'aws.dynamodb.provisioned_write_capacity';
var TMP_AWS_DYNAMODB_CONSISTENT_READ = 'aws.dynamodb.consistent_read';
var TMP_AWS_DYNAMODB_PROJECTION = 'aws.dynamodb.projection';
var TMP_AWS_DYNAMODB_LIMIT = 'aws.dynamodb.limit';
var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = 'aws.dynamodb.attributes_to_get';
var TMP_AWS_DYNAMODB_INDEX_NAME = 'aws.dynamodb.index_name';
var TMP_AWS_DYNAMODB_SELECT = 'aws.dynamodb.select';
var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = 'aws.dynamodb.global_secondary_indexes';
var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = 'aws.dynamodb.local_secondary_indexes';
var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = 'aws.dynamodb.exclusive_start_table';
var TMP_AWS_DYNAMODB_TABLE_COUNT = 'aws.dynamodb.table_count';
var TMP_AWS_DYNAMODB_SCAN_FORWARD = 'aws.dynamodb.scan_forward';
var TMP_AWS_DYNAMODB_SEGMENT = 'aws.dynamodb.segment';
var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = 'aws.dynamodb.total_segments';
var TMP_AWS_DYNAMODB_COUNT = 'aws.dynamodb.count';
var TMP_AWS_DYNAMODB_SCANNED_COUNT = 'aws.dynamodb.scanned_count';
var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = 'aws.dynamodb.attribute_definitions';
var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = 'aws.dynamodb.global_secondary_index_updates';
var TMP_MESSAGING_SYSTEM = 'messaging.system';
var TMP_MESSAGING_DESTINATION = 'messaging.destination';
var TMP_MESSAGING_DESTINATION_KIND = 'messaging.destination_kind';
var TMP_MESSAGING_TEMP_DESTINATION = 'messaging.temp_destination';
var TMP_MESSAGING_PROTOCOL = 'messaging.protocol';
var TMP_MESSAGING_PROTOCOL_VERSION = 'messaging.protocol_version';
var TMP_MESSAGING_URL = 'messaging.url';
var TMP_MESSAGING_MESSAGE_ID = 'messaging.message_id';
var TMP_MESSAGING_CONVERSATION_ID = 'messaging.conversation_id';
var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = 'messaging.message_payload_size_bytes';
var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = 'messaging.message_payload_compressed_size_bytes';
var TMP_MESSAGING_OPERATION = 'messaging.operation';
var TMP_MESSAGING_CONSUMER_ID = 'messaging.consumer_id';
var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = 'messaging.rabbitmq.routing_key';
var TMP_MESSAGING_KAFKA_MESSAGE_KEY = 'messaging.kafka.message_key';
var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = 'messaging.kafka.consumer_group';
var TMP_MESSAGING_KAFKA_CLIENT_ID = 'messaging.kafka.client_id';
var TMP_MESSAGING_KAFKA_PARTITION = 'messaging.kafka.partition';
var TMP_MESSAGING_KAFKA_TOMBSTONE = 'messaging.kafka.tombstone';
var TMP_RPC_SYSTEM = 'rpc.system';
var TMP_RPC_SERVICE = 'rpc.service';
var TMP_RPC_METHOD = 'rpc.method';
var TMP_RPC_GRPC_STATUS_CODE = 'rpc.grpc.status_code';
var TMP_RPC_JSONRPC_VERSION = 'rpc.jsonrpc.version';
var TMP_RPC_JSONRPC_REQUEST_ID = 'rpc.jsonrpc.request_id';
var TMP_RPC_JSONRPC_ERROR_CODE = 'rpc.jsonrpc.error_code';
var TMP_RPC_JSONRPC_ERROR_MESSAGE = 'rpc.jsonrpc.error_message';
var TMP_MESSAGE_TYPE = 'message.type';
var TMP_MESSAGE_ID = 'message.id';
var TMP_MESSAGE_COMPRESSED_SIZE = 'message.compressed_size';
var TMP_MESSAGE_UNCOMPRESSED_SIZE = 'message.uncompressed_size';
var SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
var SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
var SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
var SEMATTRS_DB_USER = TMP_DB_USER;
var SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
var SEMATTRS_DB_NAME = TMP_DB_NAME;
var SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
var SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
var SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
var SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
var SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
var SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
var SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
var SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
var SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
var SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
var SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
var SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
var SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
var SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
var SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
var SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
var SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
var SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
var SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
var SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
var SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
var SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
var SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
var SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
var SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
var SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
var SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
var SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
var SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
var SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
var SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
var SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
var SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
var SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
var SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
var SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
var SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
var SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
var SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
var SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
var SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
var SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
var SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
var SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
var SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
var SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
var SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
var SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
var SEMATTRS_THREAD_ID = TMP_THREAD_ID;
var SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
var SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
var SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
var SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
var SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
var SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
var SEMATTRS_HTTP_URL = TMP_HTTP_URL;
var SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
var SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
var SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
var SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
var SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
var SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
var SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
var SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
var SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
var SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
var SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
var SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
var SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
var SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
var SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
var SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
var SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
var SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
var SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
var SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
var SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
var SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
var SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
var SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
var SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
var SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
var SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
var SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
var SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
var SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
var SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
var SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
var SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
var SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
var SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
var SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
var SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
var SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
var SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
var SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
var SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
var SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
var SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
var SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
var SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
var SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
var SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
var SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
var SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
var SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
var SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
var SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
var SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
var SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
var SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
var SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
var SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
var SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
var SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
var SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
var SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
var SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
var SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
var SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
var SemanticAttributes = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_AWS_LAMBDA_INVOKED_ARN,
    TMP_DB_SYSTEM,
    TMP_DB_CONNECTION_STRING,
    TMP_DB_USER,
    TMP_DB_JDBC_DRIVER_CLASSNAME,
    TMP_DB_NAME,
    TMP_DB_STATEMENT,
    TMP_DB_OPERATION,
    TMP_DB_MSSQL_INSTANCE_NAME,
    TMP_DB_CASSANDRA_KEYSPACE,
    TMP_DB_CASSANDRA_PAGE_SIZE,
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
    TMP_DB_CASSANDRA_TABLE,
    TMP_DB_CASSANDRA_IDEMPOTENCE,
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
    TMP_DB_CASSANDRA_COORDINATOR_ID,
    TMP_DB_CASSANDRA_COORDINATOR_DC,
    TMP_DB_HBASE_NAMESPACE,
    TMP_DB_REDIS_DATABASE_INDEX,
    TMP_DB_MONGODB_COLLECTION,
    TMP_DB_SQL_TABLE,
    TMP_EXCEPTION_TYPE,
    TMP_EXCEPTION_MESSAGE,
    TMP_EXCEPTION_STACKTRACE,
    TMP_EXCEPTION_ESCAPED,
    TMP_FAAS_TRIGGER,
    TMP_FAAS_EXECUTION,
    TMP_FAAS_DOCUMENT_COLLECTION,
    TMP_FAAS_DOCUMENT_OPERATION,
    TMP_FAAS_DOCUMENT_TIME,
    TMP_FAAS_DOCUMENT_NAME,
    TMP_FAAS_TIME,
    TMP_FAAS_CRON,
    TMP_FAAS_COLDSTART,
    TMP_FAAS_INVOKED_NAME,
    TMP_FAAS_INVOKED_PROVIDER,
    TMP_FAAS_INVOKED_REGION,
    TMP_NET_TRANSPORT,
    TMP_NET_PEER_IP,
    TMP_NET_PEER_PORT,
    TMP_NET_PEER_NAME,
    TMP_NET_HOST_IP,
    TMP_NET_HOST_PORT,
    TMP_NET_HOST_NAME,
    TMP_NET_HOST_CONNECTION_TYPE,
    TMP_NET_HOST_CONNECTION_SUBTYPE,
    TMP_NET_HOST_CARRIER_NAME,
    TMP_NET_HOST_CARRIER_MCC,
    TMP_NET_HOST_CARRIER_MNC,
    TMP_NET_HOST_CARRIER_ICC,
    TMP_PEER_SERVICE,
    TMP_ENDUSER_ID,
    TMP_ENDUSER_ROLE,
    TMP_ENDUSER_SCOPE,
    TMP_THREAD_ID,
    TMP_THREAD_NAME,
    TMP_CODE_FUNCTION,
    TMP_CODE_NAMESPACE,
    TMP_CODE_FILEPATH,
    TMP_CODE_LINENO,
    TMP_HTTP_METHOD,
    TMP_HTTP_URL,
    TMP_HTTP_TARGET,
    TMP_HTTP_HOST,
    TMP_HTTP_SCHEME,
    TMP_HTTP_STATUS_CODE,
    TMP_HTTP_FLAVOR,
    TMP_HTTP_USER_AGENT,
    TMP_HTTP_REQUEST_CONTENT_LENGTH,
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_SERVER_NAME,
    TMP_HTTP_ROUTE,
    TMP_HTTP_CLIENT_IP,
    TMP_AWS_DYNAMODB_TABLE_NAMES,
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
    TMP_AWS_DYNAMODB_CONSISTENT_READ,
    TMP_AWS_DYNAMODB_PROJECTION,
    TMP_AWS_DYNAMODB_LIMIT,
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
    TMP_AWS_DYNAMODB_INDEX_NAME,
    TMP_AWS_DYNAMODB_SELECT,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
    TMP_AWS_DYNAMODB_TABLE_COUNT,
    TMP_AWS_DYNAMODB_SCAN_FORWARD,
    TMP_AWS_DYNAMODB_SEGMENT,
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
    TMP_AWS_DYNAMODB_COUNT,
    TMP_AWS_DYNAMODB_SCANNED_COUNT,
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
    TMP_MESSAGING_SYSTEM,
    TMP_MESSAGING_DESTINATION,
    TMP_MESSAGING_DESTINATION_KIND,
    TMP_MESSAGING_TEMP_DESTINATION,
    TMP_MESSAGING_PROTOCOL,
    TMP_MESSAGING_PROTOCOL_VERSION,
    TMP_MESSAGING_URL,
    TMP_MESSAGING_MESSAGE_ID,
    TMP_MESSAGING_CONVERSATION_ID,
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
    TMP_MESSAGING_OPERATION,
    TMP_MESSAGING_CONSUMER_ID,
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
    TMP_MESSAGING_KAFKA_MESSAGE_KEY,
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
    TMP_MESSAGING_KAFKA_CLIENT_ID,
    TMP_MESSAGING_KAFKA_PARTITION,
    TMP_MESSAGING_KAFKA_TOMBSTONE,
    TMP_RPC_SYSTEM,
    TMP_RPC_SERVICE,
    TMP_RPC_METHOD,
    TMP_RPC_GRPC_STATUS_CODE,
    TMP_RPC_JSONRPC_VERSION,
    TMP_RPC_JSONRPC_REQUEST_ID,
    TMP_RPC_JSONRPC_ERROR_CODE,
    TMP_RPC_JSONRPC_ERROR_MESSAGE,
    TMP_MESSAGE_TYPE,
    TMP_MESSAGE_ID,
    TMP_MESSAGE_COMPRESSED_SIZE,
    TMP_MESSAGE_UNCOMPRESSED_SIZE
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for DbSystemValues enum definition
 *
 * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_DBSYSTEMVALUES_OTHER_SQL = 'other_sql';
var TMP_DBSYSTEMVALUES_MSSQL = 'mssql';
var TMP_DBSYSTEMVALUES_MYSQL = 'mysql';
var TMP_DBSYSTEMVALUES_ORACLE = 'oracle';
var TMP_DBSYSTEMVALUES_DB2 = 'db2';
var TMP_DBSYSTEMVALUES_POSTGRESQL = 'postgresql';
var TMP_DBSYSTEMVALUES_REDSHIFT = 'redshift';
var TMP_DBSYSTEMVALUES_HIVE = 'hive';
var TMP_DBSYSTEMVALUES_CLOUDSCAPE = 'cloudscape';
var TMP_DBSYSTEMVALUES_HSQLDB = 'hsqldb';
var TMP_DBSYSTEMVALUES_PROGRESS = 'progress';
var TMP_DBSYSTEMVALUES_MAXDB = 'maxdb';
var TMP_DBSYSTEMVALUES_HANADB = 'hanadb';
var TMP_DBSYSTEMVALUES_INGRES = 'ingres';
var TMP_DBSYSTEMVALUES_FIRSTSQL = 'firstsql';
var TMP_DBSYSTEMVALUES_EDB = 'edb';
var TMP_DBSYSTEMVALUES_CACHE = 'cache';
var TMP_DBSYSTEMVALUES_ADABAS = 'adabas';
var TMP_DBSYSTEMVALUES_FIREBIRD = 'firebird';
var TMP_DBSYSTEMVALUES_DERBY = 'derby';
var TMP_DBSYSTEMVALUES_FILEMAKER = 'filemaker';
var TMP_DBSYSTEMVALUES_INFORMIX = 'informix';
var TMP_DBSYSTEMVALUES_INSTANTDB = 'instantdb';
var TMP_DBSYSTEMVALUES_INTERBASE = 'interbase';
var TMP_DBSYSTEMVALUES_MARIADB = 'mariadb';
var TMP_DBSYSTEMVALUES_NETEZZA = 'netezza';
var TMP_DBSYSTEMVALUES_PERVASIVE = 'pervasive';
var TMP_DBSYSTEMVALUES_POINTBASE = 'pointbase';
var TMP_DBSYSTEMVALUES_SQLITE = 'sqlite';
var TMP_DBSYSTEMVALUES_SYBASE = 'sybase';
var TMP_DBSYSTEMVALUES_TERADATA = 'teradata';
var TMP_DBSYSTEMVALUES_VERTICA = 'vertica';
var TMP_DBSYSTEMVALUES_H2 = 'h2';
var TMP_DBSYSTEMVALUES_COLDFUSION = 'coldfusion';
var TMP_DBSYSTEMVALUES_CASSANDRA = 'cassandra';
var TMP_DBSYSTEMVALUES_HBASE = 'hbase';
var TMP_DBSYSTEMVALUES_MONGODB = 'mongodb';
var TMP_DBSYSTEMVALUES_REDIS = 'redis';
var TMP_DBSYSTEMVALUES_COUCHBASE = 'couchbase';
var TMP_DBSYSTEMVALUES_COUCHDB = 'couchdb';
var TMP_DBSYSTEMVALUES_COSMOSDB = 'cosmosdb';
var TMP_DBSYSTEMVALUES_DYNAMODB = 'dynamodb';
var TMP_DBSYSTEMVALUES_NEO4J = 'neo4j';
var TMP_DBSYSTEMVALUES_GEODE = 'geode';
var TMP_DBSYSTEMVALUES_ELASTICSEARCH = 'elasticsearch';
var TMP_DBSYSTEMVALUES_MEMCACHED = 'memcached';
var TMP_DBSYSTEMVALUES_COCKROACHDB = 'cockroachdb';
var DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
var DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
var DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
var DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
var DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
var DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
var DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
var DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
var DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
var DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
var DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
var DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
var DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
var DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
var DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
var DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
var DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
var DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
var DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
var DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
var DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
var DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
var DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
var DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
var DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
var DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
var DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
var DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
var DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
var DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
var DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
var DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
var DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
var DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
var DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
var DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
var DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
var DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
var DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
var DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
var DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
var DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
var DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
var DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
var DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
var DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
var DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
var DbSystemValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_DBSYSTEMVALUES_OTHER_SQL,
    TMP_DBSYSTEMVALUES_MSSQL,
    TMP_DBSYSTEMVALUES_MYSQL,
    TMP_DBSYSTEMVALUES_ORACLE,
    TMP_DBSYSTEMVALUES_DB2,
    TMP_DBSYSTEMVALUES_POSTGRESQL,
    TMP_DBSYSTEMVALUES_REDSHIFT,
    TMP_DBSYSTEMVALUES_HIVE,
    TMP_DBSYSTEMVALUES_CLOUDSCAPE,
    TMP_DBSYSTEMVALUES_HSQLDB,
    TMP_DBSYSTEMVALUES_PROGRESS,
    TMP_DBSYSTEMVALUES_MAXDB,
    TMP_DBSYSTEMVALUES_HANADB,
    TMP_DBSYSTEMVALUES_INGRES,
    TMP_DBSYSTEMVALUES_FIRSTSQL,
    TMP_DBSYSTEMVALUES_EDB,
    TMP_DBSYSTEMVALUES_CACHE,
    TMP_DBSYSTEMVALUES_ADABAS,
    TMP_DBSYSTEMVALUES_FIREBIRD,
    TMP_DBSYSTEMVALUES_DERBY,
    TMP_DBSYSTEMVALUES_FILEMAKER,
    TMP_DBSYSTEMVALUES_INFORMIX,
    TMP_DBSYSTEMVALUES_INSTANTDB,
    TMP_DBSYSTEMVALUES_INTERBASE,
    TMP_DBSYSTEMVALUES_MARIADB,
    TMP_DBSYSTEMVALUES_NETEZZA,
    TMP_DBSYSTEMVALUES_PERVASIVE,
    TMP_DBSYSTEMVALUES_POINTBASE,
    TMP_DBSYSTEMVALUES_SQLITE,
    TMP_DBSYSTEMVALUES_SYBASE,
    TMP_DBSYSTEMVALUES_TERADATA,
    TMP_DBSYSTEMVALUES_VERTICA,
    TMP_DBSYSTEMVALUES_H2,
    TMP_DBSYSTEMVALUES_COLDFUSION,
    TMP_DBSYSTEMVALUES_CASSANDRA,
    TMP_DBSYSTEMVALUES_HBASE,
    TMP_DBSYSTEMVALUES_MONGODB,
    TMP_DBSYSTEMVALUES_REDIS,
    TMP_DBSYSTEMVALUES_COUCHBASE,
    TMP_DBSYSTEMVALUES_COUCHDB,
    TMP_DBSYSTEMVALUES_COSMOSDB,
    TMP_DBSYSTEMVALUES_DYNAMODB,
    TMP_DBSYSTEMVALUES_NEO4J,
    TMP_DBSYSTEMVALUES_GEODE,
    TMP_DBSYSTEMVALUES_ELASTICSEARCH,
    TMP_DBSYSTEMVALUES_MEMCACHED,
    TMP_DBSYSTEMVALUES_COCKROACHDB
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for DbCassandraConsistencyLevelValues enum definition
 *
 * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = 'all';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = 'each_quorum';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = 'quorum';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = 'local_quorum';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = 'one';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = 'two';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = 'three';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = 'local_one';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = 'any';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = 'serial';
var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = 'local_serial';
var DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
var DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
var DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
var DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
var DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
var DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
var DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
var DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
var DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
var DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
var DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
var DbCassandraConsistencyLevelValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for FaasTriggerValues enum definition
 *
 * Type of the trigger on which the function is executed.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_FAASTRIGGERVALUES_DATASOURCE = 'datasource';
var TMP_FAASTRIGGERVALUES_HTTP = 'http';
var TMP_FAASTRIGGERVALUES_PUBSUB = 'pubsub';
var TMP_FAASTRIGGERVALUES_TIMER = 'timer';
var TMP_FAASTRIGGERVALUES_OTHER = 'other';
var FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
var FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
var FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
var FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
var FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
var FaasTriggerValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_FAASTRIGGERVALUES_DATASOURCE,
    TMP_FAASTRIGGERVALUES_HTTP,
    TMP_FAASTRIGGERVALUES_PUBSUB,
    TMP_FAASTRIGGERVALUES_TIMER,
    TMP_FAASTRIGGERVALUES_OTHER
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for FaasDocumentOperationValues enum definition
 *
 * Describes the type of the operation that was performed on the data.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = 'insert';
var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = 'edit';
var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = 'delete';
var FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
var FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
var FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
var FaasDocumentOperationValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for FaasInvokedProviderValues enum definition
 *
 * The cloud provider of the invoked function.
 *
 * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = 'alibaba_cloud';
var TMP_FAASINVOKEDPROVIDERVALUES_AWS = 'aws';
var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = 'azure';
var TMP_FAASINVOKEDPROVIDERVALUES_GCP = 'gcp';
var FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
var FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
var FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
var FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
var FaasInvokedProviderValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_FAASINVOKEDPROVIDERVALUES_AWS,
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
    TMP_FAASINVOKEDPROVIDERVALUES_GCP
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for NetTransportValues enum definition
 *
 * Transport protocol used. See note below.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_NETTRANSPORTVALUES_IP_TCP = 'ip_tcp';
var TMP_NETTRANSPORTVALUES_IP_UDP = 'ip_udp';
var TMP_NETTRANSPORTVALUES_IP = 'ip';
var TMP_NETTRANSPORTVALUES_UNIX = 'unix';
var TMP_NETTRANSPORTVALUES_PIPE = 'pipe';
var TMP_NETTRANSPORTVALUES_INPROC = 'inproc';
var TMP_NETTRANSPORTVALUES_OTHER = 'other';
var NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
var NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
var NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
var NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
var NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
var NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
var NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
var NetTransportValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_NETTRANSPORTVALUES_IP_TCP,
    TMP_NETTRANSPORTVALUES_IP_UDP,
    TMP_NETTRANSPORTVALUES_IP,
    TMP_NETTRANSPORTVALUES_UNIX,
    TMP_NETTRANSPORTVALUES_PIPE,
    TMP_NETTRANSPORTVALUES_INPROC,
    TMP_NETTRANSPORTVALUES_OTHER
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for NetHostConnectionTypeValues enum definition
 *
 * The internet connection type currently being used by the host.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = 'wifi';
var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = 'wired';
var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = 'cell';
var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = 'unavailable';
var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = 'unknown';
var NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
var NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
var NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
var NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
var NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
var NetHostConnectionTypeValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for NetHostConnectionSubtypeValues enum definition
 *
 * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = 'gprs';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = 'edge';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = 'umts';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = 'cdma';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = 'evdo_0';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = 'evdo_a';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = 'cdma2000_1xrtt';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = 'hsdpa';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = 'hsupa';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = 'hspa';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = 'iden';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = 'evdo_b';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = 'lte';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = 'ehrpd';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = 'hspap';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = 'gsm';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = 'td_scdma';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = 'iwlan';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = 'nr';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = 'nrnsa';
var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = 'lte_ca';
var NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
var NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
var NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
var NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
var NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
var NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
var NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
var NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
var NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
var NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
var NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
var NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
var NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
var NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
var NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
var NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
var NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
var NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
var NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
var NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
var NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
var NetHostConnectionSubtypeValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for HttpFlavorValues enum definition
 *
 * Kind of HTTP protocol used.
 *
 * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_HTTPFLAVORVALUES_HTTP_1_0 = '1.0';
var TMP_HTTPFLAVORVALUES_HTTP_1_1 = '1.1';
var TMP_HTTPFLAVORVALUES_HTTP_2_0 = '2.0';
var TMP_HTTPFLAVORVALUES_SPDY = 'SPDY';
var TMP_HTTPFLAVORVALUES_QUIC = 'QUIC';
var HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
var HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
var HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
var HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
var HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
var HttpFlavorValues = {
    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
    SPDY: TMP_HTTPFLAVORVALUES_SPDY,
    QUIC: TMP_HTTPFLAVORVALUES_QUIC
};
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for MessagingDestinationKindValues enum definition
 *
 * The kind of message destination.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = 'queue';
var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = 'topic';
var MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
var MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
var MessagingDestinationKindValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for MessagingOperationValues enum definition
 *
 * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = 'receive';
var TMP_MESSAGINGOPERATIONVALUES_PROCESS = 'process';
var MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
var MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
var MessagingOperationValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
    TMP_MESSAGINGOPERATIONVALUES_PROCESS
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for RpcGrpcStatusCodeValues enum definition
 *
 * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
var RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
var RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
var RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
var RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
var RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
var RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
var RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
var RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
var RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
var RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
var RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
var RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
var RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
var RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
var RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
var RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
var RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
var RpcGrpcStatusCodeValues = {
    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
};
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for MessageTypeValues enum definition
 *
 * Whether this is a received or sent message.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_MESSAGETYPEVALUES_SENT = 'SENT';
var TMP_MESSAGETYPEVALUES_RECEIVED = 'RECEIVED';
var MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
var MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
var MessageTypeValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_MESSAGETYPEVALUES_SENT,
    TMP_MESSAGETYPEVALUES_RECEIVED
]);

},{"../internal/utils":"hV8FE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hV8FE":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Creates a const map from the given values
 * @param values - An array of values to be used as keys and values in the map.
 * @returns A populated version of the map with the values and keys derived from the values.
 */ /*#__NO_SIDE_EFFECTS__*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createConstMap", ()=>createConstMap);
function createConstMap(values) {
    // eslint-disable-next-line prefer-const, @typescript-eslint/no-explicit-any
    var res = {};
    var len = values.length;
    for(var lp = 0; lp < len; lp++){
        var val = values[lp];
        if (val) res[String(val).toUpperCase().replace(/[-.]/g, '_')] = val;
    }
    return res;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6gLs0":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* eslint-disable no-restricted-syntax --
 * These re-exports are only of constants, only one-level deep at this point,
 * and should not cause problems for tree-shakers.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _semanticResourceAttributes = require("./SemanticResourceAttributes");
parcelHelpers.exportAll(_semanticResourceAttributes, exports);

},{"./SemanticResourceAttributes":"7C7hx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7C7hx":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SEMRESATTRS_CLOUD_PROVIDER", ()=>SEMRESATTRS_CLOUD_PROVIDER);
parcelHelpers.export(exports, "SEMRESATTRS_CLOUD_ACCOUNT_ID", ()=>SEMRESATTRS_CLOUD_ACCOUNT_ID);
parcelHelpers.export(exports, "SEMRESATTRS_CLOUD_REGION", ()=>SEMRESATTRS_CLOUD_REGION);
parcelHelpers.export(exports, "SEMRESATTRS_CLOUD_AVAILABILITY_ZONE", ()=>SEMRESATTRS_CLOUD_AVAILABILITY_ZONE);
parcelHelpers.export(exports, "SEMRESATTRS_CLOUD_PLATFORM", ()=>SEMRESATTRS_CLOUD_PLATFORM);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_ECS_CONTAINER_ARN", ()=>SEMRESATTRS_AWS_ECS_CONTAINER_ARN);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_ECS_CLUSTER_ARN", ()=>SEMRESATTRS_AWS_ECS_CLUSTER_ARN);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_ECS_LAUNCHTYPE", ()=>SEMRESATTRS_AWS_ECS_LAUNCHTYPE);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_ECS_TASK_ARN", ()=>SEMRESATTRS_AWS_ECS_TASK_ARN);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_ECS_TASK_FAMILY", ()=>SEMRESATTRS_AWS_ECS_TASK_FAMILY);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_ECS_TASK_REVISION", ()=>SEMRESATTRS_AWS_ECS_TASK_REVISION);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_EKS_CLUSTER_ARN", ()=>SEMRESATTRS_AWS_EKS_CLUSTER_ARN);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_LOG_GROUP_NAMES", ()=>SEMRESATTRS_AWS_LOG_GROUP_NAMES);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_LOG_GROUP_ARNS", ()=>SEMRESATTRS_AWS_LOG_GROUP_ARNS);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_LOG_STREAM_NAMES", ()=>SEMRESATTRS_AWS_LOG_STREAM_NAMES);
parcelHelpers.export(exports, "SEMRESATTRS_AWS_LOG_STREAM_ARNS", ()=>SEMRESATTRS_AWS_LOG_STREAM_ARNS);
parcelHelpers.export(exports, "SEMRESATTRS_CONTAINER_NAME", ()=>SEMRESATTRS_CONTAINER_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_CONTAINER_ID", ()=>SEMRESATTRS_CONTAINER_ID);
parcelHelpers.export(exports, "SEMRESATTRS_CONTAINER_RUNTIME", ()=>SEMRESATTRS_CONTAINER_RUNTIME);
parcelHelpers.export(exports, "SEMRESATTRS_CONTAINER_IMAGE_NAME", ()=>SEMRESATTRS_CONTAINER_IMAGE_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_CONTAINER_IMAGE_TAG", ()=>SEMRESATTRS_CONTAINER_IMAGE_TAG);
parcelHelpers.export(exports, "SEMRESATTRS_DEPLOYMENT_ENVIRONMENT", ()=>SEMRESATTRS_DEPLOYMENT_ENVIRONMENT);
parcelHelpers.export(exports, "SEMRESATTRS_DEVICE_ID", ()=>SEMRESATTRS_DEVICE_ID);
parcelHelpers.export(exports, "SEMRESATTRS_DEVICE_MODEL_IDENTIFIER", ()=>SEMRESATTRS_DEVICE_MODEL_IDENTIFIER);
parcelHelpers.export(exports, "SEMRESATTRS_DEVICE_MODEL_NAME", ()=>SEMRESATTRS_DEVICE_MODEL_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_FAAS_NAME", ()=>SEMRESATTRS_FAAS_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_FAAS_ID", ()=>SEMRESATTRS_FAAS_ID);
parcelHelpers.export(exports, "SEMRESATTRS_FAAS_VERSION", ()=>SEMRESATTRS_FAAS_VERSION);
parcelHelpers.export(exports, "SEMRESATTRS_FAAS_INSTANCE", ()=>SEMRESATTRS_FAAS_INSTANCE);
parcelHelpers.export(exports, "SEMRESATTRS_FAAS_MAX_MEMORY", ()=>SEMRESATTRS_FAAS_MAX_MEMORY);
parcelHelpers.export(exports, "SEMRESATTRS_HOST_ID", ()=>SEMRESATTRS_HOST_ID);
parcelHelpers.export(exports, "SEMRESATTRS_HOST_NAME", ()=>SEMRESATTRS_HOST_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_HOST_TYPE", ()=>SEMRESATTRS_HOST_TYPE);
parcelHelpers.export(exports, "SEMRESATTRS_HOST_ARCH", ()=>SEMRESATTRS_HOST_ARCH);
parcelHelpers.export(exports, "SEMRESATTRS_HOST_IMAGE_NAME", ()=>SEMRESATTRS_HOST_IMAGE_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_HOST_IMAGE_ID", ()=>SEMRESATTRS_HOST_IMAGE_ID);
parcelHelpers.export(exports, "SEMRESATTRS_HOST_IMAGE_VERSION", ()=>SEMRESATTRS_HOST_IMAGE_VERSION);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_CLUSTER_NAME", ()=>SEMRESATTRS_K8S_CLUSTER_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_NODE_NAME", ()=>SEMRESATTRS_K8S_NODE_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_NODE_UID", ()=>SEMRESATTRS_K8S_NODE_UID);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_NAMESPACE_NAME", ()=>SEMRESATTRS_K8S_NAMESPACE_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_POD_UID", ()=>SEMRESATTRS_K8S_POD_UID);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_POD_NAME", ()=>SEMRESATTRS_K8S_POD_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_CONTAINER_NAME", ()=>SEMRESATTRS_K8S_CONTAINER_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_REPLICASET_UID", ()=>SEMRESATTRS_K8S_REPLICASET_UID);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_REPLICASET_NAME", ()=>SEMRESATTRS_K8S_REPLICASET_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_DEPLOYMENT_UID", ()=>SEMRESATTRS_K8S_DEPLOYMENT_UID);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_DEPLOYMENT_NAME", ()=>SEMRESATTRS_K8S_DEPLOYMENT_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_STATEFULSET_UID", ()=>SEMRESATTRS_K8S_STATEFULSET_UID);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_STATEFULSET_NAME", ()=>SEMRESATTRS_K8S_STATEFULSET_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_DAEMONSET_UID", ()=>SEMRESATTRS_K8S_DAEMONSET_UID);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_DAEMONSET_NAME", ()=>SEMRESATTRS_K8S_DAEMONSET_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_JOB_UID", ()=>SEMRESATTRS_K8S_JOB_UID);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_JOB_NAME", ()=>SEMRESATTRS_K8S_JOB_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_CRONJOB_UID", ()=>SEMRESATTRS_K8S_CRONJOB_UID);
parcelHelpers.export(exports, "SEMRESATTRS_K8S_CRONJOB_NAME", ()=>SEMRESATTRS_K8S_CRONJOB_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_OS_TYPE", ()=>SEMRESATTRS_OS_TYPE);
parcelHelpers.export(exports, "SEMRESATTRS_OS_DESCRIPTION", ()=>SEMRESATTRS_OS_DESCRIPTION);
parcelHelpers.export(exports, "SEMRESATTRS_OS_NAME", ()=>SEMRESATTRS_OS_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_OS_VERSION", ()=>SEMRESATTRS_OS_VERSION);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_PID", ()=>SEMRESATTRS_PROCESS_PID);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_EXECUTABLE_NAME", ()=>SEMRESATTRS_PROCESS_EXECUTABLE_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_EXECUTABLE_PATH", ()=>SEMRESATTRS_PROCESS_EXECUTABLE_PATH);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_COMMAND", ()=>SEMRESATTRS_PROCESS_COMMAND);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_COMMAND_LINE", ()=>SEMRESATTRS_PROCESS_COMMAND_LINE);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_COMMAND_ARGS", ()=>SEMRESATTRS_PROCESS_COMMAND_ARGS);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_OWNER", ()=>SEMRESATTRS_PROCESS_OWNER);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_RUNTIME_NAME", ()=>SEMRESATTRS_PROCESS_RUNTIME_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_RUNTIME_VERSION", ()=>SEMRESATTRS_PROCESS_RUNTIME_VERSION);
parcelHelpers.export(exports, "SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION", ()=>SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION);
parcelHelpers.export(exports, "SEMRESATTRS_SERVICE_NAME", ()=>SEMRESATTRS_SERVICE_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_SERVICE_NAMESPACE", ()=>SEMRESATTRS_SERVICE_NAMESPACE);
parcelHelpers.export(exports, "SEMRESATTRS_SERVICE_INSTANCE_ID", ()=>SEMRESATTRS_SERVICE_INSTANCE_ID);
parcelHelpers.export(exports, "SEMRESATTRS_SERVICE_VERSION", ()=>SEMRESATTRS_SERVICE_VERSION);
parcelHelpers.export(exports, "SEMRESATTRS_TELEMETRY_SDK_NAME", ()=>SEMRESATTRS_TELEMETRY_SDK_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_TELEMETRY_SDK_LANGUAGE", ()=>SEMRESATTRS_TELEMETRY_SDK_LANGUAGE);
parcelHelpers.export(exports, "SEMRESATTRS_TELEMETRY_SDK_VERSION", ()=>SEMRESATTRS_TELEMETRY_SDK_VERSION);
parcelHelpers.export(exports, "SEMRESATTRS_TELEMETRY_AUTO_VERSION", ()=>SEMRESATTRS_TELEMETRY_AUTO_VERSION);
parcelHelpers.export(exports, "SEMRESATTRS_WEBENGINE_NAME", ()=>SEMRESATTRS_WEBENGINE_NAME);
parcelHelpers.export(exports, "SEMRESATTRS_WEBENGINE_VERSION", ()=>SEMRESATTRS_WEBENGINE_VERSION);
parcelHelpers.export(exports, "SEMRESATTRS_WEBENGINE_DESCRIPTION", ()=>SEMRESATTRS_WEBENGINE_DESCRIPTION);
parcelHelpers.export(exports, "SemanticResourceAttributes", ()=>SemanticResourceAttributes);
parcelHelpers.export(exports, "CLOUDPROVIDERVALUES_ALIBABA_CLOUD", ()=>CLOUDPROVIDERVALUES_ALIBABA_CLOUD);
parcelHelpers.export(exports, "CLOUDPROVIDERVALUES_AWS", ()=>CLOUDPROVIDERVALUES_AWS);
parcelHelpers.export(exports, "CLOUDPROVIDERVALUES_AZURE", ()=>CLOUDPROVIDERVALUES_AZURE);
parcelHelpers.export(exports, "CLOUDPROVIDERVALUES_GCP", ()=>CLOUDPROVIDERVALUES_GCP);
parcelHelpers.export(exports, "CloudProviderValues", ()=>CloudProviderValues);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS", ()=>CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC", ()=>CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AWS_EC2", ()=>CLOUDPLATFORMVALUES_AWS_EC2);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AWS_ECS", ()=>CLOUDPLATFORMVALUES_AWS_ECS);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AWS_EKS", ()=>CLOUDPLATFORMVALUES_AWS_EKS);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AWS_LAMBDA", ()=>CLOUDPLATFORMVALUES_AWS_LAMBDA);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK", ()=>CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AZURE_VM", ()=>CLOUDPLATFORMVALUES_AZURE_VM);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES", ()=>CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AZURE_AKS", ()=>CLOUDPLATFORMVALUES_AZURE_AKS);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AZURE_FUNCTIONS", ()=>CLOUDPLATFORMVALUES_AZURE_FUNCTIONS);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_AZURE_APP_SERVICE", ()=>CLOUDPLATFORMVALUES_AZURE_APP_SERVICE);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE", ()=>CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_GCP_CLOUD_RUN", ()=>CLOUDPLATFORMVALUES_GCP_CLOUD_RUN);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE", ()=>CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS", ()=>CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS);
parcelHelpers.export(exports, "CLOUDPLATFORMVALUES_GCP_APP_ENGINE", ()=>CLOUDPLATFORMVALUES_GCP_APP_ENGINE);
parcelHelpers.export(exports, "CloudPlatformValues", ()=>CloudPlatformValues);
parcelHelpers.export(exports, "AWSECSLAUNCHTYPEVALUES_EC2", ()=>AWSECSLAUNCHTYPEVALUES_EC2);
parcelHelpers.export(exports, "AWSECSLAUNCHTYPEVALUES_FARGATE", ()=>AWSECSLAUNCHTYPEVALUES_FARGATE);
parcelHelpers.export(exports, "AwsEcsLaunchtypeValues", ()=>AwsEcsLaunchtypeValues);
parcelHelpers.export(exports, "HOSTARCHVALUES_AMD64", ()=>HOSTARCHVALUES_AMD64);
parcelHelpers.export(exports, "HOSTARCHVALUES_ARM32", ()=>HOSTARCHVALUES_ARM32);
parcelHelpers.export(exports, "HOSTARCHVALUES_ARM64", ()=>HOSTARCHVALUES_ARM64);
parcelHelpers.export(exports, "HOSTARCHVALUES_IA64", ()=>HOSTARCHVALUES_IA64);
parcelHelpers.export(exports, "HOSTARCHVALUES_PPC32", ()=>HOSTARCHVALUES_PPC32);
parcelHelpers.export(exports, "HOSTARCHVALUES_PPC64", ()=>HOSTARCHVALUES_PPC64);
parcelHelpers.export(exports, "HOSTARCHVALUES_X86", ()=>HOSTARCHVALUES_X86);
parcelHelpers.export(exports, "HostArchValues", ()=>HostArchValues);
parcelHelpers.export(exports, "OSTYPEVALUES_WINDOWS", ()=>OSTYPEVALUES_WINDOWS);
parcelHelpers.export(exports, "OSTYPEVALUES_LINUX", ()=>OSTYPEVALUES_LINUX);
parcelHelpers.export(exports, "OSTYPEVALUES_DARWIN", ()=>OSTYPEVALUES_DARWIN);
parcelHelpers.export(exports, "OSTYPEVALUES_FREEBSD", ()=>OSTYPEVALUES_FREEBSD);
parcelHelpers.export(exports, "OSTYPEVALUES_NETBSD", ()=>OSTYPEVALUES_NETBSD);
parcelHelpers.export(exports, "OSTYPEVALUES_OPENBSD", ()=>OSTYPEVALUES_OPENBSD);
parcelHelpers.export(exports, "OSTYPEVALUES_DRAGONFLYBSD", ()=>OSTYPEVALUES_DRAGONFLYBSD);
parcelHelpers.export(exports, "OSTYPEVALUES_HPUX", ()=>OSTYPEVALUES_HPUX);
parcelHelpers.export(exports, "OSTYPEVALUES_AIX", ()=>OSTYPEVALUES_AIX);
parcelHelpers.export(exports, "OSTYPEVALUES_SOLARIS", ()=>OSTYPEVALUES_SOLARIS);
parcelHelpers.export(exports, "OSTYPEVALUES_Z_OS", ()=>OSTYPEVALUES_Z_OS);
parcelHelpers.export(exports, "OsTypeValues", ()=>OsTypeValues);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_CPP", ()=>TELEMETRYSDKLANGUAGEVALUES_CPP);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_DOTNET", ()=>TELEMETRYSDKLANGUAGEVALUES_DOTNET);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_ERLANG", ()=>TELEMETRYSDKLANGUAGEVALUES_ERLANG);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_GO", ()=>TELEMETRYSDKLANGUAGEVALUES_GO);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_JAVA", ()=>TELEMETRYSDKLANGUAGEVALUES_JAVA);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_NODEJS", ()=>TELEMETRYSDKLANGUAGEVALUES_NODEJS);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_PHP", ()=>TELEMETRYSDKLANGUAGEVALUES_PHP);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_PYTHON", ()=>TELEMETRYSDKLANGUAGEVALUES_PYTHON);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_RUBY", ()=>TELEMETRYSDKLANGUAGEVALUES_RUBY);
parcelHelpers.export(exports, "TELEMETRYSDKLANGUAGEVALUES_WEBJS", ()=>TELEMETRYSDKLANGUAGEVALUES_WEBJS);
parcelHelpers.export(exports, "TelemetrySdkLanguageValues", ()=>TelemetrySdkLanguageValues);
var _utils = require("../internal/utils");
//----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
// Constant values for SemanticResourceAttributes
//----------------------------------------------------------------------------------------------------------
// Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_CLOUD_PROVIDER = 'cloud.provider';
var TMP_CLOUD_ACCOUNT_ID = 'cloud.account.id';
var TMP_CLOUD_REGION = 'cloud.region';
var TMP_CLOUD_AVAILABILITY_ZONE = 'cloud.availability_zone';
var TMP_CLOUD_PLATFORM = 'cloud.platform';
var TMP_AWS_ECS_CONTAINER_ARN = 'aws.ecs.container.arn';
var TMP_AWS_ECS_CLUSTER_ARN = 'aws.ecs.cluster.arn';
var TMP_AWS_ECS_LAUNCHTYPE = 'aws.ecs.launchtype';
var TMP_AWS_ECS_TASK_ARN = 'aws.ecs.task.arn';
var TMP_AWS_ECS_TASK_FAMILY = 'aws.ecs.task.family';
var TMP_AWS_ECS_TASK_REVISION = 'aws.ecs.task.revision';
var TMP_AWS_EKS_CLUSTER_ARN = 'aws.eks.cluster.arn';
var TMP_AWS_LOG_GROUP_NAMES = 'aws.log.group.names';
var TMP_AWS_LOG_GROUP_ARNS = 'aws.log.group.arns';
var TMP_AWS_LOG_STREAM_NAMES = 'aws.log.stream.names';
var TMP_AWS_LOG_STREAM_ARNS = 'aws.log.stream.arns';
var TMP_CONTAINER_NAME = 'container.name';
var TMP_CONTAINER_ID = 'container.id';
var TMP_CONTAINER_RUNTIME = 'container.runtime';
var TMP_CONTAINER_IMAGE_NAME = 'container.image.name';
var TMP_CONTAINER_IMAGE_TAG = 'container.image.tag';
var TMP_DEPLOYMENT_ENVIRONMENT = 'deployment.environment';
var TMP_DEVICE_ID = 'device.id';
var TMP_DEVICE_MODEL_IDENTIFIER = 'device.model.identifier';
var TMP_DEVICE_MODEL_NAME = 'device.model.name';
var TMP_FAAS_NAME = 'faas.name';
var TMP_FAAS_ID = 'faas.id';
var TMP_FAAS_VERSION = 'faas.version';
var TMP_FAAS_INSTANCE = 'faas.instance';
var TMP_FAAS_MAX_MEMORY = 'faas.max_memory';
var TMP_HOST_ID = 'host.id';
var TMP_HOST_NAME = 'host.name';
var TMP_HOST_TYPE = 'host.type';
var TMP_HOST_ARCH = 'host.arch';
var TMP_HOST_IMAGE_NAME = 'host.image.name';
var TMP_HOST_IMAGE_ID = 'host.image.id';
var TMP_HOST_IMAGE_VERSION = 'host.image.version';
var TMP_K8S_CLUSTER_NAME = 'k8s.cluster.name';
var TMP_K8S_NODE_NAME = 'k8s.node.name';
var TMP_K8S_NODE_UID = 'k8s.node.uid';
var TMP_K8S_NAMESPACE_NAME = 'k8s.namespace.name';
var TMP_K8S_POD_UID = 'k8s.pod.uid';
var TMP_K8S_POD_NAME = 'k8s.pod.name';
var TMP_K8S_CONTAINER_NAME = 'k8s.container.name';
var TMP_K8S_REPLICASET_UID = 'k8s.replicaset.uid';
var TMP_K8S_REPLICASET_NAME = 'k8s.replicaset.name';
var TMP_K8S_DEPLOYMENT_UID = 'k8s.deployment.uid';
var TMP_K8S_DEPLOYMENT_NAME = 'k8s.deployment.name';
var TMP_K8S_STATEFULSET_UID = 'k8s.statefulset.uid';
var TMP_K8S_STATEFULSET_NAME = 'k8s.statefulset.name';
var TMP_K8S_DAEMONSET_UID = 'k8s.daemonset.uid';
var TMP_K8S_DAEMONSET_NAME = 'k8s.daemonset.name';
var TMP_K8S_JOB_UID = 'k8s.job.uid';
var TMP_K8S_JOB_NAME = 'k8s.job.name';
var TMP_K8S_CRONJOB_UID = 'k8s.cronjob.uid';
var TMP_K8S_CRONJOB_NAME = 'k8s.cronjob.name';
var TMP_OS_TYPE = 'os.type';
var TMP_OS_DESCRIPTION = 'os.description';
var TMP_OS_NAME = 'os.name';
var TMP_OS_VERSION = 'os.version';
var TMP_PROCESS_PID = 'process.pid';
var TMP_PROCESS_EXECUTABLE_NAME = 'process.executable.name';
var TMP_PROCESS_EXECUTABLE_PATH = 'process.executable.path';
var TMP_PROCESS_COMMAND = 'process.command';
var TMP_PROCESS_COMMAND_LINE = 'process.command_line';
var TMP_PROCESS_COMMAND_ARGS = 'process.command_args';
var TMP_PROCESS_OWNER = 'process.owner';
var TMP_PROCESS_RUNTIME_NAME = 'process.runtime.name';
var TMP_PROCESS_RUNTIME_VERSION = 'process.runtime.version';
var TMP_PROCESS_RUNTIME_DESCRIPTION = 'process.runtime.description';
var TMP_SERVICE_NAME = 'service.name';
var TMP_SERVICE_NAMESPACE = 'service.namespace';
var TMP_SERVICE_INSTANCE_ID = 'service.instance.id';
var TMP_SERVICE_VERSION = 'service.version';
var TMP_TELEMETRY_SDK_NAME = 'telemetry.sdk.name';
var TMP_TELEMETRY_SDK_LANGUAGE = 'telemetry.sdk.language';
var TMP_TELEMETRY_SDK_VERSION = 'telemetry.sdk.version';
var TMP_TELEMETRY_AUTO_VERSION = 'telemetry.auto.version';
var TMP_WEBENGINE_NAME = 'webengine.name';
var TMP_WEBENGINE_VERSION = 'webengine.version';
var TMP_WEBENGINE_DESCRIPTION = 'webengine.description';
var SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
var SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
var SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
var SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
var SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
var SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
var SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
var SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
var SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
var SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
var SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
var SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
var SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
var SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
var SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
var SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
var SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
var SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
var SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
var SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
var SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
var SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
var SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
var SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
var SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
var SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
var SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
var SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
var SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
var SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
var SEMRESATTRS_HOST_ID = TMP_HOST_ID;
var SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
var SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
var SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
var SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
var SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
var SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
var SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
var SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
var SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
var SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
var SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
var SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
var SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
var SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
var SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
var SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
var SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
var SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
var SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
var SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
var SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
var SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
var SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
var SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
var SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
var SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
var SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
var SEMRESATTRS_OS_NAME = TMP_OS_NAME;
var SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
var SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
var SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
var SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
var SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
var SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
var SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
var SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
var SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
var SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
var SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
var SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
var SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
var SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
var SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
var SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
var SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
var SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
var SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
var SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
var SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
var SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
var SemanticResourceAttributes = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_CLOUD_PROVIDER,
    TMP_CLOUD_ACCOUNT_ID,
    TMP_CLOUD_REGION,
    TMP_CLOUD_AVAILABILITY_ZONE,
    TMP_CLOUD_PLATFORM,
    TMP_AWS_ECS_CONTAINER_ARN,
    TMP_AWS_ECS_CLUSTER_ARN,
    TMP_AWS_ECS_LAUNCHTYPE,
    TMP_AWS_ECS_TASK_ARN,
    TMP_AWS_ECS_TASK_FAMILY,
    TMP_AWS_ECS_TASK_REVISION,
    TMP_AWS_EKS_CLUSTER_ARN,
    TMP_AWS_LOG_GROUP_NAMES,
    TMP_AWS_LOG_GROUP_ARNS,
    TMP_AWS_LOG_STREAM_NAMES,
    TMP_AWS_LOG_STREAM_ARNS,
    TMP_CONTAINER_NAME,
    TMP_CONTAINER_ID,
    TMP_CONTAINER_RUNTIME,
    TMP_CONTAINER_IMAGE_NAME,
    TMP_CONTAINER_IMAGE_TAG,
    TMP_DEPLOYMENT_ENVIRONMENT,
    TMP_DEVICE_ID,
    TMP_DEVICE_MODEL_IDENTIFIER,
    TMP_DEVICE_MODEL_NAME,
    TMP_FAAS_NAME,
    TMP_FAAS_ID,
    TMP_FAAS_VERSION,
    TMP_FAAS_INSTANCE,
    TMP_FAAS_MAX_MEMORY,
    TMP_HOST_ID,
    TMP_HOST_NAME,
    TMP_HOST_TYPE,
    TMP_HOST_ARCH,
    TMP_HOST_IMAGE_NAME,
    TMP_HOST_IMAGE_ID,
    TMP_HOST_IMAGE_VERSION,
    TMP_K8S_CLUSTER_NAME,
    TMP_K8S_NODE_NAME,
    TMP_K8S_NODE_UID,
    TMP_K8S_NAMESPACE_NAME,
    TMP_K8S_POD_UID,
    TMP_K8S_POD_NAME,
    TMP_K8S_CONTAINER_NAME,
    TMP_K8S_REPLICASET_UID,
    TMP_K8S_REPLICASET_NAME,
    TMP_K8S_DEPLOYMENT_UID,
    TMP_K8S_DEPLOYMENT_NAME,
    TMP_K8S_STATEFULSET_UID,
    TMP_K8S_STATEFULSET_NAME,
    TMP_K8S_DAEMONSET_UID,
    TMP_K8S_DAEMONSET_NAME,
    TMP_K8S_JOB_UID,
    TMP_K8S_JOB_NAME,
    TMP_K8S_CRONJOB_UID,
    TMP_K8S_CRONJOB_NAME,
    TMP_OS_TYPE,
    TMP_OS_DESCRIPTION,
    TMP_OS_NAME,
    TMP_OS_VERSION,
    TMP_PROCESS_PID,
    TMP_PROCESS_EXECUTABLE_NAME,
    TMP_PROCESS_EXECUTABLE_PATH,
    TMP_PROCESS_COMMAND,
    TMP_PROCESS_COMMAND_LINE,
    TMP_PROCESS_COMMAND_ARGS,
    TMP_PROCESS_OWNER,
    TMP_PROCESS_RUNTIME_NAME,
    TMP_PROCESS_RUNTIME_VERSION,
    TMP_PROCESS_RUNTIME_DESCRIPTION,
    TMP_SERVICE_NAME,
    TMP_SERVICE_NAMESPACE,
    TMP_SERVICE_INSTANCE_ID,
    TMP_SERVICE_VERSION,
    TMP_TELEMETRY_SDK_NAME,
    TMP_TELEMETRY_SDK_LANGUAGE,
    TMP_TELEMETRY_SDK_VERSION,
    TMP_TELEMETRY_AUTO_VERSION,
    TMP_WEBENGINE_NAME,
    TMP_WEBENGINE_VERSION,
    TMP_WEBENGINE_DESCRIPTION
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for CloudProviderValues enum definition
 *
 * Name of the cloud provider.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = 'alibaba_cloud';
var TMP_CLOUDPROVIDERVALUES_AWS = 'aws';
var TMP_CLOUDPROVIDERVALUES_AZURE = 'azure';
var TMP_CLOUDPROVIDERVALUES_GCP = 'gcp';
var CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
var CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
var CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
var CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
var CloudProviderValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_CLOUDPROVIDERVALUES_AWS,
    TMP_CLOUDPROVIDERVALUES_AZURE,
    TMP_CLOUDPROVIDERVALUES_GCP
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for CloudPlatformValues enum definition
 *
 * The cloud platform in use.
 *
 * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = 'alibaba_cloud_ecs';
var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = 'alibaba_cloud_fc';
var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = 'aws_ec2';
var TMP_CLOUDPLATFORMVALUES_AWS_ECS = 'aws_ecs';
var TMP_CLOUDPLATFORMVALUES_AWS_EKS = 'aws_eks';
var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = 'aws_lambda';
var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = 'aws_elastic_beanstalk';
var TMP_CLOUDPLATFORMVALUES_AZURE_VM = 'azure_vm';
var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = 'azure_container_instances';
var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = 'azure_aks';
var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = 'azure_functions';
var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = 'azure_app_service';
var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = 'gcp_compute_engine';
var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = 'gcp_cloud_run';
var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = 'gcp_kubernetes_engine';
var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = 'gcp_cloud_functions';
var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = 'gcp_app_engine';
var CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
var CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
var CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
var CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
var CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
var CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
var CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
var CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
var CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
var CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
var CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
var CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
var CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
var CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
var CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
var CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
var CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
var CloudPlatformValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
    TMP_CLOUDPLATFORMVALUES_AWS_EC2,
    TMP_CLOUDPLATFORMVALUES_AWS_ECS,
    TMP_CLOUDPLATFORMVALUES_AWS_EKS,
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
    TMP_CLOUDPLATFORMVALUES_AZURE_VM,
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for AwsEcsLaunchtypeValues enum definition
 *
 * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = 'ec2';
var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = 'fargate';
var AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
var AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
var AwsEcsLaunchtypeValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_AWSECSLAUNCHTYPEVALUES_EC2,
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for HostArchValues enum definition
 *
 * The CPU architecture the host system is running on.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_HOSTARCHVALUES_AMD64 = 'amd64';
var TMP_HOSTARCHVALUES_ARM32 = 'arm32';
var TMP_HOSTARCHVALUES_ARM64 = 'arm64';
var TMP_HOSTARCHVALUES_IA64 = 'ia64';
var TMP_HOSTARCHVALUES_PPC32 = 'ppc32';
var TMP_HOSTARCHVALUES_PPC64 = 'ppc64';
var TMP_HOSTARCHVALUES_X86 = 'x86';
var HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
var HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
var HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
var HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
var HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
var HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
var HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
var HostArchValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_HOSTARCHVALUES_AMD64,
    TMP_HOSTARCHVALUES_ARM32,
    TMP_HOSTARCHVALUES_ARM64,
    TMP_HOSTARCHVALUES_IA64,
    TMP_HOSTARCHVALUES_PPC32,
    TMP_HOSTARCHVALUES_PPC64,
    TMP_HOSTARCHVALUES_X86
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for OsTypeValues enum definition
 *
 * The operating system type.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_OSTYPEVALUES_WINDOWS = 'windows';
var TMP_OSTYPEVALUES_LINUX = 'linux';
var TMP_OSTYPEVALUES_DARWIN = 'darwin';
var TMP_OSTYPEVALUES_FREEBSD = 'freebsd';
var TMP_OSTYPEVALUES_NETBSD = 'netbsd';
var TMP_OSTYPEVALUES_OPENBSD = 'openbsd';
var TMP_OSTYPEVALUES_DRAGONFLYBSD = 'dragonflybsd';
var TMP_OSTYPEVALUES_HPUX = 'hpux';
var TMP_OSTYPEVALUES_AIX = 'aix';
var TMP_OSTYPEVALUES_SOLARIS = 'solaris';
var TMP_OSTYPEVALUES_Z_OS = 'z_os';
var OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
var OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
var OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
var OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
var OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
var OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
var OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
var OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
var OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
var OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
var OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
var OsTypeValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_OSTYPEVALUES_WINDOWS,
    TMP_OSTYPEVALUES_LINUX,
    TMP_OSTYPEVALUES_DARWIN,
    TMP_OSTYPEVALUES_FREEBSD,
    TMP_OSTYPEVALUES_NETBSD,
    TMP_OSTYPEVALUES_OPENBSD,
    TMP_OSTYPEVALUES_DRAGONFLYBSD,
    TMP_OSTYPEVALUES_HPUX,
    TMP_OSTYPEVALUES_AIX,
    TMP_OSTYPEVALUES_SOLARIS,
    TMP_OSTYPEVALUES_Z_OS
]);
/* ----------------------------------------------------------------------------------------------------------
 * Constant values for TelemetrySdkLanguageValues enum definition
 *
 * The language of the telemetry SDK.
 * ---------------------------------------------------------------------------------------------------------- */ // Temporary local constants to assign to the individual exports and the namespaced version
// Required to avoid the namespace exports using the unminifiable export names for some package types
var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = 'cpp';
var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = 'dotnet';
var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = 'erlang';
var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = 'go';
var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = 'java';
var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = 'nodejs';
var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = 'php';
var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = 'python';
var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = 'ruby';
var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = 'webjs';
var TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
var TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
var TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
var TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
var TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
var TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
var TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
var TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
var TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
var TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
var TelemetrySdkLanguageValues = /*#__PURE__*/ (0, _utils.createConstMap)([
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
]);

},{"../internal/utils":"hV8FE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iely6":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ //----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/registry/stable/attributes.ts.j2
//----------------------------------------------------------------------------------------------------------
/**
 * Rate-limiting result, shows whether the lease was acquired or contains a rejection reason
 *
 * @example acquired
 * @example request_canceled
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ATTR_ASPNETCORE_RATE_LIMITING_RESULT", ()=>ATTR_ASPNETCORE_RATE_LIMITING_RESULT);
parcelHelpers.export(exports, "ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED", ()=>ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED);
parcelHelpers.export(exports, "ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER", ()=>ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER);
parcelHelpers.export(exports, "ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER", ()=>ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER);
parcelHelpers.export(exports, "ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED", ()=>ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED);
parcelHelpers.export(exports, "ATTR_TELEMETRY_SDK_LANGUAGE", ()=>ATTR_TELEMETRY_SDK_LANGUAGE);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_CPP", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_CPP);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_GO", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_GO);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_JAVA", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_JAVA);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_PHP", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_PHP);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_RUBY", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_RUBY);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_RUST", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_RUST);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT);
parcelHelpers.export(exports, "TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS", ()=>TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS);
parcelHelpers.export(exports, "ATTR_TELEMETRY_SDK_NAME", ()=>ATTR_TELEMETRY_SDK_NAME);
parcelHelpers.export(exports, "ATTR_TELEMETRY_SDK_VERSION", ()=>ATTR_TELEMETRY_SDK_VERSION);
parcelHelpers.export(exports, "ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE", ()=>ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE);
parcelHelpers.export(exports, "ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT", ()=>ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT);
parcelHelpers.export(exports, "ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED", ()=>ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED);
parcelHelpers.export(exports, "ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED", ()=>ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED);
parcelHelpers.export(exports, "ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED", ()=>ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED);
parcelHelpers.export(exports, "ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED", ()=>ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED);
parcelHelpers.export(exports, "ATTR_ASPNETCORE_RATE_LIMITING_POLICY", ()=>ATTR_ASPNETCORE_RATE_LIMITING_POLICY);
parcelHelpers.export(exports, "ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED", ()=>ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED);
parcelHelpers.export(exports, "ATTR_ASPNETCORE_ROUTING_IS_FALLBACK", ()=>ATTR_ASPNETCORE_ROUTING_IS_FALLBACK);
parcelHelpers.export(exports, "ATTR_ASPNETCORE_ROUTING_MATCH_STATUS", ()=>ATTR_ASPNETCORE_ROUTING_MATCH_STATUS);
parcelHelpers.export(exports, "ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE", ()=>ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE);
parcelHelpers.export(exports, "ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS", ()=>ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS);
parcelHelpers.export(exports, "ATTR_CLIENT_ADDRESS", ()=>ATTR_CLIENT_ADDRESS);
parcelHelpers.export(exports, "ATTR_CLIENT_PORT", ()=>ATTR_CLIENT_PORT);
parcelHelpers.export(exports, "ATTR_ERROR_TYPE", ()=>ATTR_ERROR_TYPE);
parcelHelpers.export(exports, "ERROR_TYPE_VALUE_OTHER", ()=>ERROR_TYPE_VALUE_OTHER);
parcelHelpers.export(exports, "ATTR_EXCEPTION_ESCAPED", ()=>ATTR_EXCEPTION_ESCAPED);
parcelHelpers.export(exports, "ATTR_EXCEPTION_MESSAGE", ()=>ATTR_EXCEPTION_MESSAGE);
parcelHelpers.export(exports, "ATTR_EXCEPTION_STACKTRACE", ()=>ATTR_EXCEPTION_STACKTRACE);
parcelHelpers.export(exports, "ATTR_EXCEPTION_TYPE", ()=>ATTR_EXCEPTION_TYPE);
parcelHelpers.export(exports, "ATTR_HTTP_REQUEST_HEADER", ()=>ATTR_HTTP_REQUEST_HEADER);
parcelHelpers.export(exports, "ATTR_HTTP_REQUEST_METHOD", ()=>ATTR_HTTP_REQUEST_METHOD);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_OTHER", ()=>HTTP_REQUEST_METHOD_VALUE_OTHER);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_CONNECT", ()=>HTTP_REQUEST_METHOD_VALUE_CONNECT);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_DELETE", ()=>HTTP_REQUEST_METHOD_VALUE_DELETE);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_GET", ()=>HTTP_REQUEST_METHOD_VALUE_GET);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_HEAD", ()=>HTTP_REQUEST_METHOD_VALUE_HEAD);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_OPTIONS", ()=>HTTP_REQUEST_METHOD_VALUE_OPTIONS);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_PATCH", ()=>HTTP_REQUEST_METHOD_VALUE_PATCH);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_POST", ()=>HTTP_REQUEST_METHOD_VALUE_POST);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_PUT", ()=>HTTP_REQUEST_METHOD_VALUE_PUT);
parcelHelpers.export(exports, "HTTP_REQUEST_METHOD_VALUE_TRACE", ()=>HTTP_REQUEST_METHOD_VALUE_TRACE);
parcelHelpers.export(exports, "ATTR_HTTP_REQUEST_METHOD_ORIGINAL", ()=>ATTR_HTTP_REQUEST_METHOD_ORIGINAL);
parcelHelpers.export(exports, "ATTR_HTTP_REQUEST_RESEND_COUNT", ()=>ATTR_HTTP_REQUEST_RESEND_COUNT);
parcelHelpers.export(exports, "ATTR_HTTP_RESPONSE_HEADER", ()=>ATTR_HTTP_RESPONSE_HEADER);
parcelHelpers.export(exports, "ATTR_HTTP_RESPONSE_STATUS_CODE", ()=>ATTR_HTTP_RESPONSE_STATUS_CODE);
parcelHelpers.export(exports, "ATTR_HTTP_ROUTE", ()=>ATTR_HTTP_ROUTE);
parcelHelpers.export(exports, "ATTR_JVM_GC_ACTION", ()=>ATTR_JVM_GC_ACTION);
parcelHelpers.export(exports, "ATTR_JVM_GC_NAME", ()=>ATTR_JVM_GC_NAME);
parcelHelpers.export(exports, "ATTR_JVM_MEMORY_POOL_NAME", ()=>ATTR_JVM_MEMORY_POOL_NAME);
parcelHelpers.export(exports, "ATTR_JVM_MEMORY_TYPE", ()=>ATTR_JVM_MEMORY_TYPE);
parcelHelpers.export(exports, "JVM_MEMORY_TYPE_VALUE_HEAP", ()=>JVM_MEMORY_TYPE_VALUE_HEAP);
parcelHelpers.export(exports, "JVM_MEMORY_TYPE_VALUE_NON_HEAP", ()=>JVM_MEMORY_TYPE_VALUE_NON_HEAP);
parcelHelpers.export(exports, "ATTR_JVM_THREAD_DAEMON", ()=>ATTR_JVM_THREAD_DAEMON);
parcelHelpers.export(exports, "ATTR_JVM_THREAD_STATE", ()=>ATTR_JVM_THREAD_STATE);
parcelHelpers.export(exports, "JVM_THREAD_STATE_VALUE_BLOCKED", ()=>JVM_THREAD_STATE_VALUE_BLOCKED);
parcelHelpers.export(exports, "JVM_THREAD_STATE_VALUE_NEW", ()=>JVM_THREAD_STATE_VALUE_NEW);
parcelHelpers.export(exports, "JVM_THREAD_STATE_VALUE_RUNNABLE", ()=>JVM_THREAD_STATE_VALUE_RUNNABLE);
parcelHelpers.export(exports, "JVM_THREAD_STATE_VALUE_TERMINATED", ()=>JVM_THREAD_STATE_VALUE_TERMINATED);
parcelHelpers.export(exports, "JVM_THREAD_STATE_VALUE_TIMED_WAITING", ()=>JVM_THREAD_STATE_VALUE_TIMED_WAITING);
parcelHelpers.export(exports, "JVM_THREAD_STATE_VALUE_WAITING", ()=>JVM_THREAD_STATE_VALUE_WAITING);
parcelHelpers.export(exports, "ATTR_NETWORK_LOCAL_ADDRESS", ()=>ATTR_NETWORK_LOCAL_ADDRESS);
parcelHelpers.export(exports, "ATTR_NETWORK_LOCAL_PORT", ()=>ATTR_NETWORK_LOCAL_PORT);
parcelHelpers.export(exports, "ATTR_NETWORK_PEER_ADDRESS", ()=>ATTR_NETWORK_PEER_ADDRESS);
parcelHelpers.export(exports, "ATTR_NETWORK_PEER_PORT", ()=>ATTR_NETWORK_PEER_PORT);
parcelHelpers.export(exports, "ATTR_NETWORK_PROTOCOL_NAME", ()=>ATTR_NETWORK_PROTOCOL_NAME);
parcelHelpers.export(exports, "ATTR_NETWORK_PROTOCOL_VERSION", ()=>ATTR_NETWORK_PROTOCOL_VERSION);
parcelHelpers.export(exports, "ATTR_NETWORK_TRANSPORT", ()=>ATTR_NETWORK_TRANSPORT);
parcelHelpers.export(exports, "NETWORK_TRANSPORT_VALUE_PIPE", ()=>NETWORK_TRANSPORT_VALUE_PIPE);
parcelHelpers.export(exports, "NETWORK_TRANSPORT_VALUE_QUIC", ()=>NETWORK_TRANSPORT_VALUE_QUIC);
parcelHelpers.export(exports, "NETWORK_TRANSPORT_VALUE_TCP", ()=>NETWORK_TRANSPORT_VALUE_TCP);
parcelHelpers.export(exports, "NETWORK_TRANSPORT_VALUE_UDP", ()=>NETWORK_TRANSPORT_VALUE_UDP);
parcelHelpers.export(exports, "NETWORK_TRANSPORT_VALUE_UNIX", ()=>NETWORK_TRANSPORT_VALUE_UNIX);
parcelHelpers.export(exports, "ATTR_NETWORK_TYPE", ()=>ATTR_NETWORK_TYPE);
parcelHelpers.export(exports, "NETWORK_TYPE_VALUE_IPV4", ()=>NETWORK_TYPE_VALUE_IPV4);
parcelHelpers.export(exports, "NETWORK_TYPE_VALUE_IPV6", ()=>NETWORK_TYPE_VALUE_IPV6);
parcelHelpers.export(exports, "ATTR_OTEL_SCOPE_NAME", ()=>ATTR_OTEL_SCOPE_NAME);
parcelHelpers.export(exports, "ATTR_OTEL_SCOPE_VERSION", ()=>ATTR_OTEL_SCOPE_VERSION);
parcelHelpers.export(exports, "ATTR_OTEL_STATUS_CODE", ()=>ATTR_OTEL_STATUS_CODE);
parcelHelpers.export(exports, "OTEL_STATUS_CODE_VALUE_ERROR", ()=>OTEL_STATUS_CODE_VALUE_ERROR);
parcelHelpers.export(exports, "OTEL_STATUS_CODE_VALUE_OK", ()=>OTEL_STATUS_CODE_VALUE_OK);
parcelHelpers.export(exports, "ATTR_OTEL_STATUS_DESCRIPTION", ()=>ATTR_OTEL_STATUS_DESCRIPTION);
parcelHelpers.export(exports, "ATTR_SERVER_ADDRESS", ()=>ATTR_SERVER_ADDRESS);
parcelHelpers.export(exports, "ATTR_SERVER_PORT", ()=>ATTR_SERVER_PORT);
parcelHelpers.export(exports, "ATTR_SERVICE_NAME", ()=>ATTR_SERVICE_NAME);
parcelHelpers.export(exports, "ATTR_SERVICE_VERSION", ()=>ATTR_SERVICE_VERSION);
parcelHelpers.export(exports, "ATTR_SIGNALR_CONNECTION_STATUS", ()=>ATTR_SIGNALR_CONNECTION_STATUS);
parcelHelpers.export(exports, "SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN", ()=>SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN);
parcelHelpers.export(exports, "SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE", ()=>SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE);
parcelHelpers.export(exports, "SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT", ()=>SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT);
parcelHelpers.export(exports, "ATTR_SIGNALR_TRANSPORT", ()=>ATTR_SIGNALR_TRANSPORT);
parcelHelpers.export(exports, "SIGNALR_TRANSPORT_VALUE_LONG_POLLING", ()=>SIGNALR_TRANSPORT_VALUE_LONG_POLLING);
parcelHelpers.export(exports, "SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS", ()=>SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS);
parcelHelpers.export(exports, "SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS", ()=>SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS);
parcelHelpers.export(exports, "ATTR_URL_FRAGMENT", ()=>ATTR_URL_FRAGMENT);
parcelHelpers.export(exports, "ATTR_URL_FULL", ()=>ATTR_URL_FULL);
parcelHelpers.export(exports, "ATTR_URL_PATH", ()=>ATTR_URL_PATH);
parcelHelpers.export(exports, "ATTR_URL_QUERY", ()=>ATTR_URL_QUERY);
parcelHelpers.export(exports, "ATTR_URL_SCHEME", ()=>ATTR_URL_SCHEME);
parcelHelpers.export(exports, "ATTR_USER_AGENT_ORIGINAL", ()=>ATTR_USER_AGENT_ORIGINAL);
var ATTR_ASPNETCORE_RATE_LIMITING_RESULT = 'aspnetcore.rate_limiting.result';
var ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
var ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
var ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
var ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
var ATTR_TELEMETRY_SDK_LANGUAGE = 'telemetry.sdk.language';
var TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
var TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
var TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
var TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
var TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
var TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
var TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
var TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
var TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
var TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
var TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
var TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
var ATTR_TELEMETRY_SDK_NAME = 'telemetry.sdk.name';
var ATTR_TELEMETRY_SDK_VERSION = 'telemetry.sdk.version';
var ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = 'aspnetcore.diagnostics.handler.type';
var ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = 'aspnetcore.diagnostics.exception.result';
var ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
var ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
var ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
var ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
var ATTR_ASPNETCORE_RATE_LIMITING_POLICY = 'aspnetcore.rate_limiting.policy';
var ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = 'aspnetcore.request.is_unhandled';
var ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = 'aspnetcore.routing.is_fallback';
var ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = 'aspnetcore.routing.match_status';
var ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
var ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
var ATTR_CLIENT_ADDRESS = 'client.address';
var ATTR_CLIENT_PORT = 'client.port';
var ATTR_ERROR_TYPE = 'error.type';
var ERROR_TYPE_VALUE_OTHER = "_OTHER";
var ATTR_EXCEPTION_ESCAPED = 'exception.escaped';
var ATTR_EXCEPTION_MESSAGE = 'exception.message';
var ATTR_EXCEPTION_STACKTRACE = 'exception.stacktrace';
var ATTR_EXCEPTION_TYPE = 'exception.type';
var ATTR_HTTP_REQUEST_HEADER = function(key) {
    return "http.request.header." + key;
};
var ATTR_HTTP_REQUEST_METHOD = 'http.request.method';
var HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
var HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
var HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
var HTTP_REQUEST_METHOD_VALUE_GET = "GET";
var HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
var HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
var HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
var HTTP_REQUEST_METHOD_VALUE_POST = "POST";
var HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
var HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
var ATTR_HTTP_REQUEST_METHOD_ORIGINAL = 'http.request.method_original';
var ATTR_HTTP_REQUEST_RESEND_COUNT = 'http.request.resend_count';
var ATTR_HTTP_RESPONSE_HEADER = function(key) {
    return "http.response.header." + key;
};
var ATTR_HTTP_RESPONSE_STATUS_CODE = 'http.response.status_code';
var ATTR_HTTP_ROUTE = 'http.route';
var ATTR_JVM_GC_ACTION = 'jvm.gc.action';
var ATTR_JVM_GC_NAME = 'jvm.gc.name';
var ATTR_JVM_MEMORY_POOL_NAME = 'jvm.memory.pool.name';
var ATTR_JVM_MEMORY_TYPE = 'jvm.memory.type';
var JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
var JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
var ATTR_JVM_THREAD_DAEMON = 'jvm.thread.daemon';
var ATTR_JVM_THREAD_STATE = 'jvm.thread.state';
var JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
var JVM_THREAD_STATE_VALUE_NEW = "new";
var JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
var JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
var JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
var JVM_THREAD_STATE_VALUE_WAITING = "waiting";
var ATTR_NETWORK_LOCAL_ADDRESS = 'network.local.address';
var ATTR_NETWORK_LOCAL_PORT = 'network.local.port';
var ATTR_NETWORK_PEER_ADDRESS = 'network.peer.address';
var ATTR_NETWORK_PEER_PORT = 'network.peer.port';
var ATTR_NETWORK_PROTOCOL_NAME = 'network.protocol.name';
var ATTR_NETWORK_PROTOCOL_VERSION = 'network.protocol.version';
var ATTR_NETWORK_TRANSPORT = 'network.transport';
var NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
var NETWORK_TRANSPORT_VALUE_QUIC = "quic";
var NETWORK_TRANSPORT_VALUE_TCP = "tcp";
var NETWORK_TRANSPORT_VALUE_UDP = "udp";
var NETWORK_TRANSPORT_VALUE_UNIX = "unix";
var ATTR_NETWORK_TYPE = 'network.type';
var NETWORK_TYPE_VALUE_IPV4 = "ipv4";
var NETWORK_TYPE_VALUE_IPV6 = "ipv6";
var ATTR_OTEL_SCOPE_NAME = 'otel.scope.name';
var ATTR_OTEL_SCOPE_VERSION = 'otel.scope.version';
var ATTR_OTEL_STATUS_CODE = 'otel.status_code';
var OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
var OTEL_STATUS_CODE_VALUE_OK = "OK";
var ATTR_OTEL_STATUS_DESCRIPTION = 'otel.status_description';
var ATTR_SERVER_ADDRESS = 'server.address';
var ATTR_SERVER_PORT = 'server.port';
var ATTR_SERVICE_NAME = 'service.name';
var ATTR_SERVICE_VERSION = 'service.version';
var ATTR_SIGNALR_CONNECTION_STATUS = 'signalr.connection.status';
var SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
var SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
var SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
var ATTR_SIGNALR_TRANSPORT = 'signalr.transport';
var SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
var SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
var SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
var ATTR_URL_FRAGMENT = 'url.fragment';
var ATTR_URL_FULL = 'url.full';
var ATTR_URL_PATH = 'url.path';
var ATTR_URL_QUERY = 'url.query';
var ATTR_URL_SCHEME = 'url.scheme';
var ATTR_USER_AGENT_ORIGINAL = 'user_agent.original';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"67SQ6":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ //----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/register/stable/metrics.ts.j2
//----------------------------------------------------------------------------------------------------------
/**
 * Number of exceptions caught by exception handling middleware.
 *
 * @note Meter name: `Microsoft.AspNetCore.Diagnostics`; Added in: ASP.NET Core 8.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS", ()=>METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS);
parcelHelpers.export(exports, "METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES", ()=>METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES);
parcelHelpers.export(exports, "METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS", ()=>METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS);
parcelHelpers.export(exports, "METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE", ()=>METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE);
parcelHelpers.export(exports, "METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION", ()=>METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION);
parcelHelpers.export(exports, "METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS", ()=>METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS);
parcelHelpers.export(exports, "METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS", ()=>METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS);
parcelHelpers.export(exports, "METRIC_HTTP_CLIENT_REQUEST_DURATION", ()=>METRIC_HTTP_CLIENT_REQUEST_DURATION);
parcelHelpers.export(exports, "METRIC_HTTP_SERVER_REQUEST_DURATION", ()=>METRIC_HTTP_SERVER_REQUEST_DURATION);
parcelHelpers.export(exports, "METRIC_JVM_CLASS_COUNT", ()=>METRIC_JVM_CLASS_COUNT);
parcelHelpers.export(exports, "METRIC_JVM_CLASS_LOADED", ()=>METRIC_JVM_CLASS_LOADED);
parcelHelpers.export(exports, "METRIC_JVM_CLASS_UNLOADED", ()=>METRIC_JVM_CLASS_UNLOADED);
parcelHelpers.export(exports, "METRIC_JVM_CPU_COUNT", ()=>METRIC_JVM_CPU_COUNT);
parcelHelpers.export(exports, "METRIC_JVM_CPU_RECENT_UTILIZATION", ()=>METRIC_JVM_CPU_RECENT_UTILIZATION);
parcelHelpers.export(exports, "METRIC_JVM_CPU_TIME", ()=>METRIC_JVM_CPU_TIME);
parcelHelpers.export(exports, "METRIC_JVM_GC_DURATION", ()=>METRIC_JVM_GC_DURATION);
parcelHelpers.export(exports, "METRIC_JVM_MEMORY_COMMITTED", ()=>METRIC_JVM_MEMORY_COMMITTED);
parcelHelpers.export(exports, "METRIC_JVM_MEMORY_LIMIT", ()=>METRIC_JVM_MEMORY_LIMIT);
parcelHelpers.export(exports, "METRIC_JVM_MEMORY_USED", ()=>METRIC_JVM_MEMORY_USED);
parcelHelpers.export(exports, "METRIC_JVM_MEMORY_USED_AFTER_LAST_GC", ()=>METRIC_JVM_MEMORY_USED_AFTER_LAST_GC);
parcelHelpers.export(exports, "METRIC_JVM_THREAD_COUNT", ()=>METRIC_JVM_THREAD_COUNT);
parcelHelpers.export(exports, "METRIC_KESTREL_ACTIVE_CONNECTIONS", ()=>METRIC_KESTREL_ACTIVE_CONNECTIONS);
parcelHelpers.export(exports, "METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES", ()=>METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES);
parcelHelpers.export(exports, "METRIC_KESTREL_CONNECTION_DURATION", ()=>METRIC_KESTREL_CONNECTION_DURATION);
parcelHelpers.export(exports, "METRIC_KESTREL_QUEUED_CONNECTIONS", ()=>METRIC_KESTREL_QUEUED_CONNECTIONS);
parcelHelpers.export(exports, "METRIC_KESTREL_QUEUED_REQUESTS", ()=>METRIC_KESTREL_QUEUED_REQUESTS);
parcelHelpers.export(exports, "METRIC_KESTREL_REJECTED_CONNECTIONS", ()=>METRIC_KESTREL_REJECTED_CONNECTIONS);
parcelHelpers.export(exports, "METRIC_KESTREL_TLS_HANDSHAKE_DURATION", ()=>METRIC_KESTREL_TLS_HANDSHAKE_DURATION);
parcelHelpers.export(exports, "METRIC_KESTREL_UPGRADED_CONNECTIONS", ()=>METRIC_KESTREL_UPGRADED_CONNECTIONS);
parcelHelpers.export(exports, "METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS", ()=>METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS);
parcelHelpers.export(exports, "METRIC_SIGNALR_SERVER_CONNECTION_DURATION", ()=>METRIC_SIGNALR_SERVER_CONNECTION_DURATION);
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = 'aspnetcore.diagnostics.exceptions';
var METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = 'aspnetcore.rate_limiting.active_request_leases';
var METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = 'aspnetcore.rate_limiting.queued_requests';
var METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = 'aspnetcore.rate_limiting.request.time_in_queue';
var METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = 'aspnetcore.rate_limiting.request_lease.duration';
var METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = 'aspnetcore.rate_limiting.requests';
var METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = 'aspnetcore.routing.match_attempts';
var METRIC_HTTP_CLIENT_REQUEST_DURATION = 'http.client.request.duration';
var METRIC_HTTP_SERVER_REQUEST_DURATION = 'http.server.request.duration';
var METRIC_JVM_CLASS_COUNT = 'jvm.class.count';
var METRIC_JVM_CLASS_LOADED = 'jvm.class.loaded';
var METRIC_JVM_CLASS_UNLOADED = 'jvm.class.unloaded';
var METRIC_JVM_CPU_COUNT = 'jvm.cpu.count';
var METRIC_JVM_CPU_RECENT_UTILIZATION = 'jvm.cpu.recent_utilization';
var METRIC_JVM_CPU_TIME = 'jvm.cpu.time';
var METRIC_JVM_GC_DURATION = 'jvm.gc.duration';
var METRIC_JVM_MEMORY_COMMITTED = 'jvm.memory.committed';
var METRIC_JVM_MEMORY_LIMIT = 'jvm.memory.limit';
var METRIC_JVM_MEMORY_USED = 'jvm.memory.used';
var METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = 'jvm.memory.used_after_last_gc';
var METRIC_JVM_THREAD_COUNT = 'jvm.thread.count';
var METRIC_KESTREL_ACTIVE_CONNECTIONS = 'kestrel.active_connections';
var METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = 'kestrel.active_tls_handshakes';
var METRIC_KESTREL_CONNECTION_DURATION = 'kestrel.connection.duration';
var METRIC_KESTREL_QUEUED_CONNECTIONS = 'kestrel.queued_connections';
var METRIC_KESTREL_QUEUED_REQUESTS = 'kestrel.queued_requests';
var METRIC_KESTREL_REJECTED_CONNECTIONS = 'kestrel.rejected_connections';
var METRIC_KESTREL_TLS_HANDSHAKE_DURATION = 'kestrel.tls_handshake.duration';
var METRIC_KESTREL_UPGRADED_CONNECTIONS = 'kestrel.upgraded_connections';
var METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = 'signalr.server.active_connections';
var METRIC_SIGNALR_SERVER_CONNECTION_DURATION = 'signalr.server.connection.duration';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bJW6":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unrefTimer", ()=>unrefTimer);
function unrefTimer(_timer) {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7QfVE":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExportResultCode", ()=>ExportResultCode);
var ExportResultCode;
(function(ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4CGBJ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CompositePropagator", ()=>CompositePropagator);
var _api = require("@opentelemetry/api");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/** Combines multiple propagators into a single propagator. */ var CompositePropagator = /** @class */ function() {
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */ function CompositePropagator(config) {
        if (config === void 0) config = {};
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators// older propagators may not have fields function, null check to be sure
        .map(function(p) {
            return typeof p.fields === 'function' ? p.fields() : [];
        }).reduce(function(x, y) {
            return x.concat(y);
        }, [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */ CompositePropagator.prototype.inject = function(context, carrier, setter) {
        var e_1, _a;
        try {
            for(var _b = __values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()){
                var propagator = _c.value;
                try {
                    propagator.inject(context, carrier, setter);
                } catch (err) {
                    (0, _api.diag).warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
                }
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    };
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */ CompositePropagator.prototype.extract = function(context, carrier, getter) {
        return this._propagators.reduce(function(ctx, propagator) {
            try {
                return propagator.extract(ctx, carrier, getter);
            } catch (err) {
                (0, _api.diag).warn("Failed to extract with " + propagator.constructor.name + ". Err: " + err.message);
            }
            return ctx;
        }, context);
    };
    CompositePropagator.prototype.fields = function() {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    };
    return CompositePropagator;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jB4ew":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TRACE_PARENT_HEADER", ()=>TRACE_PARENT_HEADER);
parcelHelpers.export(exports, "TRACE_STATE_HEADER", ()=>TRACE_STATE_HEADER);
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */ parcelHelpers.export(exports, "parseTraceParent", ()=>parseTraceParent);
parcelHelpers.export(exports, "W3CTraceContextPropagator", ()=>W3CTraceContextPropagator);
var _api = require("@opentelemetry/api");
var _suppressTracing = require("./suppress-tracing");
var _traceState = require("./TraceState");
var TRACE_PARENT_HEADER = 'traceparent';
var TRACE_STATE_HEADER = 'tracestate';
var VERSION = '00';
var VERSION_PART = '(?!ff)[\\da-f]{2}';
var TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var FLAGS_PART = '[\\da-f]{2}';
var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
function parseTraceParent(traceParent) {
    var match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match) return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5]) return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */ var W3CTraceContextPropagator = /** @class */ function() {
    function W3CTraceContextPropagator() {}
    W3CTraceContextPropagator.prototype.inject = function(context, carrier, setter) {
        var spanContext = (0, _api.trace).getSpanContext(context);
        if (!spanContext || (0, _suppressTracing.isTracingSuppressed)(context) || !(0, _api.isSpanContextValid)(spanContext)) return;
        var traceParent = VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || (0, _api.TraceFlags).NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
    };
    W3CTraceContextPropagator.prototype.extract = function(context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader) return context;
        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== 'string') return context;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext) return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(',') : traceStateHeader;
            spanContext.traceState = new (0, _traceState.TraceState)(typeof state === 'string' ? state : undefined);
        }
        return (0, _api.trace).setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function() {
        return [
            TRACE_PARENT_HEADER,
            TRACE_STATE_HEADER
        ];
    };
    return W3CTraceContextPropagator;
}();

},{"@opentelemetry/api":"6AC4z","./suppress-tracing":"1rhvC","./TraceState":"6OqHS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6OqHS":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceState", ()=>TraceState);
var _validators = require("../internal/validators");
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ',';
var LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */ var TraceState = /** @class */ function() {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState) this._parse(rawTraceState);
    }
    TraceState.prototype.set = function(key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) traceState._internalState.delete(key);
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function(key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
        .reduce(function(agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if ((0, _validators.validateKey)(key) && (0, _validators.validateValue)(value)) agg.set(key, value);
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain
        .slice(0, MAX_TRACE_STATE_ITEMS));
    };
    TraceState.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function() {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}();

},{"../internal/validators":"l944I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l944I":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */ parcelHelpers.export(exports, "validateKey", ()=>validateKey);
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */ parcelHelpers.export(exports, "validateValue", ()=>validateValue);
var VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9NR3d":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RPCType", ()=>RPCType);
parcelHelpers.export(exports, "setRPCMetadata", ()=>setRPCMetadata);
parcelHelpers.export(exports, "deleteRPCMetadata", ()=>deleteRPCMetadata);
parcelHelpers.export(exports, "getRPCMetadata", ()=>getRPCMetadata);
var _api = require("@opentelemetry/api");
var RPC_METADATA_KEY = (0, _api.createContextKey)('OpenTelemetry SDK Context Key RPC_METADATA');
var RPCType;
(function(RPCType) {
    RPCType["HTTP"] = "http";
})(RPCType || (RPCType = {}));
function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
}
function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
}
function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9TtvJ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>AlwaysOffSampler);
var _api = require("@opentelemetry/api");
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples no traces.
 */ var AlwaysOffSampler = /** @class */ function() {
    function AlwaysOffSampler() {}
    AlwaysOffSampler.prototype.shouldSample = function() {
        return {
            decision: (0, _api.SamplingDecision).NOT_RECORD
        };
    };
    AlwaysOffSampler.prototype.toString = function() {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ecqzX":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>AlwaysOnSampler);
var _api = require("@opentelemetry/api");
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples all traces.
 */ var AlwaysOnSampler = /** @class */ function() {
    function AlwaysOnSampler() {}
    AlwaysOnSampler.prototype.shouldSample = function() {
        return {
            decision: (0, _api.SamplingDecision).RECORD_AND_SAMPLED
        };
    };
    AlwaysOnSampler.prototype.toString = function() {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hPtIf":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ParentBasedSampler", ()=>ParentBasedSampler);
var _api = require("@opentelemetry/api");
var _globalErrorHandler = require("../../common/global-error-handler");
var _alwaysOffSampler = require("./AlwaysOffSampler");
var _alwaysOnSampler = require("./AlwaysOnSampler");
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */ var ParentBasedSampler = /** @class */ function() {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            (0, _globalErrorHandler.globalErrorHandler)(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new (0, _alwaysOnSampler.AlwaysOnSampler)();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new (0, _alwaysOnSampler.AlwaysOnSampler)();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new (0, _alwaysOffSampler.AlwaysOffSampler)();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new (0, _alwaysOnSampler.AlwaysOnSampler)();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new (0, _alwaysOffSampler.AlwaysOffSampler)();
    }
    ParentBasedSampler.prototype.shouldSample = function(context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = (0, _api.trace).getSpanContext(context);
        if (!parentContext || !(0, _api.isSpanContextValid)(parentContext)) return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & (0, _api.TraceFlags).SAMPLED) return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & (0, _api.TraceFlags).SAMPLED) return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function() {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}();

},{"@opentelemetry/api":"6AC4z","../../common/global-error-handler":"b1oZ8","./AlwaysOffSampler":"9TtvJ","./AlwaysOnSampler":"ecqzX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ahYGO":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>TraceIdRatioBasedSampler);
var _api = require("@opentelemetry/api");
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples a given fraction of traces based of trace id deterministically.
 */ var TraceIdRatioBasedSampler = /** @class */ function() {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) _ratio = 0;
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function(context, traceId) {
        return {
            decision: (0, _api.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? (0, _api.SamplingDecision).RECORD_AND_SAMPLED : (0, _api.SamplingDecision).NOT_RECORD
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function() {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function(ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio)) return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function(traceId) {
        var accumulation = 0;
        for(var i = 0; i < traceId.length / 8; i++){
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asyWF":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* eslint-disable @typescript-eslint/no-explicit-any */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */ parcelHelpers.export(exports, "merge", ()=>merge);
var _lodashMerge = require("./lodash.merge");
var MAX_LEVEL = 20;
function merge() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var result = args.shift();
    var objects = new WeakMap();
    while(args.length > 0)result = mergeTwoObjects(result, args.shift(), 0, objects);
    return result;
}
function takeValue(value) {
    if (isArray(value)) return value.slice();
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */ function mergeTwoObjects(one, two, level, objects) {
    if (level === void 0) level = 0;
    var result;
    if (level > MAX_LEVEL) return undefined;
    level++;
    if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) result = takeValue(two);
    else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) for(var i = 0, j = two.length; i < j; i++)result.push(takeValue(two[i]));
        else if (isObject(two)) {
            var keys = Object.keys(two);
            for(var i = 0, j = keys.length; i < j; i++){
                var key = keys[i];
                result[key] = takeValue(two[key]);
            }
        }
    } else if (isObject(one)) {
        if (isObject(two)) {
            if (!shouldMerge(one, two)) return two;
            result = Object.assign({}, one);
            var keys = Object.keys(two);
            for(var i = 0, j = keys.length; i < j; i++){
                var key = keys[i];
                var twoValue = two[key];
                if (isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') delete result[key];
                    else // result[key] = takeValue(twoValue);
                    result[key] = twoValue;
                } else {
                    var obj1 = result[key];
                    var obj2 = twoValue;
                    if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) delete result[key];
                    else {
                        if (isObject(obj1) && isObject(obj2)) {
                            var arr1 = objects.get(obj1) || [];
                            var arr2 = objects.get(obj2) || [];
                            arr1.push({
                                obj: one,
                                key: key
                            });
                            arr2.push({
                                obj: two,
                                key: key
                            });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        } else result = two;
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */ function wasObjectReferenced(obj, key, objects) {
    var arr = objects.get(obj[key]) || [];
    for(var i = 0, j = arr.length; i < j; i++){
        var info = arr[i];
        if (info.key === key && info.obj === obj) return true;
    }
    return false;
}
function isArray(value) {
    return Array.isArray(value);
}
function isFunction(value) {
    return typeof value === 'function';
}
function isObject(value) {
    return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === 'object';
}
function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value instanceof Date || value instanceof RegExp || value === null;
}
function shouldMerge(one, two) {
    if (!(0, _lodashMerge.isPlainObject)(one) || !(0, _lodashMerge.isPlainObject)(two)) return false;
    return true;
}

},{"./lodash.merge":"fSdpF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fSdpF":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */ parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
var objectTag = '[object Object]';
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
var objectCtorString = funcToString.call(Object);
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var nativeObjectToString = objectProto.toString;
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) return false;
    var proto = getPrototype(value);
    if (proto === null) return true;
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) return value === undefined ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    var unmasked = false;
    try {
        value[symToStringTag] = undefined;
        unmasked = true;
    } catch (e) {
    // silence
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) value[symToStringTag] = tag;
        else delete value[symToStringTag];
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iWKYy":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimeoutError", ()=>TimeoutError);
/**
 * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise
 * rejects, and resolves if the specified promise resolves.
 *
 * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.
 *
 * @param promise promise to use with timeout.
 * @param timeout the timeout in milliseconds until the returned promise is rejected.
 */ parcelHelpers.export(exports, "callWithTimeout", ()=>callWithTimeout);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Error that is thrown on timeouts.
 */ var TimeoutError = /** @class */ function(_super) {
    __extends(TimeoutError, _super);
    function TimeoutError(message) {
        var _this = _super.call(this, message) || this;
        // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:
        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error);
function callWithTimeout(promise, timeout) {
    var timeoutHandle;
    var timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
            reject(new TimeoutError('Operation timed out.'));
        }, timeout);
    });
    return Promise.race([
        promise,
        timeoutPromise
    ]).then(function(result) {
        clearTimeout(timeoutHandle);
        return result;
    }, function(reason) {
        clearTimeout(timeoutHandle);
        throw reason;
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6x22z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ parcelHelpers.export(exports, "urlMatches", ()=>urlMatches);
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */ parcelHelpers.export(exports, "isUrlIgnored", ()=>isUrlIgnored);
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') return url === urlToMatch;
    else return !!url.match(urlToMatch);
}
function isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) return false;
    try {
        for(var ignoredUrls_1 = __values(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()){
            var ignoreUrl = ignoredUrls_1_1.value;
            if (urlMatches(url, ignoreUrl)) return true;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lzw4N":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Checks if certain function has been already wrapped
 * @param func
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isWrapped", ()=>isWrapped);
function isWrapped(func) {
    return typeof func === 'function' && typeof func.__original === 'function' && typeof func.__unwrap === 'function' && func.__wrapped === true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"96fEi":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BindOnceFuture", ()=>BindOnceFuture);
var _promise = require("./promise");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */ var BindOnceFuture = /** @class */ function() {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new (0, _promise.Deferred)();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function() {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function() {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function() {
        var _a;
        var _this = this;
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, __spreadArray([
                    this._that
                ], __read(args), false))).then(function(val) {
                    return _this._deferred.resolve(val);
                }, function(err) {
                    return _this._deferred.reject(err);
                });
            } catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}();

},{"./promise":"5xfCv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5xfCv":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Deferred", ()=>Deferred);
var Deferred = /** @class */ function() {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function(resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function() {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function(val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function(err) {
        this._reject(err);
    };
    return Deferred;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1BxU4":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @internal
 * Shared functionality used by Exporters while exporting data, including suppression of Traces.
 */ parcelHelpers.export(exports, "_export", ()=>_export);
var _api = require("@opentelemetry/api");
var _suppressTracing = require("../trace/suppress-tracing");
function _export(exporter, arg) {
    return new Promise(function(resolve) {
        // prevent downstream exporter calls from generating spans
        (0, _api.context).with((0, _suppressTracing.suppressTracing)((0, _api.context).active()), function() {
            exporter.export(arg, function(result) {
                resolve(result);
            });
        });
    });
}

},{"@opentelemetry/api":"6AC4z","../trace/suppress-tracing":"1rhvC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bkokT":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Span", ()=>Span);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var _semanticConventions = require("@opentelemetry/semantic-conventions");
var _enums = require("./enums");
var __assign = undefined && undefined.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * This class represents a span.
 */ var Span = /** @class */ function() {
    /**
     * Constructs a new Span instance.
     *
     * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.
     * */ function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock, attributes) {
        if (links === void 0) links = [];
        this.attributes = {};
        this.links = [];
        this.events = [];
        this._droppedAttributesCount = 0;
        this._droppedEventsCount = 0;
        this._droppedLinksCount = 0;
        this.status = {
            code: (0, _api.SpanStatusCode).UNSET
        };
        this.endTime = [
            0,
            0
        ];
        this._ended = false;
        this._duration = [
            -1,
            -1
        ];
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        var now = Date.now();
        this._performanceStartTime = (0, _core.otperformance).now();
        this._performanceOffset = now - (this._performanceStartTime + (0, _core.getTimeOrigin)());
        this._startTimeProvided = startTime != null;
        this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
        if (attributes != null) this.setAttributes(attributes);
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context);
    }
    Span.prototype.spanContext = function() {
        return this._spanContext;
    };
    Span.prototype.setAttribute = function(key, value) {
        if (value == null || this._isSpanEnded()) return this;
        if (key.length === 0) {
            (0, _api.diag).warn("Invalid attribute key: " + key);
            return this;
        }
        if (!(0, _core.isAttributeValue)(value)) {
            (0, _api.diag).warn("Invalid attribute value set for key: " + key);
            return this;
        }
        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
            this._droppedAttributesCount++;
            return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
    };
    Span.prototype.setAttributes = function(attributes) {
        var e_1, _a;
        try {
            for(var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()){
                var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
                this.setAttribute(k, v);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return this;
    };
    /**
     *
     * @param name Span Name
     * @param [attributesOrStartTime] Span attributes or start time
     *     if type is {@type TimeInput} and 3rd param is undefined
     * @param [timeStamp] Specified time stamp for the event
     */ Span.prototype.addEvent = function(name, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded()) return this;
        if (this._spanLimits.eventCountLimit === 0) {
            (0, _api.diag).warn('No events allowed.');
            this._droppedEventsCount++;
            return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
            if (this._droppedEventsCount === 0) (0, _api.diag).debug('Dropping extra events.');
            this.events.shift();
            this._droppedEventsCount++;
        }
        if ((0, _core.isTimeInput)(attributesOrStartTime)) {
            if (!(0, _core.isTimeInput)(timeStamp)) timeStamp = attributesOrStartTime;
            attributesOrStartTime = undefined;
        }
        var attributes = (0, _core.sanitizeAttributes)(attributesOrStartTime);
        this.events.push({
            name: name,
            attributes: attributes,
            time: this._getTime(timeStamp),
            droppedAttributesCount: 0
        });
        return this;
    };
    Span.prototype.addLink = function(link) {
        this.links.push(link);
        return this;
    };
    Span.prototype.addLinks = function(links) {
        var _a;
        (_a = this.links).push.apply(_a, __spreadArray([], __read(links), false));
        return this;
    };
    Span.prototype.setStatus = function(status) {
        if (this._isSpanEnded()) return this;
        this.status = __assign({}, status);
        // When using try-catch, the caught "error" is of type `any`. When then assigning `any` to `status.message`,
        // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()
        // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or
        // undefined to avoid an incorrect type causing issues downstream.
        if (this.status.message != null && typeof status.message !== 'string') {
            (0, _api.diag).warn("Dropping invalid status.message of type '" + typeof status.message + "', expected 'string'");
            delete this.status.message;
        }
        return this;
    };
    Span.prototype.updateName = function(name) {
        if (this._isSpanEnded()) return this;
        this.name = name;
        return this;
    };
    Span.prototype.end = function(endTime) {
        if (this._isSpanEnded()) {
            (0, _api.diag).error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.");
            return;
        }
        this._ended = true;
        this.endTime = this._getTime(endTime);
        this._duration = (0, _core.hrTimeDuration)(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
            (0, _api.diag).warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);
            this.endTime = this.startTime.slice();
            this._duration = [
                0,
                0
            ];
        }
        if (this._droppedEventsCount > 0) (0, _api.diag).warn("Dropped " + this._droppedEventsCount + " events because eventCountLimit reached");
        this._spanProcessor.onEnd(this);
    };
    Span.prototype._getTime = function(inp) {
        if (typeof inp === 'number' && inp <= (0, _core.otperformance).now()) // must be a performance timestamp
        // apply correction and convert to hrtime
        return (0, _core.hrTime)(inp + this._performanceOffset);
        if (typeof inp === 'number') return (0, _core.millisToHrTime)(inp);
        if (inp instanceof Date) return (0, _core.millisToHrTime)(inp.getTime());
        if ((0, _core.isTimeInputHrTime)(inp)) return inp;
        if (this._startTimeProvided) // if user provided a time for the start manually
        // we can't use duration to calculate event/end times
        return (0, _core.millisToHrTime)(Date.now());
        var msDuration = (0, _core.otperformance).now() - this._performanceStartTime;
        return (0, _core.addHrTimes)(this.startTime, (0, _core.millisToHrTime)(msDuration));
    };
    Span.prototype.isRecording = function() {
        return this._ended === false;
    };
    Span.prototype.recordException = function(exception, time) {
        var attributes = {};
        if (typeof exception === 'string') attributes[0, _semanticConventions.SEMATTRS_EXCEPTION_MESSAGE] = exception;
        else if (exception) {
            if (exception.code) attributes[0, _semanticConventions.SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
            else if (exception.name) attributes[0, _semanticConventions.SEMATTRS_EXCEPTION_TYPE] = exception.name;
            if (exception.message) attributes[0, _semanticConventions.SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
            if (exception.stack) attributes[0, _semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
        }
        // these are minimum requirements from spec
        if (attributes[0, _semanticConventions.SEMATTRS_EXCEPTION_TYPE] || attributes[0, _semanticConventions.SEMATTRS_EXCEPTION_MESSAGE]) this.addEvent((0, _enums.ExceptionEventName), attributes, time);
        else (0, _api.diag).warn("Failed to record an exception " + exception);
    };
    Object.defineProperty(Span.prototype, "duration", {
        get: function() {
            return this._duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "ended", {
        get: function() {
            return this._ended;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "droppedAttributesCount", {
        get: function() {
            return this._droppedAttributesCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "droppedEventsCount", {
        get: function() {
            return this._droppedEventsCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "droppedLinksCount", {
        get: function() {
            return this._droppedLinksCount;
        },
        enumerable: false,
        configurable: true
    });
    Span.prototype._isSpanEnded = function() {
        if (this._ended) (0, _api.diag).warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
        return this._ended;
    };
    // Utility function to truncate given value within size
    // for value type of string, will truncate to given limit
    // for type of non-string, will return same value
    Span.prototype._truncateToLimitUtil = function(value, limit) {
        if (value.length <= limit) return value;
        return value.substring(0, limit);
    };
    /**
     * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
     * return string with truncated to {@code attributeValueLengthLimit} characters
     *
     * If the given attribute value is array of strings then
     * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
     *
     * Otherwise return same Attribute {@code value}
     *
     * @param value Attribute value
     * @returns truncated attribute value if required, otherwise same value
     */ Span.prototype._truncateToSize = function(value) {
        var _this = this;
        var limit = this._attributeValueLengthLimit;
        // Check limit
        if (limit <= 0) {
            // Negative values are invalid, so do not truncate
            (0, _api.diag).warn("Attribute value limit must be positive, got " + limit);
            return value;
        }
        // String
        if (typeof value === 'string') return this._truncateToLimitUtil(value, limit);
        // Array of strings
        if (Array.isArray(value)) return value.map(function(val) {
            return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;
        });
        // Other types, no need to apply value length limit
        return value;
    };
    return Span;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"1eVry","@opentelemetry/semantic-conventions":"lCgfj","./enums":"3kGnt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3kGnt":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Event name definitions
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExceptionEventName", ()=>ExceptionEventName);
var ExceptionEventName = 'exception';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7cAWa":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Function to merge Default configuration (as specified in './config') with
 * user provided configurations.
 */ parcelHelpers.export(exports, "mergeConfig", ()=>mergeConfig);
/**
 * When general limits are provided and model specific limits are not,
 * configures the model specific limits by using the values from the general ones.
 * @param userConfig User provided tracer configuration
 */ parcelHelpers.export(exports, "reconfigureLimits", ()=>reconfigureLimits);
var _config = require("./config");
var _core = require("@opentelemetry/core");
function mergeConfig(userConfig) {
    var perInstanceDefaults = {
        sampler: (0, _config.buildSamplerFromEnv)()
    };
    var DEFAULT_CONFIG = (0, _config.loadDefaultConfig)();
    var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
    target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
    target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
    return target;
}
function reconfigureLimits(userConfig) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var spanLimits = Object.assign({}, userConfig.spanLimits);
    var parsedEnvConfig = (0, _core.getEnvWithoutDefaults)();
    /**
     * Reassign span attribute count limit to use first non null value defined by user or use default value
     */ spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b = (_a = userConfig.spanLimits) === null || _a === void 0 ? void 0 : _a.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : (0, _core.DEFAULT_ATTRIBUTE_COUNT_LIMIT);
    /**
     * Reassign span attribute value length limit to use first non null value defined by user or use default value
     */ spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : (0, _core.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT);
    return Object.assign({}, userConfig, {
        spanLimits: spanLimits
    });
}

},{"./config":"keX9s","@opentelemetry/core":"1eVry","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"keX9s":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Load default configuration. For fields with primitive values, any user-provided
 * value will override the corresponding default value. For fields with
 * non-primitive values (like `spanLimits`), the user-provided value will be
 * used to extend the default value.
 */ // object needs to be wrapped in this function and called when needed otherwise
// envs are parsed before tests are ran - causes tests using these envs to fail
parcelHelpers.export(exports, "loadDefaultConfig", ()=>loadDefaultConfig);
/**
 * Based on environment, builds a sampler, complies with specification.
 * @param environment optional, by default uses getEnv(), but allows passing a value to reuse parsed environment
 */ parcelHelpers.export(exports, "buildSamplerFromEnv", ()=>buildSamplerFromEnv);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var _alwaysOffSampler = require("./sampler/AlwaysOffSampler");
var _alwaysOnSampler = require("./sampler/AlwaysOnSampler");
var _parentBasedSampler = require("./sampler/ParentBasedSampler");
var _traceIdRatioBasedSampler = require("./sampler/TraceIdRatioBasedSampler");
var env = (0, _core.getEnv)();
var FALLBACK_OTEL_TRACES_SAMPLER = (0, _core.TracesSamplerValues).AlwaysOn;
var DEFAULT_RATIO = 1;
function loadDefaultConfig() {
    var _env = (0, _core.getEnv)();
    return {
        sampler: buildSamplerFromEnv(env),
        forceFlushTimeoutMillis: 30000,
        generalLimits: {
            attributeValueLengthLimit: _env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            attributeCountLimit: _env.OTEL_ATTRIBUTE_COUNT_LIMIT
        },
        spanLimits: {
            attributeValueLengthLimit: _env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            attributeCountLimit: _env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
            linkCountLimit: _env.OTEL_SPAN_LINK_COUNT_LIMIT,
            eventCountLimit: _env.OTEL_SPAN_EVENT_COUNT_LIMIT,
            attributePerEventCountLimit: _env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
            attributePerLinkCountLimit: _env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
        },
        mergeResourceWithDefaults: true
    };
}
function buildSamplerFromEnv(environment) {
    if (environment === void 0) environment = (0, _core.getEnv)();
    switch(environment.OTEL_TRACES_SAMPLER){
        case (0, _core.TracesSamplerValues).AlwaysOn:
            return new (0, _alwaysOnSampler.AlwaysOnSampler)();
        case (0, _core.TracesSamplerValues).AlwaysOff:
            return new (0, _alwaysOffSampler.AlwaysOffSampler)();
        case (0, _core.TracesSamplerValues).ParentBasedAlwaysOn:
            return new (0, _parentBasedSampler.ParentBasedSampler)({
                root: new (0, _alwaysOnSampler.AlwaysOnSampler)()
            });
        case (0, _core.TracesSamplerValues).ParentBasedAlwaysOff:
            return new (0, _parentBasedSampler.ParentBasedSampler)({
                root: new (0, _alwaysOffSampler.AlwaysOffSampler)()
            });
        case (0, _core.TracesSamplerValues).TraceIdRatio:
            return new (0, _traceIdRatioBasedSampler.TraceIdRatioBasedSampler)(getSamplerProbabilityFromEnv(environment));
        case (0, _core.TracesSamplerValues).ParentBasedTraceIdRatio:
            return new (0, _parentBasedSampler.ParentBasedSampler)({
                root: new (0, _traceIdRatioBasedSampler.TraceIdRatioBasedSampler)(getSamplerProbabilityFromEnv(environment))
            });
        default:
            (0, _api.diag).error("OTEL_TRACES_SAMPLER value \"" + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + "\".");
            return new (0, _alwaysOnSampler.AlwaysOnSampler)();
    }
}
function getSamplerProbabilityFromEnv(environment) {
    if (environment.OTEL_TRACES_SAMPLER_ARG === undefined || environment.OTEL_TRACES_SAMPLER_ARG === '') {
        (0, _api.diag).error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
    if (isNaN(probability)) {
        (0, _api.diag).error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    if (probability < 0 || probability > 1) {
        (0, _api.diag).error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    return probability;
}

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"1eVry","./sampler/AlwaysOffSampler":"kq1rz","./sampler/AlwaysOnSampler":"2vmgJ","./sampler/ParentBasedSampler":"ev7Oh","./sampler/TraceIdRatioBasedSampler":"fXq8d","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kq1rz":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>AlwaysOffSampler);
var _sampler = require("../Sampler");
/** Sampler that samples no traces. */ var AlwaysOffSampler = /** @class */ function() {
    function AlwaysOffSampler() {}
    AlwaysOffSampler.prototype.shouldSample = function() {
        return {
            decision: (0, _sampler.SamplingDecision).NOT_RECORD
        };
    };
    AlwaysOffSampler.prototype.toString = function() {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}();

},{"../Sampler":"9KuXl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9KuXl":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SamplingDecision", ()=>SamplingDecision);
var SamplingDecision;
(function(SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */ SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */ SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */ SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2vmgJ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>AlwaysOnSampler);
var _sampler = require("../Sampler");
/** Sampler that samples all traces. */ var AlwaysOnSampler = /** @class */ function() {
    function AlwaysOnSampler() {}
    AlwaysOnSampler.prototype.shouldSample = function() {
        return {
            decision: (0, _sampler.SamplingDecision).RECORD_AND_SAMPLED
        };
    };
    AlwaysOnSampler.prototype.toString = function() {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}();

},{"../Sampler":"9KuXl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ev7Oh":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ParentBasedSampler", ()=>ParentBasedSampler);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var _alwaysOffSampler = require("./AlwaysOffSampler");
var _alwaysOnSampler = require("./AlwaysOnSampler");
/**
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */ var ParentBasedSampler = /** @class */ function() {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            (0, _core.globalErrorHandler)(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new (0, _alwaysOnSampler.AlwaysOnSampler)();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new (0, _alwaysOnSampler.AlwaysOnSampler)();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new (0, _alwaysOffSampler.AlwaysOffSampler)();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new (0, _alwaysOnSampler.AlwaysOnSampler)();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new (0, _alwaysOffSampler.AlwaysOffSampler)();
    }
    ParentBasedSampler.prototype.shouldSample = function(context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = (0, _api.trace).getSpanContext(context);
        if (!parentContext || !(0, _api.isSpanContextValid)(parentContext)) return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & (0, _api.TraceFlags).SAMPLED) return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & (0, _api.TraceFlags).SAMPLED) return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function() {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"1eVry","./AlwaysOffSampler":"kq1rz","./AlwaysOnSampler":"2vmgJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fXq8d":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>TraceIdRatioBasedSampler);
var _api = require("@opentelemetry/api");
var _sampler = require("../Sampler");
/** Sampler that samples a given fraction of traces based of trace id deterministically. */ var TraceIdRatioBasedSampler = /** @class */ function() {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) _ratio = 0;
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function(context, traceId) {
        return {
            decision: (0, _api.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? (0, _sampler.SamplingDecision).RECORD_AND_SAMPLED : (0, _sampler.SamplingDecision).NOT_RECORD
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function() {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function(ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio)) return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function(traceId) {
        var accumulation = 0;
        for(var i = 0; i < traceId.length / 8; i++){
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}();

},{"@opentelemetry/api":"6AC4z","../Sampler":"9KuXl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpW1w":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BatchSpanProcessor", ()=>(0, _batchSpanProcessor.BatchSpanProcessor));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _randomIdGenerator.RandomIdGenerator));
var _batchSpanProcessor = require("./export/BatchSpanProcessor");
var _randomIdGenerator = require("./RandomIdGenerator");

},{"./export/BatchSpanProcessor":"kSwzo","./RandomIdGenerator":"fdWa9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kSwzo":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BatchSpanProcessor", ()=>BatchSpanProcessor);
var _batchSpanProcessorBase = require("../../../export/BatchSpanProcessorBase");
var _core = require("@opentelemetry/core");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var BatchSpanProcessor = /** @class */ function(_super) {
    __extends(BatchSpanProcessor, _super);
    function BatchSpanProcessor(_exporter, config) {
        var _this = _super.call(this, _exporter, config) || this;
        _this.onInit(config);
        return _this;
    }
    BatchSpanProcessor.prototype.onInit = function(config) {
        var _this = this;
        if ((config === null || config === void 0 ? void 0 : config.disableAutoFlushOnDocumentHide) !== true && typeof document !== 'undefined') {
            this._visibilityChangeListener = function() {
                if (document.visibilityState === 'hidden') _this.forceFlush().catch(function(error) {
                    (0, _core.globalErrorHandler)(error);
                });
            };
            this._pageHideListener = function() {
                _this.forceFlush().catch(function(error) {
                    (0, _core.globalErrorHandler)(error);
                });
            };
            document.addEventListener('visibilitychange', this._visibilityChangeListener);
            // use 'pagehide' event as a fallback for Safari; see https://bugs.webkit.org/show_bug.cgi?id=116769
            document.addEventListener('pagehide', this._pageHideListener);
        }
    };
    BatchSpanProcessor.prototype.onShutdown = function() {
        if (typeof document !== 'undefined') {
            if (this._visibilityChangeListener) document.removeEventListener('visibilitychange', this._visibilityChangeListener);
            if (this._pageHideListener) document.removeEventListener('pagehide', this._pageHideListener);
        }
    };
    return BatchSpanProcessor;
}((0, _batchSpanProcessorBase.BatchSpanProcessorBase));

},{"../../../export/BatchSpanProcessorBase":"il3aW","@opentelemetry/core":"1eVry","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"il3aW":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BatchSpanProcessorBase", ()=>BatchSpanProcessorBase);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
/**
 * Implementation of the {@link SpanProcessor} that batches spans exported by
 * the SDK then pushes them to the exporter pipeline.
 */ var BatchSpanProcessorBase = /** @class */ function() {
    function BatchSpanProcessorBase(_exporter, config) {
        this._exporter = _exporter;
        this._isExporting = false;
        this._finishedSpans = [];
        this._droppedSpansCount = 0;
        var env = (0, _core.getEnv)();
        this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number' ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number' ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number' ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number' ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new (0, _core.BindOnceFuture)(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
            (0, _api.diag).warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');
            this._maxExportBatchSize = this._maxQueueSize;
        }
    }
    BatchSpanProcessorBase.prototype.forceFlush = function() {
        if (this._shutdownOnce.isCalled) return this._shutdownOnce.promise;
        return this._flushAll();
    };
    // does nothing.
    BatchSpanProcessorBase.prototype.onStart = function(_span, _parentContext) {};
    BatchSpanProcessorBase.prototype.onEnd = function(span) {
        if (this._shutdownOnce.isCalled) return;
        if ((span.spanContext().traceFlags & (0, _api.TraceFlags).SAMPLED) === 0) return;
        this._addToBuffer(span);
    };
    BatchSpanProcessorBase.prototype.shutdown = function() {
        return this._shutdownOnce.call();
    };
    BatchSpanProcessorBase.prototype._shutdown = function() {
        var _this = this;
        return Promise.resolve().then(function() {
            return _this.onShutdown();
        }).then(function() {
            return _this._flushAll();
        }).then(function() {
            return _this._exporter.shutdown();
        });
    };
    /** Add a span in the buffer. */ BatchSpanProcessorBase.prototype._addToBuffer = function(span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
            // limit reached, drop span
            if (this._droppedSpansCount === 0) (0, _api.diag).debug('maxQueueSize reached, dropping spans');
            this._droppedSpansCount++;
            return;
        }
        if (this._droppedSpansCount > 0) {
            // some spans were dropped, log once with count of spans dropped
            (0, _api.diag).warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached");
            this._droppedSpansCount = 0;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
    };
    /**
     * Send all spans to the exporter respecting the batch size limit
     * This function is used only on forceFlush or shutdown,
     * for all other cases _flush should be used
     * */ BatchSpanProcessorBase.prototype._flushAll = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var promises = [];
            // calculate number of batches
            var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
            for(var i = 0, j = count; i < j; i++)promises.push(_this._flushOneBatch());
            Promise.all(promises).then(function() {
                resolve();
            }).catch(reject);
        });
    };
    BatchSpanProcessorBase.prototype._flushOneBatch = function() {
        var _this = this;
        this._clearTimer();
        if (this._finishedSpans.length === 0) return Promise.resolve();
        return new Promise(function(resolve, reject) {
            var timer = setTimeout(function() {
                // don't wait anymore for export, this way the next batch can start
                reject(new Error('Timeout'));
            }, _this._exportTimeoutMillis);
            // prevent downstream exporter calls from generating spans
            (0, _api.context).with((0, _core.suppressTracing)((0, _api.context).active()), function() {
                // Reset the finished spans buffer here because the next invocations of the _flush method
                // could pass the same finished spans to the exporter if the buffer is cleared
                // outside the execution of this callback.
                var spans;
                if (_this._finishedSpans.length <= _this._maxExportBatchSize) {
                    spans = _this._finishedSpans;
                    _this._finishedSpans = [];
                } else spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);
                var doExport = function() {
                    return _this._exporter.export(spans, function(result) {
                        var _a;
                        clearTimeout(timer);
                        if (result.code === (0, _core.ExportResultCode).SUCCESS) resolve();
                        else reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));
                    });
                };
                var pendingResources = null;
                for(var i = 0, len = spans.length; i < len; i++){
                    var span = spans[i];
                    if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
                        pendingResources !== null && pendingResources !== void 0 ? pendingResources : pendingResources = [];
                        pendingResources.push(span.resource.waitForAsyncAttributes());
                    }
                }
                // Avoid scheduling a promise to make the behavior more predictable and easier to test
                if (pendingResources === null) doExport();
                else Promise.all(pendingResources).then(doExport, function(err) {
                    (0, _core.globalErrorHandler)(err);
                    reject(err);
                });
            });
        });
    };
    BatchSpanProcessorBase.prototype._maybeStartTimer = function() {
        var _this = this;
        if (this._isExporting) return;
        var flush = function() {
            _this._isExporting = true;
            _this._flushOneBatch().finally(function() {
                _this._isExporting = false;
                if (_this._finishedSpans.length > 0) {
                    _this._clearTimer();
                    _this._maybeStartTimer();
                }
            }).catch(function(e) {
                _this._isExporting = false;
                (0, _core.globalErrorHandler)(e);
            });
        };
        // we only wait if the queue doesn't have enough elements yet
        if (this._finishedSpans.length >= this._maxExportBatchSize) return flush();
        if (this._timer !== undefined) return;
        this._timer = setTimeout(function() {
            return flush();
        }, this._scheduledDelayMillis);
        (0, _core.unrefTimer)(this._timer);
    };
    BatchSpanProcessorBase.prototype._clearTimer = function() {
        if (this._timer !== undefined) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
    };
    return BatchSpanProcessorBase;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"1eVry","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fdWa9":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RandomIdGenerator", ()=>RandomIdGenerator);
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
var RandomIdGenerator = /** @class */ function() {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */ this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */ this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}();
var SHARED_CHAR_CODES_ARRAY = Array(32);
function getIdGenerator(bytes) {
    return function generateId() {
        for(var i = 0; i < bytes * 2; i++){
            SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (SHARED_CHAR_CODES_ARRAY[i] >= 58) SHARED_CHAR_CODES_ARRAY[i] += 39;
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"252wY":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ForceFlushState", ()=>ForceFlushState);
parcelHelpers.export(exports, "BasicTracerProvider", ()=>BasicTracerProvider);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var _resources = require("@opentelemetry/resources");
var _ = require(".");
var _config = require("./config");
var _multiSpanProcessor = require("./MultiSpanProcessor");
var _noopSpanProcessor = require("./export/NoopSpanProcessor");
var _platform = require("./platform");
var _utility = require("./utility");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var ForceFlushState;
(function(ForceFlushState) {
    ForceFlushState[ForceFlushState["resolved"] = 0] = "resolved";
    ForceFlushState[ForceFlushState["timeout"] = 1] = "timeout";
    ForceFlushState[ForceFlushState["error"] = 2] = "error";
    ForceFlushState[ForceFlushState["unresolved"] = 3] = "unresolved";
})(ForceFlushState || (ForceFlushState = {}));
/**
 * This class represents a basic tracer provider which platform libraries can extend
 */ var BasicTracerProvider = /** @class */ function() {
    function BasicTracerProvider(config) {
        if (config === void 0) config = {};
        var _a, _b;
        this._registeredSpanProcessors = [];
        this._tracers = new Map();
        var mergedConfig = (0, _core.merge)({}, (0, _config.loadDefaultConfig)(), (0, _utility.reconfigureLimits)(config));
        this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : (0, _resources.Resource).empty();
        if (mergedConfig.mergeResourceWithDefaults) this.resource = (0, _resources.Resource).default().merge(this.resource);
        this._config = Object.assign({}, mergedConfig, {
            resource: this.resource
        });
        if ((_b = config.spanProcessors) === null || _b === void 0 ? void 0 : _b.length) {
            this._registeredSpanProcessors = __spreadArray([], __read(config.spanProcessors), false);
            this.activeSpanProcessor = new (0, _multiSpanProcessor.MultiSpanProcessor)(this._registeredSpanProcessors);
        } else {
            var defaultExporter = this._buildExporterFromEnv();
            if (defaultExporter !== undefined) {
                var batchProcessor = new (0, _platform.BatchSpanProcessor)(defaultExporter);
                this.activeSpanProcessor = batchProcessor;
            } else this.activeSpanProcessor = new (0, _noopSpanProcessor.NoopSpanProcessor)();
        }
    }
    BasicTracerProvider.prototype.getTracer = function(name, version, options) {
        var key = name + "@" + (version || '') + ":" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || '');
        if (!this._tracers.has(key)) this._tracers.set(key, new (0, _.Tracer)({
            name: name,
            version: version,
            schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl
        }, this._config, this));
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._tracers.get(key);
    };
    /**
     * @deprecated please use {@link TracerConfig} spanProcessors property
     * Adds a new {@link SpanProcessor} to this tracer.
     * @param spanProcessor the new SpanProcessor to be added.
     */ BasicTracerProvider.prototype.addSpanProcessor = function(spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) // since we might have enabled by default a batchProcessor, we disable it
        // before adding the new one
        this.activeSpanProcessor.shutdown().catch(function(err) {
            return (0, _api.diag).error('Error while trying to shutdown current span processor', err);
        });
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new (0, _multiSpanProcessor.MultiSpanProcessor)(this._registeredSpanProcessors);
    };
    BasicTracerProvider.prototype.getActiveSpanProcessor = function() {
        return this.activeSpanProcessor;
    };
    /**
     * Register this TracerProvider for use with the OpenTelemetry API.
     * Undefined values may be replaced with defaults, and
     * null values will be skipped.
     *
     * @param config Configuration object for SDK registration
     */ BasicTracerProvider.prototype.register = function(config) {
        if (config === void 0) config = {};
        (0, _api.trace).setGlobalTracerProvider(this);
        if (config.propagator === undefined) config.propagator = this._buildPropagatorFromEnv();
        if (config.contextManager) (0, _api.context).setGlobalContextManager(config.contextManager);
        if (config.propagator) (0, _api.propagation).setGlobalPropagator(config.propagator);
    };
    BasicTracerProvider.prototype.forceFlush = function() {
        var timeout = this._config.forceFlushTimeoutMillis;
        var promises = this._registeredSpanProcessors.map(function(spanProcessor) {
            return new Promise(function(resolve) {
                var state;
                var timeoutInterval = setTimeout(function() {
                    resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
                    state = ForceFlushState.timeout;
                }, timeout);
                spanProcessor.forceFlush().then(function() {
                    clearTimeout(timeoutInterval);
                    if (state !== ForceFlushState.timeout) {
                        state = ForceFlushState.resolved;
                        resolve(state);
                    }
                }).catch(function(error) {
                    clearTimeout(timeoutInterval);
                    state = ForceFlushState.error;
                    resolve(error);
                });
            });
        });
        return new Promise(function(resolve, reject) {
            Promise.all(promises).then(function(results) {
                var errors = results.filter(function(result) {
                    return result !== ForceFlushState.resolved;
                });
                if (errors.length > 0) reject(errors);
                else resolve();
            }).catch(function(error) {
                return reject([
                    error
                ]);
            });
        });
    };
    BasicTracerProvider.prototype.shutdown = function() {
        return this.activeSpanProcessor.shutdown();
    };
    /**
     * TS cannot yet infer the type of this.constructor:
     * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146
     * There is no need to override either of the getters in your child class.
     * The type of the registered component maps should be the same across all
     * classes in the inheritance tree.
     */ BasicTracerProvider.prototype._getPropagator = function(name) {
        var _a;
        return (_a = this.constructor._registeredPropagators.get(name)) === null || _a === void 0 ? void 0 : _a();
    };
    BasicTracerProvider.prototype._getSpanExporter = function(name) {
        var _a;
        return (_a = this.constructor._registeredExporters.get(name)) === null || _a === void 0 ? void 0 : _a();
    };
    BasicTracerProvider.prototype._buildPropagatorFromEnv = function() {
        var _this = this;
        // per spec, propagators from env must be deduplicated
        var uniquePropagatorNames = Array.from(new Set((0, _core.getEnv)().OTEL_PROPAGATORS));
        var propagators = uniquePropagatorNames.map(function(name) {
            var propagator = _this._getPropagator(name);
            if (!propagator) (0, _api.diag).warn("Propagator \"" + name + "\" requested through environment variable is unavailable.");
            return propagator;
        });
        var validPropagators = propagators.reduce(function(list, item) {
            if (item) list.push(item);
            return list;
        }, []);
        if (validPropagators.length === 0) return;
        else if (uniquePropagatorNames.length === 1) return validPropagators[0];
        else return new (0, _core.CompositePropagator)({
            propagators: validPropagators
        });
    };
    BasicTracerProvider.prototype._buildExporterFromEnv = function() {
        var exporterName = (0, _core.getEnv)().OTEL_TRACES_EXPORTER;
        if (exporterName === 'none' || exporterName === '') return;
        var exporter = this._getSpanExporter(exporterName);
        if (!exporter) (0, _api.diag).error("Exporter \"" + exporterName + "\" requested through environment variable is unavailable.");
        return exporter;
    };
    BasicTracerProvider._registeredPropagators = new Map([
        [
            'tracecontext',
            function() {
                return new (0, _core.W3CTraceContextPropagator)();
            }
        ],
        [
            'baggage',
            function() {
                return new (0, _core.W3CBaggagePropagator)();
            }
        ]
    ]);
    BasicTracerProvider._registeredExporters = new Map();
    return BasicTracerProvider;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"1eVry","@opentelemetry/resources":"6qUsw",".":"1KkHk","./config":"keX9s","./MultiSpanProcessor":"dJpCI","./export/NoopSpanProcessor":"55Aje","./platform":"kpW1w","./utility":"7cAWa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6qUsw":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Resource", ()=>(0, _resource.Resource));
parcelHelpers.export(exports, "defaultServiceName", ()=>(0, _platform.defaultServiceName));
parcelHelpers.export(exports, "browserDetector", ()=>(0, _detectors.browserDetector));
parcelHelpers.export(exports, "browserDetectorSync", ()=>(0, _detectors.browserDetectorSync));
parcelHelpers.export(exports, "envDetector", ()=>(0, _detectors.envDetector));
parcelHelpers.export(exports, "envDetectorSync", ()=>(0, _detectors.envDetectorSync));
parcelHelpers.export(exports, "hostDetector", ()=>(0, _detectors.hostDetector));
parcelHelpers.export(exports, "hostDetectorSync", ()=>(0, _detectors.hostDetectorSync));
parcelHelpers.export(exports, "osDetector", ()=>(0, _detectors.osDetector));
parcelHelpers.export(exports, "osDetectorSync", ()=>(0, _detectors.osDetectorSync));
parcelHelpers.export(exports, "processDetector", ()=>(0, _detectors.processDetector));
parcelHelpers.export(exports, "processDetectorSync", ()=>(0, _detectors.processDetectorSync));
parcelHelpers.export(exports, "serviceInstanceIdDetectorSync", ()=>(0, _detectors.serviceInstanceIdDetectorSync));
parcelHelpers.export(exports, "detectResourcesSync", ()=>(0, _detectResources.detectResourcesSync));
parcelHelpers.export(exports, "detectResources", ()=>(0, _detectResources.detectResources));
var _resource = require("./Resource");
var _platform = require("./platform");
var _detectors = require("./detectors");
var _detectResources = require("./detect-resources");

},{"./Resource":"cAS9R","./platform":false,"./detectors":false,"./detect-resources":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cAS9R":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Resource", ()=>Resource);
var _api = require("@opentelemetry/api");
var _semanticConventions = require("@opentelemetry/semantic-conventions");
var _core = require("@opentelemetry/core");
var _platform = require("./platform");
var __assign = undefined && undefined.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
/**
 * A Resource describes the entity for which a signals (metrics or trace) are
 * collected.
 */ var Resource = /** @class */ function() {
    function Resource(/**
     * A dictionary of attributes with string keys and values that provide
     * information about the entity as numbers, strings or booleans
     * TODO: Consider to add check/validation on attributes.
     */ attributes, asyncAttributesPromise) {
        var _this = this;
        var _a;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then(function(asyncAttributes) {
            _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);
            _this.asyncAttributesPending = false;
            return asyncAttributes;
        }, function(err) {
            (0, _api.diag).debug("a resource's async attributes promise rejected: %s", err);
            _this.asyncAttributesPending = false;
            return {};
        });
    }
    /**
     * Returns an empty Resource
     */ Resource.empty = function() {
        return Resource.EMPTY;
    };
    /**
     * Returns a Resource that identifies the SDK in use.
     */ Resource.default = function() {
        var _a;
        return new Resource((_a = {}, _a[0, _semanticConventions.SEMRESATTRS_SERVICE_NAME] = (0, _platform.defaultServiceName)(), _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = (0, _core.SDK_INFO)[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE], _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_NAME] = (0, _core.SDK_INFO)[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_NAME], _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_VERSION] = (0, _core.SDK_INFO)[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_VERSION], _a));
    };
    Object.defineProperty(Resource.prototype, "attributes", {
        get: function() {
            var _a;
            if (this.asyncAttributesPending) (0, _api.diag).error('Accessing resource attributes before async attributes settled');
            return (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
     * this Resource's attributes. This is useful in exporters to block until resource detection
     * has finished.
     */ Resource.prototype.waitForAsyncAttributes = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!this.asyncAttributesPending) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this._asyncAttributesPromise
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Returns a new, merged {@link Resource} by merging the current Resource
     * with the other Resource. In case of a collision, other Resource takes
     * precedence.
     *
     * @param other the Resource that will be merged with this.
     * @returns the newly merged Resource.
     */ Resource.prototype.merge = function(other) {
        var _this = this;
        var _a;
        if (!other) return this;
        // SpanAttributes from other resource overwrite attributes from this resource.
        var mergedSyncAttributes = __assign(__assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) return new Resource(mergedSyncAttributes);
        var mergedAttributesPromise = Promise.all([
            this._asyncAttributesPromise,
            other._asyncAttributesPromise
        ]).then(function(_a) {
            var _b;
            var _c = __read(_a, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];
            return __assign(__assign(__assign(__assign({}, _this._syncAttributes), thisAsyncAttributes), (_b = other._syncAttributes) !== null && _b !== void 0 ? _b : other.attributes), otherAsyncAttributes);
        });
        return new Resource(mergedSyncAttributes, mergedAttributesPromise);
    };
    Resource.EMPTY = new Resource({});
    return Resource;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/semantic-conventions":"lCgfj","@opentelemetry/core":"1eVry","./platform":"e7SaZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e7SaZ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultServiceName", ()=>(0, _defaultServiceName.defaultServiceName));
var _defaultServiceName = require("./default-service-name");

},{"./default-service-name":"9LaHH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9LaHH":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultServiceName", ()=>defaultServiceName);
function defaultServiceName() {
    return 'unknown_service';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dJpCI":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MultiSpanProcessor", ()=>MultiSpanProcessor);
var _core = require("@opentelemetry/core");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * Implementation of the {@link SpanProcessor} that simply forwards all
 * received events to a list of {@link SpanProcessor}s.
 */ var MultiSpanProcessor = /** @class */ function() {
    function MultiSpanProcessor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
    }
    MultiSpanProcessor.prototype.forceFlush = function() {
        var e_1, _a;
        var promises = [];
        try {
            for(var _b = __values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()){
                var spanProcessor = _c.value;
                promises.push(spanProcessor.forceFlush());
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return new Promise(function(resolve) {
            Promise.all(promises).then(function() {
                resolve();
            }).catch(function(error) {
                (0, _core.globalErrorHandler)(error || new Error('MultiSpanProcessor: forceFlush failed'));
                resolve();
            });
        });
    };
    MultiSpanProcessor.prototype.onStart = function(span, context) {
        var e_2, _a;
        try {
            for(var _b = __values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()){
                var spanProcessor = _c.value;
                spanProcessor.onStart(span, context);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    };
    MultiSpanProcessor.prototype.onEnd = function(span) {
        var e_3, _a;
        try {
            for(var _b = __values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()){
                var spanProcessor = _c.value;
                spanProcessor.onEnd(span);
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
    };
    MultiSpanProcessor.prototype.shutdown = function() {
        var e_4, _a;
        var promises = [];
        try {
            for(var _b = __values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()){
                var spanProcessor = _c.value;
                promises.push(spanProcessor.shutdown());
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
        return new Promise(function(resolve, reject) {
            Promise.all(promises).then(function() {
                resolve();
            }, reject);
        });
    };
    return MultiSpanProcessor;
}();

},{"@opentelemetry/core":"1eVry","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"55Aje":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** No-op implementation of SpanProcessor */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopSpanProcessor", ()=>NoopSpanProcessor);
var NoopSpanProcessor = /** @class */ function() {
    function NoopSpanProcessor() {}
    NoopSpanProcessor.prototype.onStart = function(_span, _context) {};
    NoopSpanProcessor.prototype.onEnd = function(_span) {};
    NoopSpanProcessor.prototype.shutdown = function() {
        return Promise.resolve();
    };
    NoopSpanProcessor.prototype.forceFlush = function() {
        return Promise.resolve();
    };
    return NoopSpanProcessor;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dXLQl":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StackContextManager", ()=>StackContextManager);
var _api = require("@opentelemetry/api");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Stack Context Manager for managing the state in web
 * it doesn't fully support the async calls though
 */ var StackContextManager = /** @class */ function() {
    function StackContextManager() {
        /**
         * whether the context manager is enabled or not
         */ this._enabled = false;
        /**
         * Keeps the reference to current context
         */ this._currentContext = (0, _api.ROOT_CONTEXT);
    }
    /**
     *
     * @param context
     * @param target Function to be executed within the context
     */ // eslint-disable-next-line @typescript-eslint/ban-types
    StackContextManager.prototype._bindFunction = function(context, target) {
        if (context === void 0) context = (0, _api.ROOT_CONTEXT);
        var manager = this;
        var contextWrapper = function() {
            var _this = this;
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
            return manager.with(context, function() {
                return target.apply(_this, args);
            });
        };
        Object.defineProperty(contextWrapper, 'length', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: target.length
        });
        return contextWrapper;
    };
    /**
     * Returns the active context
     */ StackContextManager.prototype.active = function() {
        return this._currentContext;
    };
    /**
     * Binds a the certain context or the active one to the target function and then returns the target
     * @param context A context (span) to be bind to target
     * @param target a function or event emitter. When target or one of its callbacks is called,
     *  the provided context will be used as the active context for the duration of the call.
     */ StackContextManager.prototype.bind = function(context, target) {
        // if no specific context to propagate is given, we use the current one
        if (context === undefined) context = this.active();
        if (typeof target === 'function') return this._bindFunction(context, target);
        return target;
    };
    /**
     * Disable the context manager (clears the current context)
     */ StackContextManager.prototype.disable = function() {
        this._currentContext = (0, _api.ROOT_CONTEXT);
        this._enabled = false;
        return this;
    };
    /**
     * Enables the context manager and creates a default(root) context
     */ StackContextManager.prototype.enable = function() {
        if (this._enabled) return this;
        this._enabled = true;
        this._currentContext = (0, _api.ROOT_CONTEXT);
        return this;
    };
    /**
     * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.
     * The context will be set as active
     * @param context
     * @param fn Callback function
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */ StackContextManager.prototype.with = function(context, fn, thisArg) {
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++)args[_i - 3] = arguments[_i];
        var previousContext = this._currentContext;
        this._currentContext = context || (0, _api.ROOT_CONTEXT);
        try {
            return fn.call.apply(fn, __spreadArray([
                thisArg
            ], __read(args), false));
        } finally{
            this._currentContext = previousContext;
        }
    };
    return StackContextManager;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eNyqo":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PerformanceTimingNames", ()=>PerformanceTimingNames);
var PerformanceTimingNames;
(function(PerformanceTimingNames) {
    PerformanceTimingNames["CONNECT_END"] = "connectEnd";
    PerformanceTimingNames["CONNECT_START"] = "connectStart";
    PerformanceTimingNames["DECODED_BODY_SIZE"] = "decodedBodySize";
    PerformanceTimingNames["DOM_COMPLETE"] = "domComplete";
    PerformanceTimingNames["DOM_CONTENT_LOADED_EVENT_END"] = "domContentLoadedEventEnd";
    PerformanceTimingNames["DOM_CONTENT_LOADED_EVENT_START"] = "domContentLoadedEventStart";
    PerformanceTimingNames["DOM_INTERACTIVE"] = "domInteractive";
    PerformanceTimingNames["DOMAIN_LOOKUP_END"] = "domainLookupEnd";
    PerformanceTimingNames["DOMAIN_LOOKUP_START"] = "domainLookupStart";
    PerformanceTimingNames["ENCODED_BODY_SIZE"] = "encodedBodySize";
    PerformanceTimingNames["FETCH_START"] = "fetchStart";
    PerformanceTimingNames["LOAD_EVENT_END"] = "loadEventEnd";
    PerformanceTimingNames["LOAD_EVENT_START"] = "loadEventStart";
    PerformanceTimingNames["NAVIGATION_START"] = "navigationStart";
    PerformanceTimingNames["REDIRECT_END"] = "redirectEnd";
    PerformanceTimingNames["REDIRECT_START"] = "redirectStart";
    PerformanceTimingNames["REQUEST_START"] = "requestStart";
    PerformanceTimingNames["RESPONSE_END"] = "responseEnd";
    PerformanceTimingNames["RESPONSE_START"] = "responseStart";
    PerformanceTimingNames["SECURE_CONNECTION_START"] = "secureConnectionStart";
    PerformanceTimingNames["UNLOAD_EVENT_END"] = "unloadEventEnd";
    PerformanceTimingNames["UNLOAD_EVENT_START"] = "unloadEventStart";
})(PerformanceTimingNames || (PerformanceTimingNames = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ccAWO":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Helper function to be able to use enum as typed key in type and in interface when using forEach
 * @param obj
 * @param key
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
parcelHelpers.export(exports, "hasKey", ()=>hasKey);
/**
 * Helper function for starting an event on span based on {@link PerformanceEntries}
 * @param span
 * @param performanceName name of performance entry for time start
 * @param entries
 * @param refPerfName name of performance entry to use for reference
 */ parcelHelpers.export(exports, "addSpanNetworkEvent", ()=>addSpanNetworkEvent);
/**
 * Helper function for adding network events
 * @param span
 * @param resource
 */ parcelHelpers.export(exports, "addSpanNetworkEvents", ()=>addSpanNetworkEvents);
/**
 * sort resources by startTime
 * @param filteredResources
 */ parcelHelpers.export(exports, "sortResources", ()=>sortResources);
/**
 * Get closest performance resource ignoring the resources that have been
 * already used.
 * @param spanUrl
 * @param startTimeHR
 * @param endTimeHR
 * @param resources
 * @param ignoredResources
 * @param initiatorType
 */ parcelHelpers.export(exports, "getResource", ()=>getResource);
/**
 * Parses url using URL constructor or fallback to anchor element.
 * @param url
 */ parcelHelpers.export(exports, "parseUrl", ()=>parseUrl);
/**
 * Parses url using URL constructor or fallback to anchor element and serialize
 * it to a string.
 *
 * Performs the steps described in https://html.spec.whatwg.org/multipage/urls-and-fetching.html#parse-a-url
 *
 * @param url
 */ parcelHelpers.export(exports, "normalizeUrl", ()=>normalizeUrl);
/**
 * Get element XPath
 * @param target - target element
 * @param optimised - when id attribute of element is present the xpath can be
 * simplified to contain id
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
parcelHelpers.export(exports, "getElementXPath", ()=>getElementXPath);
/**
 * Checks if trace headers should be propagated
 * @param spanUrl
 * @private
 */ parcelHelpers.export(exports, "shouldPropagateTraceHeaders", ()=>shouldPropagateTraceHeaders);
var _performanceTimingNames = require("./enums/PerformanceTimingNames");
var _core = require("@opentelemetry/core");
var _semanticConventions = require("@opentelemetry/semantic-conventions");
// Used to normalize relative URLs
var urlNormalizingAnchor;
function getUrlNormalizingAnchor() {
    if (!urlNormalizingAnchor) urlNormalizingAnchor = document.createElement('a');
    return urlNormalizingAnchor;
}
function hasKey(obj, key) {
    return key in obj;
}
function addSpanNetworkEvent(span, performanceName, entries, refPerfName) {
    var perfTime = undefined;
    var refTime = undefined;
    if (hasKey(entries, performanceName) && typeof entries[performanceName] === 'number') perfTime = entries[performanceName];
    var refName = refPerfName || (0, _performanceTimingNames.PerformanceTimingNames).FETCH_START;
    // Use a reference time which is the earliest possible value so that the performance timings that are earlier should not be added
    // using FETCH START time in case no reference is provided
    if (hasKey(entries, refName) && typeof entries[refName] === 'number') refTime = entries[refName];
    if (perfTime !== undefined && refTime !== undefined && perfTime >= refTime) {
        span.addEvent(performanceName, perfTime);
        return span;
    }
    return undefined;
}
function addSpanNetworkEvents(span, resource) {
    addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).FETCH_START, resource);
    addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).DOMAIN_LOOKUP_START, resource);
    addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).DOMAIN_LOOKUP_END, resource);
    addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).CONNECT_START, resource);
    if (hasKey(resource, 'name') && resource['name'].startsWith('https:')) addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).SECURE_CONNECTION_START, resource);
    addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).CONNECT_END, resource);
    addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).REQUEST_START, resource);
    addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).RESPONSE_START, resource);
    addSpanNetworkEvent(span, (0, _performanceTimingNames.PerformanceTimingNames).RESPONSE_END, resource);
    var encodedLength = resource[(0, _performanceTimingNames.PerformanceTimingNames).ENCODED_BODY_SIZE];
    if (encodedLength !== undefined) span.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH), encodedLength);
    var decodedLength = resource[(0, _performanceTimingNames.PerformanceTimingNames).DECODED_BODY_SIZE];
    // Spec: Not set if transport encoding not used (in which case encoded and decoded sizes match)
    if (decodedLength !== undefined && encodedLength !== decodedLength) span.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED), decodedLength);
}
function sortResources(filteredResources) {
    return filteredResources.slice().sort(function(a, b) {
        var valueA = a[(0, _performanceTimingNames.PerformanceTimingNames).FETCH_START];
        var valueB = b[(0, _performanceTimingNames.PerformanceTimingNames).FETCH_START];
        if (valueA > valueB) return 1;
        else if (valueA < valueB) return -1;
        return 0;
    });
}
/** Returns the origin if present (if in browser context). */ function getOrigin() {
    return typeof location !== 'undefined' ? location.origin : undefined;
}
function getResource(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
    if (ignoredResources === void 0) ignoredResources = new WeakSet();
    // de-relativize the URL before usage (does no harm to absolute URLs)
    var parsedSpanUrl = parseUrl(spanUrl);
    spanUrl = parsedSpanUrl.toString();
    var filteredResources = filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType);
    if (filteredResources.length === 0) return {
        mainRequest: undefined
    };
    if (filteredResources.length === 1) return {
        mainRequest: filteredResources[0]
    };
    var sorted = sortResources(filteredResources);
    if (parsedSpanUrl.origin !== getOrigin() && sorted.length > 1) {
        var corsPreFlightRequest = sorted[0];
        var mainRequest = findMainRequest(sorted, corsPreFlightRequest[(0, _performanceTimingNames.PerformanceTimingNames).RESPONSE_END], endTimeHR);
        var responseEnd = corsPreFlightRequest[(0, _performanceTimingNames.PerformanceTimingNames).RESPONSE_END];
        var fetchStart = mainRequest[(0, _performanceTimingNames.PerformanceTimingNames).FETCH_START];
        // no corsPreFlightRequest
        if (fetchStart < responseEnd) {
            mainRequest = corsPreFlightRequest;
            corsPreFlightRequest = undefined;
        }
        return {
            corsPreFlightRequest: corsPreFlightRequest,
            mainRequest: mainRequest
        };
    } else return {
        mainRequest: filteredResources[0]
    };
}
/**
 * Will find the main request skipping the cors pre flight requests
 * @param resources
 * @param corsPreFlightRequestEndTime
 * @param spanEndTimeHR
 */ function findMainRequest(resources, corsPreFlightRequestEndTime, spanEndTimeHR) {
    var spanEndTime = (0, _core.hrTimeToNanoseconds)(spanEndTimeHR);
    var minTime = (0, _core.hrTimeToNanoseconds)((0, _core.timeInputToHrTime)(corsPreFlightRequestEndTime));
    var mainRequest = resources[1];
    var bestGap;
    var length = resources.length;
    for(var i = 1; i < length; i++){
        var resource = resources[i];
        var resourceStartTime = (0, _core.hrTimeToNanoseconds)((0, _core.timeInputToHrTime)(resource[(0, _performanceTimingNames.PerformanceTimingNames).FETCH_START]));
        var resourceEndTime = (0, _core.hrTimeToNanoseconds)((0, _core.timeInputToHrTime)(resource[(0, _performanceTimingNames.PerformanceTimingNames).RESPONSE_END]));
        var currentGap = spanEndTime - resourceEndTime;
        if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {
            bestGap = currentGap;
            mainRequest = resource;
        }
    }
    return mainRequest;
}
/**
 * Filter all resources that has started and finished according to span start time and end time.
 *     It will return the closest resource to a start time
 * @param spanUrl
 * @param startTimeHR
 * @param endTimeHR
 * @param resources
 * @param ignoredResources
 */ function filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
    var startTime = (0, _core.hrTimeToNanoseconds)(startTimeHR);
    var endTime = (0, _core.hrTimeToNanoseconds)(endTimeHR);
    var filteredResources = resources.filter(function(resource) {
        var resourceStartTime = (0, _core.hrTimeToNanoseconds)((0, _core.timeInputToHrTime)(resource[(0, _performanceTimingNames.PerformanceTimingNames).FETCH_START]));
        var resourceEndTime = (0, _core.hrTimeToNanoseconds)((0, _core.timeInputToHrTime)(resource[(0, _performanceTimingNames.PerformanceTimingNames).RESPONSE_END]));
        return resource.initiatorType.toLowerCase() === (initiatorType || 'xmlhttprequest') && resource.name === spanUrl && resourceStartTime >= startTime && resourceEndTime <= endTime;
    });
    if (filteredResources.length > 0) filteredResources = filteredResources.filter(function(resource) {
        return !ignoredResources.has(resource);
    });
    return filteredResources;
}
function parseUrl(url) {
    if (typeof URL === 'function') return new URL(url, typeof document !== 'undefined' ? document.baseURI : typeof location !== 'undefined' // Some JS runtimes (e.g. Deno) don't define this
     ? location.href : undefined);
    var element = getUrlNormalizingAnchor();
    element.href = url;
    return element;
}
function normalizeUrl(url) {
    var urlLike = parseUrl(url);
    return urlLike.href;
}
function getElementXPath(target, optimised) {
    if (target.nodeType === Node.DOCUMENT_NODE) return '/';
    var targetValue = getNodeValue(target, optimised);
    if (optimised && targetValue.indexOf('@id') > 0) return targetValue;
    var xpath = '';
    if (target.parentNode) xpath += getElementXPath(target.parentNode, false);
    xpath += targetValue;
    return xpath;
}
/**
 * get node index within the siblings
 * @param target
 */ function getNodeIndex(target) {
    if (!target.parentNode) return 0;
    var allowedTypes = [
        target.nodeType
    ];
    if (target.nodeType === Node.CDATA_SECTION_NODE) allowedTypes.push(Node.TEXT_NODE);
    var elements = Array.from(target.parentNode.childNodes);
    elements = elements.filter(function(element) {
        var localName = element.localName;
        return allowedTypes.indexOf(element.nodeType) >= 0 && localName === target.localName;
    });
    if (elements.length >= 1) return elements.indexOf(target) + 1; // xpath starts from 1
    // if there are no other similar child xpath doesn't need index
    return 0;
}
/**
 * get node value for xpath
 * @param target
 * @param optimised
 */ function getNodeValue(target, optimised) {
    var nodeType = target.nodeType;
    var index = getNodeIndex(target);
    var nodeValue = '';
    if (nodeType === Node.ELEMENT_NODE) {
        var id = target.getAttribute('id');
        if (optimised && id) return "//*[@id=\"" + id + "\"]";
        nodeValue = target.localName;
    } else if (nodeType === Node.TEXT_NODE || nodeType === Node.CDATA_SECTION_NODE) nodeValue = 'text()';
    else if (nodeType === Node.COMMENT_NODE) nodeValue = 'comment()';
    else return '';
    // if index is 1 it can be omitted in xpath
    if (nodeValue && index > 1) return "/" + nodeValue + "[" + index + "]";
    return "/" + nodeValue;
}
function shouldPropagateTraceHeaders(spanUrl, propagateTraceHeaderCorsUrls) {
    var propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];
    if (typeof propagateTraceHeaderUrls === 'string' || propagateTraceHeaderUrls instanceof RegExp) propagateTraceHeaderUrls = [
        propagateTraceHeaderUrls
    ];
    var parsedSpanUrl = parseUrl(spanUrl);
    if (parsedSpanUrl.origin === getOrigin()) return true;
    else return propagateTraceHeaderUrls.some(function(propagateTraceHeaderUrl) {
        return (0, _core.urlMatches)(spanUrl, propagateTraceHeaderUrl);
    });
}

},{"./enums/PerformanceTimingNames":"eNyqo","@opentelemetry/core":"1eVry","@opentelemetry/semantic-conventions":"lCgfj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"exbkI":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instrumentation = require("./instrumentation");
parcelHelpers.exportAll(_instrumentation, exports);
var _attributeNames = require("./enums/AttributeNames");
parcelHelpers.exportAll(_attributeNames, exports);
var _types = require("./types");
parcelHelpers.exportAll(_types, exports);

},{"./instrumentation":"b9rsS","./enums/AttributeNames":"2uTf8","./types":"5cOeU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b9rsS":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DocumentLoadInstrumentation", ()=>DocumentLoadInstrumentation);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var _sdkTraceWeb = require("@opentelemetry/sdk-trace-web");
var _instrumentation = require("@opentelemetry/instrumentation");
var _attributeNames = require("./enums/AttributeNames");
/** @knipignore */ var _version = require("./version");
var _semanticConventions = require("@opentelemetry/semantic-conventions");
var _utils = require("./utils");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * This class represents a document load plugin
 */ var DocumentLoadInstrumentation = /** @class */ function(_super) {
    __extends(DocumentLoadInstrumentation, _super);
    function DocumentLoadInstrumentation(config) {
        if (config === void 0) config = {};
        var _this = _super.call(this, (0, _version.PACKAGE_NAME), (0, _version.PACKAGE_VERSION), config) || this;
        _this.component = 'document-load';
        _this.version = '1';
        _this.moduleName = _this.component;
        return _this;
    }
    DocumentLoadInstrumentation.prototype.init = function() {};
    /**
     * callback to be executed when page is loaded
     */ DocumentLoadInstrumentation.prototype._onDocumentLoaded = function() {
        var _this = this;
        // Timeout is needed as load event doesn't have yet the performance metrics for loadEnd.
        // Support for event "loadend" is very limited and cannot be used
        window.setTimeout(function() {
            _this._collectPerformance();
        });
    };
    /**
     * Adds spans for all resources
     * @param rootSpan
     */ DocumentLoadInstrumentation.prototype._addResourcesSpans = function(rootSpan) {
        var _this = this;
        var _a, _b;
        var resources = (_b = (_a = (0, _core.otperformance)).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a, 'resource');
        if (resources) resources.forEach(function(resource) {
            _this._initResourceSpan(resource, rootSpan);
        });
    };
    /**
     * Collects information about performance and creates appropriate spans
     */ DocumentLoadInstrumentation.prototype._collectPerformance = function() {
        var _this = this;
        var metaElement = Array.from(document.getElementsByTagName('meta')).find(function(e) {
            return e.getAttribute('name') === (0, _core.TRACE_PARENT_HEADER);
        });
        var entries = (0, _utils.getPerformanceNavigationEntries)();
        var traceparent = metaElement && metaElement.content || '';
        (0, _api.context).with((0, _api.propagation).extract((0, _api.ROOT_CONTEXT), {
            traceparent: traceparent
        }), function() {
            var _a;
            var rootSpan = _this._startSpan((0, _attributeNames.AttributeNames).DOCUMENT_LOAD, (0, _sdkTraceWeb.PerformanceTimingNames).FETCH_START, entries);
            if (!rootSpan) return;
            (0, _api.context).with((0, _api.trace).setSpan((0, _api.context).active(), rootSpan), function() {
                var fetchSpan = _this._startSpan((0, _attributeNames.AttributeNames).DOCUMENT_FETCH, (0, _sdkTraceWeb.PerformanceTimingNames).FETCH_START, entries);
                if (fetchSpan) {
                    fetchSpan.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_URL), location.href);
                    (0, _api.context).with((0, _api.trace).setSpan((0, _api.context).active(), fetchSpan), function() {
                        var _a;
                        if (!_this.getConfig().ignoreNetworkEvents) (0, _sdkTraceWeb.addSpanNetworkEvents)(fetchSpan, entries);
                        _this._addCustomAttributesOnSpan(fetchSpan, (_a = _this.getConfig().applyCustomAttributesOnSpan) === null || _a === void 0 ? void 0 : _a.documentFetch);
                        _this._endSpan(fetchSpan, (0, _sdkTraceWeb.PerformanceTimingNames).RESPONSE_END, entries);
                    });
                }
            });
            rootSpan.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_URL), location.href);
            rootSpan.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_USER_AGENT), navigator.userAgent);
            _this._addResourcesSpans(rootSpan);
            if (!_this.getConfig().ignoreNetworkEvents) {
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).FETCH_START, entries);
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).UNLOAD_EVENT_START, entries);
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).UNLOAD_EVENT_END, entries);
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).DOM_INTERACTIVE, entries);
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).DOM_CONTENT_LOADED_EVENT_START, entries);
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).DOM_CONTENT_LOADED_EVENT_END, entries);
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).DOM_COMPLETE, entries);
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).LOAD_EVENT_START, entries);
                (0, _sdkTraceWeb.addSpanNetworkEvent)(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).LOAD_EVENT_END, entries);
            }
            if (!_this.getConfig().ignorePerformancePaintEvents) (0, _utils.addSpanPerformancePaintEvents)(rootSpan);
            _this._addCustomAttributesOnSpan(rootSpan, (_a = _this.getConfig().applyCustomAttributesOnSpan) === null || _a === void 0 ? void 0 : _a.documentLoad);
            _this._endSpan(rootSpan, (0, _sdkTraceWeb.PerformanceTimingNames).LOAD_EVENT_END, entries);
        });
    };
    /**
     * Helper function for ending span
     * @param span
     * @param performanceName name of performance entry for time end
     * @param entries
     */ DocumentLoadInstrumentation.prototype._endSpan = function(span, performanceName, entries) {
        // span can be undefined when entries are missing the certain performance - the span will not be created
        if (span) {
            if ((0, _sdkTraceWeb.hasKey)(entries, performanceName)) span.end(entries[performanceName]);
            else // just end span
            span.end();
        }
    };
    /**
     * Creates and ends a span with network information about resource added as timed events
     * @param resource
     * @param parentSpan
     */ DocumentLoadInstrumentation.prototype._initResourceSpan = function(resource, parentSpan) {
        var _a;
        var span = this._startSpan((0, _attributeNames.AttributeNames).RESOURCE_FETCH, (0, _sdkTraceWeb.PerformanceTimingNames).FETCH_START, resource, parentSpan);
        if (span) {
            span.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_URL), resource.name);
            if (!this.getConfig().ignoreNetworkEvents) (0, _sdkTraceWeb.addSpanNetworkEvents)(span, resource);
            this._addCustomAttributesOnResourceSpan(span, resource, (_a = this.getConfig().applyCustomAttributesOnSpan) === null || _a === void 0 ? void 0 : _a.resourceFetch);
            this._endSpan(span, (0, _sdkTraceWeb.PerformanceTimingNames).RESPONSE_END, resource);
        }
    };
    /**
     * Helper function for starting a span
     * @param spanName name of span
     * @param performanceName name of performance entry for time start
     * @param entries
     * @param parentSpan
     */ DocumentLoadInstrumentation.prototype._startSpan = function(spanName, performanceName, entries, parentSpan) {
        if ((0, _sdkTraceWeb.hasKey)(entries, performanceName) && typeof entries[performanceName] === 'number') {
            var span = this.tracer.startSpan(spanName, {
                startTime: entries[performanceName]
            }, parentSpan ? (0, _api.trace).setSpan((0, _api.context).active(), parentSpan) : undefined);
            return span;
        }
        return undefined;
    };
    /**
     * executes callback {_onDocumentLoaded} when the page is loaded
     */ DocumentLoadInstrumentation.prototype._waitForPageLoad = function() {
        if (window.document.readyState === 'complete') this._onDocumentLoaded();
        else {
            this._onDocumentLoaded = this._onDocumentLoaded.bind(this);
            window.addEventListener('load', this._onDocumentLoaded);
        }
    };
    /**
     * adds custom attributes to root span if configured
     */ DocumentLoadInstrumentation.prototype._addCustomAttributesOnSpan = function(span, applyCustomAttributesOnSpan) {
        var _this = this;
        if (applyCustomAttributesOnSpan) (0, _instrumentation.safeExecuteInTheMiddle)(function() {
            return applyCustomAttributesOnSpan(span);
        }, function(error) {
            if (!error) return;
            _this._diag.error('addCustomAttributesOnSpan', error);
        }, true);
    };
    /**
     * adds custom attributes to span if configured
     */ DocumentLoadInstrumentation.prototype._addCustomAttributesOnResourceSpan = function(span, resource, applyCustomAttributesOnSpan) {
        var _this = this;
        if (applyCustomAttributesOnSpan) (0, _instrumentation.safeExecuteInTheMiddle)(function() {
            return applyCustomAttributesOnSpan(span, resource);
        }, function(error) {
            if (!error) return;
            _this._diag.error('addCustomAttributesOnResourceSpan', error);
        }, true);
    };
    /**
     * implements enable function
     */ DocumentLoadInstrumentation.prototype.enable = function() {
        // remove previously attached load to avoid adding the same event twice
        // in case of multiple enable calling.
        window.removeEventListener('load', this._onDocumentLoaded);
        this._waitForPageLoad();
    };
    /**
     * implements disable function
     */ DocumentLoadInstrumentation.prototype.disable = function() {
        window.removeEventListener('load', this._onDocumentLoaded);
    };
    return DocumentLoadInstrumentation;
}((0, _instrumentation.InstrumentationBase));

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"dBsXh","@opentelemetry/sdk-trace-web":"eXZZL","@opentelemetry/instrumentation":"3OTpd","./enums/AttributeNames":"2uTf8","./version":"kjKSa","@opentelemetry/semantic-conventions":"lCgfj","./utils":"hRpx5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3OTpd":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerInstrumentations", ()=>(0, _autoLoader.registerInstrumentations));
parcelHelpers.export(exports, "InstrumentationBase", ()=>(0, _index.InstrumentationBase));
parcelHelpers.export(exports, "InstrumentationNodeModuleDefinition", ()=>(0, _instrumentationNodeModuleDefinition.InstrumentationNodeModuleDefinition));
parcelHelpers.export(exports, "InstrumentationNodeModuleFile", ()=>(0, _instrumentationNodeModuleFile.InstrumentationNodeModuleFile));
parcelHelpers.export(exports, "isWrapped", ()=>(0, _utils.isWrapped));
parcelHelpers.export(exports, "safeExecuteInTheMiddle", ()=>(0, _utils.safeExecuteInTheMiddle));
parcelHelpers.export(exports, "safeExecuteInTheMiddleAsync", ()=>(0, _utils.safeExecuteInTheMiddleAsync));
var _autoLoader = require("./autoLoader");
var _index = require("./platform/index");
var _instrumentationNodeModuleDefinition = require("./instrumentationNodeModuleDefinition");
var _instrumentationNodeModuleFile = require("./instrumentationNodeModuleFile");
var _utils = require("./utils");

},{"./autoLoader":"4D6OU","./platform/index":"lLPwY","./instrumentationNodeModuleDefinition":false,"./instrumentationNodeModuleFile":false,"./utils":"3YarC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4D6OU":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * It will register instrumentations and plugins
 * @param options
 * @return returns function to unload instrumentation and plugins that were
 *   registered
 */ parcelHelpers.export(exports, "registerInstrumentations", ()=>registerInstrumentations);
var _api = require("@opentelemetry/api");
var _apiLogs = require("@opentelemetry/api-logs");
var _autoLoaderUtils = require("./autoLoaderUtils");
function registerInstrumentations(options) {
    var _a, _b;
    var tracerProvider = options.tracerProvider || (0, _api.trace).getTracerProvider();
    var meterProvider = options.meterProvider || (0, _api.metrics).getMeterProvider();
    var loggerProvider = options.loggerProvider || (0, _apiLogs.logs).getLoggerProvider();
    var instrumentations = (_b = (_a = options.instrumentations) === null || _a === void 0 ? void 0 : _a.flat()) !== null && _b !== void 0 ? _b : [];
    (0, _autoLoaderUtils.enableInstrumentations)(instrumentations, tracerProvider, meterProvider, loggerProvider);
    return function() {
        (0, _autoLoaderUtils.disableInstrumentations)(instrumentations);
    };
}

},{"@opentelemetry/api":"6AC4z","@opentelemetry/api-logs":"8PPAH","./autoLoaderUtils":"7OC7p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8PPAH":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SeverityNumber", ()=>(0, _logRecord.SeverityNumber));
parcelHelpers.export(exports, "NOOP_LOGGER", ()=>(0, _noopLogger.NOOP_LOGGER));
parcelHelpers.export(exports, "NoopLogger", ()=>(0, _noopLogger.NoopLogger));
parcelHelpers.export(exports, "NOOP_LOGGER_PROVIDER", ()=>(0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER));
parcelHelpers.export(exports, "NoopLoggerProvider", ()=>(0, _noopLoggerProvider.NoopLoggerProvider));
parcelHelpers.export(exports, "ProxyLogger", ()=>(0, _proxyLogger.ProxyLogger));
parcelHelpers.export(exports, "ProxyLoggerProvider", ()=>(0, _proxyLoggerProvider.ProxyLoggerProvider));
parcelHelpers.export(exports, "logs", ()=>logs);
var _logRecord = require("./types/LogRecord");
var _noopLogger = require("./NoopLogger");
var _noopLoggerProvider = require("./NoopLoggerProvider");
var _proxyLogger = require("./ProxyLogger");
var _proxyLoggerProvider = require("./ProxyLoggerProvider");
var _logs = require("./api/logs");
var logs = (0, _logs.LogsAPI).getInstance();

},{"./types/LogRecord":false,"./NoopLogger":false,"./NoopLoggerProvider":false,"./ProxyLogger":false,"./ProxyLoggerProvider":false,"./api/logs":"bJuoF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3wEsI":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopLogger", ()=>NoopLogger);
parcelHelpers.export(exports, "NOOP_LOGGER", ()=>NOOP_LOGGER);
var NoopLogger = /** @class */ function() {
    function NoopLogger() {}
    NoopLogger.prototype.emit = function(_logRecord) {};
    return NoopLogger;
}();
var NOOP_LOGGER = new NoopLogger();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d2o09":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopLoggerProvider", ()=>NoopLoggerProvider);
parcelHelpers.export(exports, "NOOP_LOGGER_PROVIDER", ()=>NOOP_LOGGER_PROVIDER);
var _noopLogger = require("./NoopLogger");
var NoopLoggerProvider = /** @class */ function() {
    function NoopLoggerProvider() {}
    NoopLoggerProvider.prototype.getLogger = function(_name, _version, _options) {
        return new (0, _noopLogger.NoopLogger)();
    };
    return NoopLoggerProvider;
}();
var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

},{"./NoopLogger":"3wEsI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Tkw6":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProxyLogger", ()=>ProxyLogger);
var _noopLogger = require("./NoopLogger");
var ProxyLogger = /** @class */ function() {
    function ProxyLogger(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    /**
     * Emit a log record. This method should only be used by log appenders.
     *
     * @param logRecord
     */ ProxyLogger.prototype.emit = function(logRecord) {
        this._getLogger().emit(logRecord);
    };
    /**
     * Try to get a logger from the proxy logger provider.
     * If the proxy logger provider has no delegate, return a noop logger.
     */ ProxyLogger.prototype._getLogger = function() {
        if (this._delegate) return this._delegate;
        var logger = this._provider.getDelegateLogger(this.name, this.version, this.options);
        if (!logger) return 0, _noopLogger.NOOP_LOGGER;
        this._delegate = logger;
        return this._delegate;
    };
    return ProxyLogger;
}();

},{"./NoopLogger":"3wEsI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2y3Np":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProxyLoggerProvider", ()=>ProxyLoggerProvider);
var _noopLoggerProvider = require("./NoopLoggerProvider");
var _proxyLogger = require("./ProxyLogger");
var ProxyLoggerProvider = /** @class */ function() {
    function ProxyLoggerProvider() {}
    ProxyLoggerProvider.prototype.getLogger = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new (0, _proxyLogger.ProxyLogger)(this, name, version, options);
    };
    ProxyLoggerProvider.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : (0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER);
    };
    /**
     * Set the delegate logger provider
     */ ProxyLoggerProvider.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyLoggerProvider.prototype.getDelegateLogger = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
    };
    return ProxyLoggerProvider;
}();

},{"./NoopLoggerProvider":"d2o09","./ProxyLogger":"6Tkw6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bJuoF":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LogsAPI", ()=>LogsAPI);
var _globalUtils = require("../internal/global-utils");
var _noopLoggerProvider = require("../NoopLoggerProvider");
var _proxyLoggerProvider = require("../ProxyLoggerProvider");
var LogsAPI = /** @class */ function() {
    function LogsAPI() {
        this._proxyLoggerProvider = new (0, _proxyLoggerProvider.ProxyLoggerProvider)();
    }
    LogsAPI.getInstance = function() {
        if (!this._instance) this._instance = new LogsAPI();
        return this._instance;
    };
    LogsAPI.prototype.setGlobalLoggerProvider = function(provider) {
        if ((0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY]) return this.getLoggerProvider();
        (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY] = (0, _globalUtils.makeGetter)((0, _globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION), provider, (0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER));
        this._proxyLoggerProvider.setDelegate(provider);
        return provider;
    };
    /**
     * Returns the global logger provider.
     *
     * @returns LoggerProvider
     */ LogsAPI.prototype.getLoggerProvider = function() {
        var _a, _b;
        return (_b = (_a = (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call((0, _globalUtils._global), (0, _globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION))) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
    };
    /**
     * Returns a logger from the global logger provider.
     *
     * @returns Logger
     */ LogsAPI.prototype.getLogger = function(name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
    };
    /** Remove the global logger provider */ LogsAPI.prototype.disable = function() {
        delete (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY];
        this._proxyLoggerProvider = new (0, _proxyLoggerProvider.ProxyLoggerProvider)();
    };
    return LogsAPI;
}();

},{"../internal/global-utils":"glyIT","../NoopLoggerProvider":"d2o09","../ProxyLoggerProvider":"2y3Np","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"glyIT":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GLOBAL_LOGS_API_KEY", ()=>GLOBAL_LOGS_API_KEY);
parcelHelpers.export(exports, "_global", ()=>_global);
/**
 * Make a function which accepts a version integer and returns the instance of an API if the version
 * is compatible, or a fallback version (usually NOOP) if it is not.
 *
 * @param requiredVersion Backwards compatibility version which is required to return the instance
 * @param instance Instance which should be returned if the required version is compatible
 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
 */ parcelHelpers.export(exports, "makeGetter", ()=>makeGetter);
parcelHelpers.export(exports, "API_BACKWARDS_COMPATIBILITY_VERSION", ()=>API_BACKWARDS_COMPATIBILITY_VERSION);
var _platform = require("../platform");
var GLOBAL_LOGS_API_KEY = Symbol.for('io.opentelemetry.js.api.logs');
var _global = (0, _platform._globalThis);
function makeGetter(requiredVersion, instance, fallback) {
    return function(version) {
        return version === requiredVersion ? instance : fallback;
    };
}
var API_BACKWARDS_COMPATIBILITY_VERSION = 1;

},{"../platform":"cicGq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cicGq":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>(0, _globalThis._globalThis));
var _globalThis = require("./globalThis");

},{"./globalThis":"7NLgd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7NLgd":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */ /** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>_globalThis);
var global = arguments[3];
var _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7OC7p":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Enable instrumentations
 * @param instrumentations
 * @param tracerProvider
 * @param meterProvider
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "enableInstrumentations", ()=>enableInstrumentations);
/**
 * Disable instrumentations
 * @param instrumentations
 */ parcelHelpers.export(exports, "disableInstrumentations", ()=>disableInstrumentations);
function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
    for(var i = 0, j = instrumentations.length; i < j; i++){
        var instrumentation = instrumentations[i];
        if (tracerProvider) instrumentation.setTracerProvider(tracerProvider);
        if (meterProvider) instrumentation.setMeterProvider(meterProvider);
        if (loggerProvider && instrumentation.setLoggerProvider) instrumentation.setLoggerProvider(loggerProvider);
        // instrumentations have been already enabled during creation
        // so enable only if user prevented that by setting enabled to false
        // this is to prevent double enabling but when calling register all
        // instrumentations should be now enabled
        if (!instrumentation.getConfig().enabled) instrumentation.enable();
    }
}
function disableInstrumentations(instrumentations) {
    instrumentations.forEach(function(instrumentation) {
        return instrumentation.disable();
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lLPwY":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationBase", ()=>(0, _instrumentation.InstrumentationBase));
parcelHelpers.export(exports, "normalize", ()=>(0, _noopNormalize.normalize));
var _instrumentation = require("./instrumentation");
var _noopNormalize = require("./noop-normalize");

},{"./instrumentation":"hCn2q","./noop-normalize":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hCn2q":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationBase", ()=>InstrumentationBase);
var _instrumentation = require("../../instrumentation");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Base abstract class for instrumenting web plugins
 */ var InstrumentationBase = /** @class */ function(_super) {
    __extends(InstrumentationBase, _super);
    function InstrumentationBase(instrumentationName, instrumentationVersion, config) {
        var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
        if (_this._config.enabled) _this.enable();
        return _this;
    }
    return InstrumentationBase;
}((0, _instrumentation.InstrumentationAbstract));

},{"../../instrumentation":"jMsGo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jMsGo":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationAbstract", ()=>InstrumentationAbstract);
var _api = require("@opentelemetry/api");
var _apiLogs = require("@opentelemetry/api-logs");
var _shimmer = require("shimmer");
var __assign = undefined && undefined.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * Base abstract internal class for instrumenting node and web plugins
 */ var InstrumentationAbstract = /** @class */ function() {
    function InstrumentationAbstract(instrumentationName, instrumentationVersion, config) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        this._config = {};
        /* Api to wrap instrumented method */ this._wrap = _shimmer.wrap;
        /* Api to unwrap instrumented methods */ this._unwrap = _shimmer.unwrap;
        /* Api to mass wrap instrumented method */ this._massWrap = _shimmer.massWrap;
        /* Api to mass unwrap instrumented methods */ this._massUnwrap = _shimmer.massUnwrap;
        this.setConfig(config);
        this._diag = (0, _api.diag).createComponentLogger({
            namespace: instrumentationName
        });
        this._tracer = (0, _api.trace).getTracer(instrumentationName, instrumentationVersion);
        this._meter = (0, _api.metrics).getMeter(instrumentationName, instrumentationVersion);
        this._logger = (0, _apiLogs.logs).getLogger(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
    }
    Object.defineProperty(InstrumentationAbstract.prototype, "meter", {
        /* Returns meter */ get: function() {
            return this._meter;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets MeterProvider to this plugin
     * @param meterProvider
     */ InstrumentationAbstract.prototype.setMeterProvider = function(meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
    };
    Object.defineProperty(InstrumentationAbstract.prototype, "logger", {
        /* Returns logger */ get: function() {
            return this._logger;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets LoggerProvider to this plugin
     * @param loggerProvider
     */ InstrumentationAbstract.prototype.setLoggerProvider = function(loggerProvider) {
        this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    };
    /**
     * @experimental
     *
     * Get module definitions defined by {@link init}.
     * This can be used for experimental compile-time instrumentation.
     *
     * @returns an array of {@link InstrumentationModuleDefinition}
     */ InstrumentationAbstract.prototype.getModuleDefinitions = function() {
        var _a;
        var initResult = (_a = this.init()) !== null && _a !== void 0 ? _a : [];
        if (!Array.isArray(initResult)) return [
            initResult
        ];
        return initResult;
    };
    /**
     * Sets the new metric instruments with the current Meter.
     */ InstrumentationAbstract.prototype._updateMetricInstruments = function() {
        return;
    };
    /* Returns InstrumentationConfig */ InstrumentationAbstract.prototype.getConfig = function() {
        return this._config;
    };
    /**
     * Sets InstrumentationConfig to this plugin
     * @param config
     */ InstrumentationAbstract.prototype.setConfig = function(config) {
        // copy config first level properties to ensure they are immutable.
        // nested properties are not copied, thus are mutable from the outside.
        this._config = __assign({
            enabled: true
        }, config);
    };
    /**
     * Sets TraceProvider to this plugin
     * @param tracerProvider
     */ InstrumentationAbstract.prototype.setTracerProvider = function(tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    };
    Object.defineProperty(InstrumentationAbstract.prototype, "tracer", {
        /* Returns tracer */ get: function() {
            return this._tracer;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Execute span customization hook, if configured, and log any errors.
     * Any semantics of the trigger and info are defined by the specific instrumentation.
     * @param hookHandler The optional hook handler which the user has configured via instrumentation config
     * @param triggerName The name of the trigger for executing the hook for logging purposes
     * @param span The span to which the hook should be applied
     * @param info The info object to be passed to the hook, with useful data the hook may use
     */ InstrumentationAbstract.prototype._runSpanCustomizationHook = function(hookHandler, triggerName, span, info) {
        if (!hookHandler) return;
        try {
            hookHandler(span, info);
        } catch (e) {
            this._diag.error("Error running span customization hook due to exception in handler", {
                triggerName: triggerName
            }, e);
        }
    };
    return InstrumentationAbstract;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/api-logs":"8PPAH","shimmer":"kGpxk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kGpxk":[function(require,module,exports,__globalThis) {
'use strict';
function isFunction(funktion) {
    return typeof funktion === 'function';
}
// Default to complaining loudly when things don't go according to plan.
var logger = console.error.bind(console);
// Sets a property on an object, preserving its enumerability.
// This function assumes that the property is already writable.
function defineProperty(obj, name, value) {
    var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
    Object.defineProperty(obj, name, {
        configurable: true,
        enumerable: enumerable,
        writable: true,
        value: value
    });
}
// Keep initialization idempotent.
function shimmer(options) {
    if (options && options.logger) {
        if (!isFunction(options.logger)) logger("new logger isn't a function, not replacing");
        else logger = options.logger;
    }
}
function wrap(nodule, name, wrapper) {
    if (!nodule || !nodule[name]) {
        logger('no original function ' + name + ' to wrap');
        return;
    }
    if (!wrapper) {
        logger('no wrapper function');
        logger(new Error().stack);
        return;
    }
    if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
        logger('original object and wrapper must be functions');
        return;
    }
    var original = nodule[name];
    var wrapped = wrapper(original, name);
    defineProperty(wrapped, '__original', original);
    defineProperty(wrapped, '__unwrap', function() {
        if (nodule[name] === wrapped) defineProperty(nodule, name, original);
    });
    defineProperty(wrapped, '__wrapped', true);
    defineProperty(nodule, name, wrapped);
    return wrapped;
}
function massWrap(nodules, names, wrapper) {
    if (!nodules) {
        logger('must provide one or more modules to patch');
        logger(new Error().stack);
        return;
    } else if (!Array.isArray(nodules)) nodules = [
        nodules
    ];
    if (!(names && Array.isArray(names))) {
        logger('must provide one or more functions to wrap on modules');
        return;
    }
    nodules.forEach(function(nodule) {
        names.forEach(function(name) {
            wrap(nodule, name, wrapper);
        });
    });
}
function unwrap(nodule, name) {
    if (!nodule || !nodule[name]) {
        logger('no function to unwrap.');
        logger(new Error().stack);
        return;
    }
    if (!nodule[name].__unwrap) logger('no original to unwrap to -- has ' + name + ' already been unwrapped?');
    else return nodule[name].__unwrap();
}
function massUnwrap(nodules, names) {
    if (!nodules) {
        logger('must provide one or more modules to patch');
        logger(new Error().stack);
        return;
    } else if (!Array.isArray(nodules)) nodules = [
        nodules
    ];
    if (!(names && Array.isArray(names))) {
        logger('must provide one or more functions to unwrap on modules');
        return;
    }
    nodules.forEach(function(nodule) {
        names.forEach(function(name) {
            unwrap(nodule, name);
        });
    });
}
shimmer.wrap = wrap;
shimmer.massWrap = massWrap;
shimmer.unwrap = unwrap;
shimmer.massUnwrap = massUnwrap;
module.exports = shimmer;

},{}],"3YarC":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * function to execute patched function and being able to catch errors
 * @param execute - function to be executed
 * @param onFinish - callback to run when execute finishes
 */ parcelHelpers.export(exports, "safeExecuteInTheMiddle", ()=>safeExecuteInTheMiddle);
/**
 * Async function to execute patched function and being able to catch errors
 * @param execute - function to be executed
 * @param onFinish - callback to run when execute finishes
 */ parcelHelpers.export(exports, "safeExecuteInTheMiddleAsync", ()=>safeExecuteInTheMiddleAsync);
/**
 * Checks if certain function has been already wrapped
 * @param func
 */ parcelHelpers.export(exports, "isWrapped", ()=>isWrapped);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    var error;
    var result;
    try {
        result = execute();
    } catch (e) {
        error = e;
    } finally{
        onFinish(error, result);
        if (error && !preventThrowingError) // eslint-disable-next-line no-unsafe-finally
        throw error;
        // eslint-disable-next-line no-unsafe-finally
        return result;
    }
}
function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    return __awaiter(this, void 0, void 0, function() {
        var error, result, e_1;
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    _a.trys.push([
                        0,
                        2,
                        3,
                        4
                    ]);
                    return [
                        4 /*yield*/ ,
                        execute()
                    ];
                case 1:
                    result = _a.sent();
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 2:
                    e_1 = _a.sent();
                    error = e_1;
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 3:
                    onFinish(error, result);
                    if (error && !preventThrowingError) // eslint-disable-next-line no-unsafe-finally
                    throw error;
                    // eslint-disable-next-line no-unsafe-finally
                    return [
                        2 /*return*/ ,
                        result
                    ];
                case 4:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
function isWrapped(func) {
    return typeof func === 'function' && typeof func.__original === 'function' && typeof func.__unwrap === 'function' && func.__wrapped === true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2uTf8":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AttributeNames", ()=>AttributeNames);
var AttributeNames;
(function(AttributeNames) {
    AttributeNames["DOCUMENT_LOAD"] = "documentLoad";
    AttributeNames["DOCUMENT_FETCH"] = "documentFetch";
    AttributeNames["RESOURCE_FETCH"] = "resourceFetch";
})(AttributeNames || (AttributeNames = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kjKSa":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // this is autogenerated file, see scripts/version-update.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PACKAGE_VERSION", ()=>PACKAGE_VERSION);
parcelHelpers.export(exports, "PACKAGE_NAME", ()=>PACKAGE_NAME);
var PACKAGE_VERSION = '0.42.0';
var PACKAGE_NAME = '@opentelemetry/instrumentation-document-load';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hRpx5":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getPerformanceNavigationEntries", ()=>getPerformanceNavigationEntries);
parcelHelpers.export(exports, "addSpanPerformancePaintEvents", ()=>addSpanPerformancePaintEvents);
var _core = require("@opentelemetry/core");
var _sdkTraceWeb = require("@opentelemetry/sdk-trace-web");
var _eventNames = require("./enums/EventNames");
var getPerformanceNavigationEntries = function() {
    var _a, _b;
    var entries = {};
    var performanceNavigationTiming = (_b = (_a = (0, _core.otperformance)).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a, 'navigation')[0];
    if (performanceNavigationTiming) {
        var keys = Object.values((0, _sdkTraceWeb.PerformanceTimingNames));
        keys.forEach(function(key) {
            if ((0, _sdkTraceWeb.hasKey)(performanceNavigationTiming, key)) {
                var value = performanceNavigationTiming[key];
                if (typeof value === 'number') entries[key] = value;
            }
        });
    } else {
        // // fallback to previous version
        var perf = (0, _core.otperformance);
        var performanceTiming_1 = perf.timing;
        if (performanceTiming_1) {
            var keys = Object.values((0, _sdkTraceWeb.PerformanceTimingNames));
            keys.forEach(function(key) {
                if ((0, _sdkTraceWeb.hasKey)(performanceTiming_1, key)) {
                    var value = performanceTiming_1[key];
                    if (typeof value === 'number') entries[key] = value;
                }
            });
        }
    }
    return entries;
};
var performancePaintNames = {
    'first-paint': (0, _eventNames.EventNames).FIRST_PAINT,
    'first-contentful-paint': (0, _eventNames.EventNames).FIRST_CONTENTFUL_PAINT
};
var addSpanPerformancePaintEvents = function(span) {
    var _a, _b;
    var performancePaintTiming = (_b = (_a = (0, _core.otperformance)).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a, 'paint');
    if (performancePaintTiming) performancePaintTiming.forEach(function(_a) {
        var name = _a.name, startTime = _a.startTime;
        if ((0, _sdkTraceWeb.hasKey)(performancePaintNames, name)) span.addEvent(performancePaintNames[name], startTime);
    });
};

},{"@opentelemetry/core":"dBsXh","@opentelemetry/sdk-trace-web":"eXZZL","./enums/EventNames":"kWXpn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kWXpn":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EventNames", ()=>EventNames);
var EventNames;
(function(EventNames) {
    EventNames["FIRST_PAINT"] = "firstPaint";
    EventNames["FIRST_CONTENTFUL_PAINT"] = "firstContentfulPaint";
})(EventNames || (EventNames = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cOeU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmUfS":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZoneContextManager", ()=>(0, _contextZonePeerDep.ZoneContextManager));
var _contextZonePeerDep = require("@opentelemetry/context-zone-peer-dep");
var _zoneJs = require("zone.js");

},{"@opentelemetry/context-zone-peer-dep":"lln3o","zone.js":"9REDz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lln3o":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZoneContextManager", ()=>(0, _zoneContextManager.ZoneContextManager));
var _zoneContextManager = require("./ZoneContextManager");

},{"./ZoneContextManager":"la9bE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"la9bE":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /// <reference types="zone.js" />
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZoneContextManager", ()=>ZoneContextManager);
var _api = require("@opentelemetry/api");
var _util = require("./util");
/* Key name to be used to save a context reference in Zone */ var ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';
/**
 * ZoneContextManager
 * This module provides an easy functionality for tracing action between asynchronous operations in web.
 * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.
 * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.
 * It stores the information about context in zone. Each Context will have always new Zone;
 * It also supports binding a certain Span to a target that has "addEventListener" and "removeEventListener".
 * When this happens a new zone is being created and the provided Span is being assigned to this zone.
 */ var ZoneContextManager = /** @class */ function() {
    function ZoneContextManager() {
        /**
         * whether the context manager is enabled or not
         */ this._enabled = false;
        /**
         * Helps to create a unique name for the zones - part of zone name
         */ this._zoneCounter = 0;
    }
    /**
     * Returns the active context from certain zone name
     * @param activeZone
     */ ZoneContextManager.prototype._activeContextFromZone = function(activeZone) {
        return activeZone && activeZone.get(ZONE_CONTEXT_KEY) || (0, _api.ROOT_CONTEXT);
    };
    /**
     * @param context A context (span) to be executed within target function
     * @param target Function to be executed within the context
     */ // eslint-disable-next-line @typescript-eslint/ban-types
    ZoneContextManager.prototype._bindFunction = function(context, target) {
        var manager = this;
        var contextWrapper = function() {
            var _this = this;
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
            return manager.with(context, function() {
                return target.apply(_this, args);
            });
        };
        Object.defineProperty(contextWrapper, 'length', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: target.length
        });
        return contextWrapper;
    };
    /**
     * @param context A context (span) to be bind to target
     * @param obj target object on which the listeners will be patched
     */ ZoneContextManager.prototype._bindListener = function(context, obj) {
        var target = obj;
        if (target.__ot_listeners !== undefined) return obj;
        target.__ot_listeners = {};
        if (typeof target.addEventListener === 'function') target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);
        if (typeof target.removeEventListener === 'function') target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);
        return obj;
    };
    /**
     * Creates a new unique zone name
     */ ZoneContextManager.prototype._createZoneName = function() {
        this._zoneCounter++;
        var random = Math.random();
        return this._zoneCounter + "-" + random;
    };
    /**
     * Creates a new zone
     * @param zoneName zone name
     * @param context A context (span) to be bind with Zone
     */ ZoneContextManager.prototype._createZone = function(zoneName, context) {
        var _a;
        return Zone.current.fork({
            name: zoneName,
            properties: (_a = {}, _a[ZONE_CONTEXT_KEY] = context, _a)
        });
    };
    /**
     * Returns the active zone
     */ ZoneContextManager.prototype._getActiveZone = function() {
        return Zone.current;
    };
    /**
     * Patches addEventListener method
     * @param target any target that has "addEventListener" method
     * @param original reference to the patched method
     * @param [context] context to be bind to the listener
     */ ZoneContextManager.prototype._patchAddEventListener = function(target, original, context) {
        var contextManager = this;
        return function(event, listener, opts) {
            if (target.__ot_listeners === undefined) target.__ot_listeners = {};
            var listeners = target.__ot_listeners[event];
            if (listeners === undefined) {
                listeners = new WeakMap();
                target.__ot_listeners[event] = listeners;
            }
            var patchedListener = contextManager.bind(context, listener);
            // store a weak reference of the user listener to ours
            listeners.set(listener, patchedListener);
            return original.call(this, event, patchedListener, opts);
        };
    };
    /**
     * Patches removeEventListener method
     * @param target any target that has "removeEventListener" method
     * @param original reference to the patched method
     */ ZoneContextManager.prototype._patchRemoveEventListener = function(target, original) {
        return function(event, listener) {
            if (target.__ot_listeners === undefined || target.__ot_listeners[event] === undefined) return original.call(this, event, listener);
            var events = target.__ot_listeners[event];
            var patchedListener = events.get(listener);
            events.delete(listener);
            return original.call(this, event, patchedListener || listener);
        };
    };
    /**
     * Returns the active context
     */ ZoneContextManager.prototype.active = function() {
        if (!this._enabled) return 0, _api.ROOT_CONTEXT;
        var activeZone = this._getActiveZone();
        var active = this._activeContextFromZone(activeZone);
        if (active) return active;
        return 0, _api.ROOT_CONTEXT;
    };
    /**
     * Binds a the certain context or the active one to the target function and then returns the target
     * @param context A context (span) to be bind to target
     * @param target a function or event emitter. When target or one of its callbacks is called,
     *  the provided context will be used as the active context for the duration of the call.
     */ ZoneContextManager.prototype.bind = function(context, target) {
        // if no specific context to propagate is given, we use the current one
        if (context === undefined) context = this.active();
        if (typeof target === 'function') return this._bindFunction(context, target);
        else if ((0, _util.isListenerObject)(target)) this._bindListener(context, target);
        return target;
    };
    /**
     * Disable the context manager (clears all the contexts)
     */ ZoneContextManager.prototype.disable = function() {
        this._enabled = false;
        return this;
    };
    /**
     * Enables the context manager and creates a default(root) context
     */ ZoneContextManager.prototype.enable = function() {
        this._enabled = true;
        return this;
    };
    /**
     * Calls the callback function [fn] with the provided [context].
     *     If [context] is undefined then it will use the active context.
     *     The context will be set as active
     * @param context A context (span) to be called with provided callback
     * @param fn Callback function
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */ ZoneContextManager.prototype.with = function(context, fn, thisArg) {
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++)args[_i - 3] = arguments[_i];
        var zoneName = this._createZoneName();
        var newZone = this._createZone(zoneName, context);
        return newZone.run(fn, thisArg, args);
    };
    return ZoneContextManager;
}();

},{"@opentelemetry/api":"6AC4z","./util":"5r8zZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5r8zZ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * check if an object has addEventListener and removeEventListener functions then it will return true.
 * Generally only called with a `TargetWithEvents` but may be called with an unknown / any.
 * @param obj - The object to check.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isListenerObject", ()=>isListenerObject);
function isListenerObject(obj) {
    if (obj === void 0) obj = {};
    return typeof obj.addEventListener === 'function' && typeof obj.removeEventListener === 'function';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9REDz":[function(require,module,exports,__globalThis) {
'use strict';
/**
 * @license Angular v<unknown>
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */ const global = globalThis;
// __Zone_symbol_prefix global can be used to override the default zone
// symbol prefix with a custom one if needed.
function __symbol__(name) {
    const symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';
    return symbolPrefix + name;
}
function initZone() {
    const performance = global['performance'];
    function mark(name) {
        performance && performance['mark'] && performance['mark'](name);
    }
    function performanceMeasure(name, label) {
        performance && performance['measure'] && performance['measure'](name, label);
    }
    mark('Zone');
    class ZoneImpl {
        // tslint:disable-next-line:require-internal-with-underscore
        static{
            this.__symbol__ = __symbol__;
        }
        static assertZonePatched() {
            if (global['Promise'] !== patches['ZoneAwarePromise']) throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)");
        }
        static get root() {
            let zone = ZoneImpl.current;
            while(zone.parent)zone = zone.parent;
            return zone;
        }
        static get current() {
            return _currentZoneFrame.zone;
        }
        static get currentTask() {
            return _currentTask;
        }
        // tslint:disable-next-line:require-internal-with-underscore
        static __load_patch(name, fn, ignoreDuplicate = false) {
            if (patches.hasOwnProperty(name)) {
                // `checkDuplicate` option is defined from global variable
                // so it works for all modules.
                // `ignoreDuplicate` can work for the specified module
                const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;
                if (!ignoreDuplicate && checkDuplicate) throw Error('Already loaded patch: ' + name);
            } else if (!global['__Zone_disable_' + name]) {
                const perfName = 'Zone:' + name;
                mark(perfName);
                patches[name] = fn(global, ZoneImpl, _api);
                performanceMeasure(perfName, perfName);
            }
        }
        get parent() {
            return this._parent;
        }
        get name() {
            return this._name;
        }
        constructor(parent, zoneSpec){
            this._parent = parent;
            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
            this._properties = zoneSpec && zoneSpec.properties || {};
            this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
        }
        get(key) {
            const zone = this.getZoneWith(key);
            if (zone) return zone._properties[key];
        }
        getZoneWith(key) {
            let current = this;
            while(current){
                if (current._properties.hasOwnProperty(key)) return current;
                current = current._parent;
            }
            return null;
        }
        fork(zoneSpec) {
            if (!zoneSpec) throw new Error('ZoneSpec required!');
            return this._zoneDelegate.fork(this, zoneSpec);
        }
        wrap(callback, source) {
            if (typeof callback !== 'function') throw new Error('Expecting function got: ' + callback);
            const _callback = this._zoneDelegate.intercept(this, callback, source);
            const zone = this;
            return function() {
                return zone.runGuarded(_callback, this, arguments, source);
            };
        }
        run(callback, applyThis, applyArgs, source) {
            _currentZoneFrame = {
                parent: _currentZoneFrame,
                zone: this
            };
            try {
                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
            } finally{
                _currentZoneFrame = _currentZoneFrame.parent;
            }
        }
        runGuarded(callback, applyThis = null, applyArgs, source) {
            _currentZoneFrame = {
                parent: _currentZoneFrame,
                zone: this
            };
            try {
                try {
                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
                } catch (error) {
                    if (this._zoneDelegate.handleError(this, error)) throw error;
                }
            } finally{
                _currentZoneFrame = _currentZoneFrame.parent;
            }
        }
        runTask(task, applyThis, applyArgs) {
            if (task.zone != this) throw new Error('A task can only be run in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
            const zoneTask = task;
            // https://github.com/angular/zone.js/issues/778, sometimes eventTask
            // will run in notScheduled(canceled) state, we should not try to
            // run such kind of task but just return
            const { type, data: { isPeriodic = false, isRefreshable = false } = {} } = task;
            if (task.state === notScheduled && (type === eventTask || type === macroTask)) return;
            const reEntryGuard = task.state != running;
            reEntryGuard && zoneTask._transitionTo(running, scheduled);
            const previousTask = _currentTask;
            _currentTask = zoneTask;
            _currentZoneFrame = {
                parent: _currentZoneFrame,
                zone: this
            };
            try {
                if (type == macroTask && task.data && !isPeriodic && !isRefreshable) task.cancelFn = undefined;
                try {
                    return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);
                } catch (error) {
                    if (this._zoneDelegate.handleError(this, error)) throw error;
                }
            } finally{
                // if the task's state is notScheduled or unknown, then it has already been cancelled
                // we should not reset the state to scheduled
                const state = task.state;
                if (state !== notScheduled && state !== unknown) {
                    if (type == eventTask || isPeriodic || isRefreshable && state === scheduling) reEntryGuard && zoneTask._transitionTo(scheduled, running, scheduling);
                    else {
                        const zoneDelegates = zoneTask._zoneDelegates;
                        this._updateTaskCount(zoneTask, -1);
                        reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);
                        if (isRefreshable) zoneTask._zoneDelegates = zoneDelegates;
                    }
                }
                _currentZoneFrame = _currentZoneFrame.parent;
                _currentTask = previousTask;
            }
        }
        scheduleTask(task) {
            if (task.zone && task.zone !== this) {
                // check if the task was rescheduled, the newZone
                // should not be the children of the original zone
                let newZone = this;
                while(newZone){
                    if (newZone === task.zone) throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);
                    newZone = newZone.parent;
                }
            }
            task._transitionTo(scheduling, notScheduled);
            const zoneDelegates = [];
            task._zoneDelegates = zoneDelegates;
            task._zone = this;
            try {
                task = this._zoneDelegate.scheduleTask(this, task);
            } catch (err) {
                // should set task's state to unknown when scheduleTask throw error
                // because the err may from reschedule, so the fromState maybe notScheduled
                task._transitionTo(unknown, scheduling, notScheduled);
                // TODO: @JiaLiPassion, should we check the result from handleError?
                this._zoneDelegate.handleError(this, err);
                throw err;
            }
            if (task._zoneDelegates === zoneDelegates) // we have to check because internally the delegate can reschedule the task.
            this._updateTaskCount(task, 1);
            if (task.state == scheduling) task._transitionTo(scheduled, scheduling);
            return task;
        }
        scheduleMicroTask(source, callback, data, customSchedule) {
            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));
        }
        scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
        }
        scheduleEventTask(source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
        }
        cancelTask(task) {
            if (task.zone != this) throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
            if (task.state !== scheduled && task.state !== running) return;
            task._transitionTo(canceling, scheduled, running);
            try {
                this._zoneDelegate.cancelTask(this, task);
            } catch (err) {
                // if error occurs when cancelTask, transit the state to unknown
                task._transitionTo(unknown, canceling);
                this._zoneDelegate.handleError(this, err);
                throw err;
            }
            this._updateTaskCount(task, -1);
            task._transitionTo(notScheduled, canceling);
            task.runCount = -1;
            return task;
        }
        _updateTaskCount(task, count) {
            const zoneDelegates = task._zoneDelegates;
            if (count == -1) task._zoneDelegates = null;
            for(let i = 0; i < zoneDelegates.length; i++)zoneDelegates[i]._updateTaskCount(task.type, count);
        }
    }
    const DELEGATE_ZS = {
        name: '',
        onHasTask: (delegate, _, target, hasTaskState)=>delegate.hasTask(target, hasTaskState),
        onScheduleTask: (delegate, _, target, task)=>delegate.scheduleTask(target, task),
        onInvokeTask: (delegate, _, target, task, applyThis, applyArgs)=>delegate.invokeTask(target, task, applyThis, applyArgs),
        onCancelTask: (delegate, _, target, task)=>delegate.cancelTask(target, task)
    };
    class _ZoneDelegate {
        get zone() {
            return this._zone;
        }
        constructor(zone, parentDelegate, zoneSpec){
            this._taskCounts = {
                'microTask': 0,
                'macroTask': 0,
                'eventTask': 0
            };
            this._zone = zone;
            this._parentDelegate = parentDelegate;
            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);
            this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
            this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
            this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);
            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
            this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);
            this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
            this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
            this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);
            this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
            this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
            this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);
            this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
            this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
            this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);
            this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
            this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
            this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);
            this._hasTaskZS = null;
            this._hasTaskDlgt = null;
            this._hasTaskDlgtOwner = null;
            this._hasTaskCurrZone = null;
            const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
            const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
            if (zoneSpecHasTask || parentHasTask) {
                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such
                // a case all task related interceptors must go through this ZD. We can't short circuit it.
                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
                this._hasTaskDlgt = parentDelegate;
                this._hasTaskDlgtOwner = this;
                this._hasTaskCurrZone = this._zone;
                if (!zoneSpec.onScheduleTask) {
                    this._scheduleTaskZS = DELEGATE_ZS;
                    this._scheduleTaskDlgt = parentDelegate;
                    this._scheduleTaskCurrZone = this._zone;
                }
                if (!zoneSpec.onInvokeTask) {
                    this._invokeTaskZS = DELEGATE_ZS;
                    this._invokeTaskDlgt = parentDelegate;
                    this._invokeTaskCurrZone = this._zone;
                }
                if (!zoneSpec.onCancelTask) {
                    this._cancelTaskZS = DELEGATE_ZS;
                    this._cancelTaskDlgt = parentDelegate;
                    this._cancelTaskCurrZone = this._zone;
                }
            }
        }
        fork(targetZone, zoneSpec) {
            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new ZoneImpl(targetZone, zoneSpec);
        }
        intercept(targetZone, callback, source) {
            return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
        }
        invoke(targetZone, callback, applyThis, applyArgs, source) {
            return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
        }
        handleError(targetZone, error) {
            return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
        }
        scheduleTask(targetZone, task) {
            let returnTask = task;
            if (this._scheduleTaskZS) {
                if (this._hasTaskZS) returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
                if (!returnTask) returnTask = task;
            } else {
                if (task.scheduleFn) task.scheduleFn(task);
                else if (task.type == microTask) scheduleMicroTask(task);
                else throw new Error('Task is missing scheduleFn.');
            }
            return returnTask;
        }
        invokeTask(targetZone, task, applyThis, applyArgs) {
            return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
        }
        cancelTask(targetZone, task) {
            let value;
            if (this._cancelTaskZS) value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
            else {
                if (!task.cancelFn) throw Error('Task is not cancelable');
                value = task.cancelFn(task);
            }
            return value;
        }
        hasTask(targetZone, isEmpty) {
            // hasTask should not throw error so other ZoneDelegate
            // can still trigger hasTask callback
            try {
                this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
            } catch (err) {
                this.handleError(targetZone, err);
            }
        }
        // tslint:disable-next-line:require-internal-with-underscore
        _updateTaskCount(type, count) {
            const counts = this._taskCounts;
            const prev = counts[type];
            const next = counts[type] = prev + count;
            if (next < 0) throw new Error('More tasks executed then were scheduled.');
            if (prev == 0 || next == 0) {
                const isEmpty = {
                    microTask: counts['microTask'] > 0,
                    macroTask: counts['macroTask'] > 0,
                    eventTask: counts['eventTask'] > 0,
                    change: type
                };
                this.hasTask(this._zone, isEmpty);
            }
        }
    }
    class ZoneTask {
        constructor(type, source, callback, options, scheduleFn, cancelFn){
            // tslint:disable-next-line:require-internal-with-underscore
            this._zone = null;
            this.runCount = 0;
            // tslint:disable-next-line:require-internal-with-underscore
            this._zoneDelegates = null;
            // tslint:disable-next-line:require-internal-with-underscore
            this._state = 'notScheduled';
            this.type = type;
            this.source = source;
            this.data = options;
            this.scheduleFn = scheduleFn;
            this.cancelFn = cancelFn;
            if (!callback) throw new Error('callback is not defined');
            this.callback = callback;
            const self1 = this;
            // TODO: @JiaLiPassion options should have interface
            if (type === eventTask && options && options.useG) this.invoke = ZoneTask.invokeTask;
            else this.invoke = function() {
                return ZoneTask.invokeTask.call(global, self1, this, arguments);
            };
        }
        static invokeTask(task, target, args) {
            if (!task) task = this;
            _numberOfNestedTaskFrames++;
            try {
                task.runCount++;
                return task.zone.runTask(task, target, args);
            } finally{
                if (_numberOfNestedTaskFrames == 1) drainMicroTaskQueue();
                _numberOfNestedTaskFrames--;
            }
        }
        get zone() {
            return this._zone;
        }
        get state() {
            return this._state;
        }
        cancelScheduleRequest() {
            this._transitionTo(notScheduled, scheduling);
        }
        // tslint:disable-next-line:require-internal-with-underscore
        _transitionTo(toState, fromState1, fromState2) {
            if (this._state === fromState1 || this._state === fromState2) {
                this._state = toState;
                if (toState == notScheduled) this._zoneDelegates = null;
            } else throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? " or '" + fromState2 + "'" : ''}, was '${this._state}'.`);
        }
        toString() {
            if (this.data && typeof this.data.handleId !== 'undefined') return this.data.handleId.toString();
            else return Object.prototype.toString.call(this);
        }
        // add toJSON method to prevent cyclic error when
        // call JSON.stringify(zoneTask)
        toJSON() {
            return {
                type: this.type,
                state: this.state,
                source: this.source,
                zone: this.zone.name,
                runCount: this.runCount
            };
        }
    }
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    ///  MICROTASK QUEUE
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    const symbolSetTimeout = __symbol__('setTimeout');
    const symbolPromise = __symbol__('Promise');
    const symbolThen = __symbol__('then');
    let _microTaskQueue = [];
    let _isDrainingMicrotaskQueue = false;
    let nativeMicroTaskQueuePromise;
    function nativeScheduleMicroTask(func) {
        if (!nativeMicroTaskQueuePromise) {
            if (global[symbolPromise]) nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);
        }
        if (nativeMicroTaskQueuePromise) {
            let nativeThen = nativeMicroTaskQueuePromise[symbolThen];
            if (!nativeThen) // native Promise is not patchable, we need to use `then` directly
            // issue 1078
            nativeThen = nativeMicroTaskQueuePromise['then'];
            nativeThen.call(nativeMicroTaskQueuePromise, func);
        } else global[symbolSetTimeout](func, 0);
    }
    function scheduleMicroTask(task) {
        // if we are not running in any task, and there has not been anything scheduled
        // we must bootstrap the initial task creation by manually scheduling the drain
        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) // We are not running in Task, so we need to kickstart the microtask queue.
        nativeScheduleMicroTask(drainMicroTaskQueue);
        task && _microTaskQueue.push(task);
    }
    function drainMicroTaskQueue() {
        if (!_isDrainingMicrotaskQueue) {
            _isDrainingMicrotaskQueue = true;
            while(_microTaskQueue.length){
                const queue = _microTaskQueue;
                _microTaskQueue = [];
                for(let i = 0; i < queue.length; i++){
                    const task = queue[i];
                    try {
                        task.zone.runTask(task, null, null);
                    } catch (error) {
                        _api.onUnhandledError(error);
                    }
                }
            }
            _api.microtaskDrainDone();
            _isDrainingMicrotaskQueue = false;
        }
    }
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    ///  BOOTSTRAP
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    const NO_ZONE = {
        name: 'NO ZONE'
    };
    const notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';
    const microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';
    const patches = {};
    const _api = {
        symbol: __symbol__,
        currentZoneFrame: ()=>_currentZoneFrame,
        onUnhandledError: noop,
        microtaskDrainDone: noop,
        scheduleMicroTask: scheduleMicroTask,
        showUncaughtError: ()=>!ZoneImpl[__symbol__('ignoreConsoleErrorUncaughtError')],
        patchEventTarget: ()=>[],
        patchOnProperties: noop,
        patchMethod: ()=>noop,
        bindArguments: ()=>[],
        patchThen: ()=>noop,
        patchMacroTask: ()=>noop,
        patchEventPrototype: ()=>noop,
        isIEOrEdge: ()=>false,
        getGlobalObjects: ()=>undefined,
        ObjectDefineProperty: ()=>noop,
        ObjectGetOwnPropertyDescriptor: ()=>undefined,
        ObjectCreate: ()=>undefined,
        ArraySlice: ()=>[],
        patchClass: ()=>noop,
        wrapWithCurrentZone: ()=>noop,
        filterProperties: ()=>[],
        attachOriginToPatched: ()=>noop,
        _redefineProperty: ()=>noop,
        patchCallbacks: ()=>noop,
        nativeScheduleMicroTask: nativeScheduleMicroTask
    };
    let _currentZoneFrame = {
        parent: null,
        zone: new ZoneImpl(null, null)
    };
    let _currentTask = null;
    let _numberOfNestedTaskFrames = 0;
    function noop() {}
    performanceMeasure('Zone', 'Zone');
    return ZoneImpl;
}
function loadZone() {
    // if global['Zone'] already exists (maybe zone.js was already loaded or
    // some other lib also registered a global object named Zone), we may need
    // to throw an error, but sometimes user may not want this error.
    // For example,
    // we have two web pages, page1 includes zone.js, page2 doesn't.
    // and the 1st time user load page1 and page2, everything work fine,
    // but when user load page2 again, error occurs because global['Zone'] already exists.
    // so we add a flag to let user choose whether to throw this error or not.
    // By default, if existing Zone is from zone.js, we will not throw the error.
    const global = globalThis;
    const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;
    if (global['Zone'] && (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function')) throw new Error('Zone already loaded.');
    // Initialize global `Zone` constant.
    global['Zone'] ??= initZone();
    return global['Zone'];
}
/**
 * Suppress closure compiler errors about unknown 'Zone' variable
 * @fileoverview
 * @suppress {undefinedVars,globalThis,missingRequire}
 */ // issue #989, to reduce bundle size, use short name
/** Object.getOwnPropertyDescriptor */ const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
/** Object.defineProperty */ const ObjectDefineProperty = Object.defineProperty;
/** Object.getPrototypeOf */ const ObjectGetPrototypeOf = Object.getPrototypeOf;
/** Object.create */ const ObjectCreate = Object.create;
/** Array.prototype.slice */ const ArraySlice = Array.prototype.slice;
/** addEventListener string const */ const ADD_EVENT_LISTENER_STR = 'addEventListener';
/** removeEventListener string const */ const REMOVE_EVENT_LISTENER_STR = 'removeEventListener';
/** zoneSymbol addEventListener */ const ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);
/** zoneSymbol removeEventListener */ const ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);
/** true string const */ const TRUE_STR = 'true';
/** false string const */ const FALSE_STR = 'false';
/** Zone symbol prefix string const. */ const ZONE_SYMBOL_PREFIX = __symbol__('');
function wrapWithCurrentZone(callback, source) {
    return Zone.current.wrap(callback, source);
}
function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
}
const zoneSymbol = __symbol__;
const isWindowExists = typeof window !== 'undefined';
const internalWindow = isWindowExists ? window : undefined;
const _global = isWindowExists && internalWindow || globalThis;
const REMOVE_ATTRIBUTE = 'removeAttribute';
function bindArguments(args, source) {
    for(let i = args.length - 1; i >= 0; i--)if (typeof args[i] === 'function') args[i] = wrapWithCurrentZone(args[i], source + '_' + i);
    return args;
}
function patchPrototype(prototype, fnNames) {
    const source = prototype.constructor['name'];
    for(let i = 0; i < fnNames.length; i++){
        const name = fnNames[i];
        const delegate = prototype[name];
        if (delegate) {
            const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);
            if (!isPropertyWritable(prototypeDesc)) continue;
            prototype[name] = ((delegate)=>{
                const patched = function() {
                    return delegate.apply(this, bindArguments(arguments, source + '.' + name));
                };
                attachOriginToPatched(patched, delegate);
                return patched;
            })(delegate);
        }
    }
}
function isPropertyWritable(propertyDesc) {
    if (!propertyDesc) return true;
    if (propertyDesc.writable === false) return false;
    return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');
}
const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
// this code.
const isNode = !('nw' in _global) && typeof _global.process !== 'undefined' && _global.process.toString() === '[object process]';
const isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);
// we are in electron of nw, so we are both browser and nodejs
// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
// this code.
const isMix = typeof _global.process !== 'undefined' && _global.process.toString() === '[object process]' && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);
const zoneSymbolEventNames$1 = {};
const enableBeforeunloadSymbol = zoneSymbol('enable_beforeunload');
const wrapFn = function(event) {
    // https://github.com/angular/zone.js/issues/911, in IE, sometimes
    // event will be undefined, so we need to use window.event
    event = event || _global.event;
    if (!event) return;
    let eventNameSymbol = zoneSymbolEventNames$1[event.type];
    if (!eventNameSymbol) eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol('ON_PROPERTY' + event.type);
    const target = this || event.target || _global;
    const listener = target[eventNameSymbol];
    let result;
    if (isBrowser && target === internalWindow && event.type === 'error') {
        // window.onerror have different signature
        // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror
        // and onerror callback will prevent default when callback return true
        const errorEvent = event;
        result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
        if (result === true) event.preventDefault();
    } else {
        result = listener && listener.apply(this, arguments);
        if (// https://github.com/angular/angular/issues/47579
        // https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent
        // This is the only specific case we should check for. The spec defines that the
        // `returnValue` attribute represents the message to show the user. When the event
        // is created, this attribute must be set to the empty string.
        event.type === 'beforeunload' && // To prevent any breaking changes resulting from this change, given that
        // it was already causing a significant number of failures in G3, we have hidden
        // that behavior behind a global configuration flag. Consumers can enable this
        // flag explicitly if they want the `beforeunload` event to be handled as defined
        // in the specification.
        _global[enableBeforeunloadSymbol] && // The IDL event definition is `attribute DOMString returnValue`, so we check whether
        // `typeof result` is a string.
        typeof result === 'string') event.returnValue = result;
        else if (result != undefined && !result) event.preventDefault();
    }
    return result;
};
function patchProperty(obj, prop, prototype) {
    let desc = ObjectGetOwnPropertyDescriptor(obj, prop);
    if (!desc && prototype) {
        // when patch window object, use prototype to check prop exist or not
        const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
        if (prototypeDesc) desc = {
            enumerable: true,
            configurable: true
        };
    }
    // if the descriptor not exists or is not configurable
    // just return
    if (!desc || !desc.configurable) return;
    const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');
    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) return;
    // A property descriptor cannot have getter/setter and be writable
    // deleting the writable and value properties avoids this error:
    //
    // TypeError: property descriptors must not specify a value or be writable when a
    // getter or setter has been specified
    delete desc.writable;
    delete desc.value;
    const originalDescGet = desc.get;
    const originalDescSet = desc.set;
    // slice(2) cuz 'onclick' -> 'click', etc
    const eventName = prop.slice(2);
    let eventNameSymbol = zoneSymbolEventNames$1[eventName];
    if (!eventNameSymbol) eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol('ON_PROPERTY' + eventName);
    desc.set = function(newValue) {
        // in some of windows's onproperty callback, this is undefined
        // so we need to check it
        let target = this;
        if (!target && obj === _global) target = _global;
        if (!target) return;
        const previousValue = target[eventNameSymbol];
        if (typeof previousValue === 'function') target.removeEventListener(eventName, wrapFn);
        // issue #978, when onload handler was added before loading zone.js
        // we should remove it with originalDescSet
        originalDescSet && originalDescSet.call(target, null);
        target[eventNameSymbol] = newValue;
        if (typeof newValue === 'function') target.addEventListener(eventName, wrapFn, false);
    };
    // The getter would return undefined for unassigned properties but the default value of an
    // unassigned property is null
    desc.get = function() {
        // in some of windows's onproperty callback, this is undefined
        // so we need to check it
        let target = this;
        if (!target && obj === _global) target = _global;
        if (!target) return null;
        const listener = target[eventNameSymbol];
        if (listener) return listener;
        else if (originalDescGet) {
            // result will be null when use inline event attribute,
            // such as <button onclick="func();">OK</button>
            // because the onclick function is internal raw uncompiled handler
            // the onclick will be evaluated when first time event was triggered or
            // the property is accessed, https://github.com/angular/zone.js/issues/525
            // so we should use original native get to retrieve the handler
            let value = originalDescGet.call(this);
            if (value) {
                desc.set.call(this, value);
                if (typeof target[REMOVE_ATTRIBUTE] === 'function') target.removeAttribute(prop);
                return value;
            }
        }
        return null;
    };
    ObjectDefineProperty(obj, prop, desc);
    obj[onPropPatchedSymbol] = true;
}
function patchOnProperties(obj, properties, prototype) {
    if (properties) for(let i = 0; i < properties.length; i++)patchProperty(obj, 'on' + properties[i], prototype);
    else {
        const onProperties = [];
        for(const prop in obj)if (prop.slice(0, 2) == 'on') onProperties.push(prop);
        for(let j = 0; j < onProperties.length; j++)patchProperty(obj, onProperties[j], prototype);
    }
}
const originalInstanceKey = zoneSymbol('originalInstance');
// wrap some native API on `window`
function patchClass(className) {
    const OriginalClass = _global[className];
    if (!OriginalClass) return;
    // keep original class in global
    _global[zoneSymbol(className)] = OriginalClass;
    _global[className] = function() {
        const a = bindArguments(arguments, className);
        switch(a.length){
            case 0:
                this[originalInstanceKey] = new OriginalClass();
                break;
            case 1:
                this[originalInstanceKey] = new OriginalClass(a[0]);
                break;
            case 2:
                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
                break;
            case 3:
                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
                break;
            case 4:
                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
                break;
            default:
                throw new Error('Arg list too long.');
        }
    };
    // attach original delegate to patched function
    attachOriginToPatched(_global[className], OriginalClass);
    const instance = new OriginalClass(function() {});
    let prop;
    for(prop in instance){
        // https://bugs.webkit.org/show_bug.cgi?id=44721
        if (className === 'XMLHttpRequest' && prop === 'responseBlob') continue;
        (function(prop) {
            if (typeof instance[prop] === 'function') _global[className].prototype[prop] = function() {
                return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
            };
            else ObjectDefineProperty(_global[className].prototype, prop, {
                set: function(fn) {
                    if (typeof fn === 'function') {
                        this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop);
                        // keep callback in wrapped function so we can
                        // use it in Function.prototype.toString to return
                        // the native one.
                        attachOriginToPatched(this[originalInstanceKey][prop], fn);
                    } else this[originalInstanceKey][prop] = fn;
                },
                get: function() {
                    return this[originalInstanceKey][prop];
                }
            });
        })(prop);
    }
    for(prop in OriginalClass)if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) _global[className][prop] = OriginalClass[prop];
}
function patchMethod(target, name, patchFn) {
    let proto = target;
    while(proto && !proto.hasOwnProperty(name))proto = ObjectGetPrototypeOf(proto);
    if (!proto && target[name]) // somehow we did not find it, but we can see it. This happens on IE for Window properties.
    proto = target;
    const delegateName = zoneSymbol(name);
    let delegate = null;
    if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
        delegate = proto[delegateName] = proto[name];
        // check whether proto[name] is writable
        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob
        const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
        if (isPropertyWritable(desc)) {
            const patchDelegate = patchFn(delegate, delegateName, name);
            proto[name] = function() {
                return patchDelegate(this, arguments);
            };
            attachOriginToPatched(proto[name], delegate);
        }
    }
    return delegate;
}
// TODO: @JiaLiPassion, support cancel task later if necessary
function patchMacroTask(obj, funcName, metaCreator) {
    let setNative = null;
    function scheduleTask(task) {
        const data = task.data;
        data.args[data.cbIdx] = function() {
            task.invoke.apply(this, arguments);
        };
        setNative.apply(data.target, data.args);
        return task;
    }
    setNative = patchMethod(obj, funcName, (delegate)=>function(self1, args) {
            const meta = metaCreator(self1, args);
            if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
            else // cause an error by calling it directly.
            return delegate.apply(self1, args);
        });
}
function attachOriginToPatched(patched, original) {
    patched[zoneSymbol('OriginalDelegate')] = original;
}
let isDetectedIEOrEdge = false;
let ieOrEdge = false;
function isIE() {
    try {
        const ua = internalWindow.navigator.userAgent;
        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) return true;
    } catch (error) {}
    return false;
}
function isIEOrEdge() {
    if (isDetectedIEOrEdge) return ieOrEdge;
    isDetectedIEOrEdge = true;
    try {
        const ua = internalWindow.navigator.userAgent;
        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) ieOrEdge = true;
    } catch (error) {}
    return ieOrEdge;
}
function isFunction(value) {
    return typeof value === 'function';
}
function isNumber(value) {
    return typeof value === 'number';
}
/**
 * @fileoverview
 * @suppress {missingRequire}
 */ // Note that passive event listeners are now supported by most modern browsers,
// including Chrome, Firefox, Safari, and Edge. There's a pending change that
// would remove support for legacy browsers by zone.js. Removing `passiveSupported`
// from the codebase will reduce the final code size for existing apps that still use zone.js.
let passiveSupported = false;
if (typeof window !== 'undefined') try {
    const options = Object.defineProperty({}, 'passive', {
        get: function() {
            passiveSupported = true;
        }
    });
    // Note: We pass the `options` object as the event handler too. This is not compatible with the
    // signature of `addEventListener` or `removeEventListener` but enables us to remove the handler
    // without an actual handler.
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, options);
} catch (err) {
    passiveSupported = false;
}
// an identifier to tell ZoneTask do not create a new invoke closure
const OPTIMIZED_ZONE_EVENT_TASK_DATA = {
    useG: true
};
const zoneSymbolEventNames = {};
const globalSources = {};
const EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\w+)(true|false)$');
const IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');
function prepareEventNames(eventName, eventNameToString) {
    const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
    const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
    zoneSymbolEventNames[eventName] = {};
    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
}
function patchEventTarget(_global, api, apis, patchOptions) {
    const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
    const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
    const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || 'eventListeners';
    const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || 'removeAllListeners';
    const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
    const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
    const PREPEND_EVENT_LISTENER = 'prependListener';
    const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';
    const invokeTask = function(task, target, event) {
        // for better performance, check isRemoved which is set
        // by removeEventListener
        if (task.isRemoved) return;
        const delegate = task.callback;
        if (typeof delegate === 'object' && delegate.handleEvent) {
            // create the bind version of handleEvent when invoke
            task.callback = (event)=>delegate.handleEvent(event);
            task.originalDelegate = delegate;
        }
        // invoke static task.invoke
        // need to try/catch error here, otherwise, the error in one event listener
        // will break the executions of the other event listeners. Also error will
        // not remove the event listener when `once` options is true.
        let error;
        try {
            task.invoke(task, target, [
                event
            ]);
        } catch (err) {
            error = err;
        }
        const options = task.options;
        if (options && typeof options === 'object' && options.once) {
            // if options.once is true, after invoke once remove listener here
            // only browser need to do this, nodejs eventEmitter will cal removeListener
            // inside EventEmitter.once
            const delegate = task.originalDelegate ? task.originalDelegate : task.callback;
            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);
        }
        return error;
    };
    function globalCallback(context, event, isCapture) {
        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
        // event will be undefined, so we need to use window.event
        event = event || _global.event;
        if (!event) return;
        // event.target is needed for Samsung TV and SourceBuffer
        // || global is needed https://github.com/angular/zone.js/issues/190
        const target = context || event.target || _global;
        const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
        if (tasks) {
            const errors = [];
            // invoke all tasks which attached to current target with given event.type and capture = false
            // for performance concern, if task.length === 1, just invoke
            if (tasks.length === 1) {
                const err = invokeTask(tasks[0], target, event);
                err && errors.push(err);
            } else {
                // https://github.com/angular/zone.js/issues/836
                // copy the tasks array before invoke, to avoid
                // the callback will remove itself or other listener
                const copyTasks = tasks.slice();
                for(let i = 0; i < copyTasks.length; i++){
                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) break;
                    const err = invokeTask(copyTasks[i], target, event);
                    err && errors.push(err);
                }
            }
            // Since there is only one error, we don't need to schedule microTask
            // to throw the error.
            if (errors.length === 1) throw errors[0];
            else for(let i = 0; i < errors.length; i++){
                const err = errors[i];
                api.nativeScheduleMicroTask(()=>{
                    throw err;
                });
            }
        }
    }
    // global shared zoneAwareCallback to handle all event callback with capture = false
    const globalZoneAwareCallback = function(event) {
        return globalCallback(this, event, false);
    };
    // global shared zoneAwareCallback to handle all event callback with capture = true
    const globalZoneAwareCaptureCallback = function(event) {
        return globalCallback(this, event, true);
    };
    function patchEventTargetMethods(obj, patchOptions) {
        if (!obj) return false;
        let useGlobalCallback = true;
        if (patchOptions && patchOptions.useG !== undefined) useGlobalCallback = patchOptions.useG;
        const validateHandler = patchOptions && patchOptions.vh;
        let checkDuplicate = true;
        if (patchOptions && patchOptions.chkDup !== undefined) checkDuplicate = patchOptions.chkDup;
        let returnTarget = false;
        if (patchOptions && patchOptions.rt !== undefined) returnTarget = patchOptions.rt;
        let proto = obj;
        while(proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER))proto = ObjectGetPrototypeOf(proto);
        if (!proto && obj[ADD_EVENT_LISTENER]) // somehow we did not find it, but we can see it. This happens on IE for Window properties.
        proto = obj;
        if (!proto) return false;
        if (proto[zoneSymbolAddEventListener]) return false;
        const eventNameToString = patchOptions && patchOptions.eventNameToString;
        // We use a shared global `taskData` to pass data for `scheduleEventTask`,
        // eliminating the need to create a new object solely for passing data.
        // WARNING: This object has a static lifetime, meaning it is not created
        // each time `addEventListener` is called. It is instantiated only once
        // and captured by reference inside the `addEventListener` and
        // `removeEventListener` functions. Do not add any new properties to this
        // object, as doing so would necessitate maintaining the information
        // between `addEventListener` calls.
        const taskData = {};
        const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
        const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
        const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
        const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
        let nativePrependEventListener;
        if (patchOptions && patchOptions.prepend) nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] = proto[patchOptions.prepend];
        /**
         * This util function will build an option object with passive option
         * to handle all possible input from the user.
         */ function buildEventListenerOptions(options, passive) {
            if (!passiveSupported && typeof options === 'object' && options) // doesn't support passive but user want to pass an object as options.
            // this will not work on some old browser, so we just pass a boolean
            // as useCapture parameter
            return !!options.capture;
            if (!passiveSupported || !passive) return options;
            if (typeof options === 'boolean') return {
                capture: options,
                passive: true
            };
            if (!options) return {
                passive: true
            };
            if (typeof options === 'object' && options.passive !== false) return {
                ...options,
                passive: true
            };
            return options;
        }
        const customScheduleGlobal = function(task) {
            // if there is already a task for the eventName + capture,
            // just return, because we use the shared globalZoneAwareCallback here.
            if (taskData.isExisting) return;
            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
        };
        /**
         * In the context of events and listeners, this function will be
         * called at the end by `cancelTask`, which, in turn, calls `task.cancelFn`.
         * Cancelling a task is primarily used to remove event listeners from
         * the task target.
         */ const customCancelGlobal = function(task) {
            // if task is not marked as isRemoved, this call is directly
            // from Zone.prototype.cancelTask, we should remove the task
            // from tasksList of target first
            if (!task.isRemoved) {
                const symbolEventNames = zoneSymbolEventNames[task.eventName];
                let symbolEventName;
                if (symbolEventNames) symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
                const existingTasks = symbolEventName && task.target[symbolEventName];
                if (existingTasks) for(let i = 0; i < existingTasks.length; i++){
                    const existingTask = existingTasks[i];
                    if (existingTask === task) {
                        existingTasks.splice(i, 1);
                        // set isRemoved to data for faster invokeTask check
                        task.isRemoved = true;
                        if (task.removeAbortListener) {
                            task.removeAbortListener();
                            task.removeAbortListener = null;
                        }
                        if (existingTasks.length === 0) {
                            // all tasks for the eventName + capture have gone,
                            // remove globalZoneAwareCallback and remove the task cache from target
                            task.allRemoved = true;
                            task.target[symbolEventName] = null;
                        }
                        break;
                    }
                }
            }
            // if all tasks for the eventName + capture have gone,
            // we will really remove the global event callback,
            // if not, return
            if (!task.allRemoved) return;
            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
        };
        const customScheduleNonGlobal = function(task) {
            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
        };
        const customSchedulePrepend = function(task) {
            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
        };
        const customCancelNonGlobal = function(task) {
            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
        };
        const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
        const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
        const compareTaskCallbackVsDelegate = function(task, delegate) {
            const typeOfDelegate = typeof delegate;
            return typeOfDelegate === 'function' && task.callback === delegate || typeOfDelegate === 'object' && task.originalDelegate === delegate;
        };
        const compare = patchOptions && patchOptions.diff ? patchOptions.diff : compareTaskCallbackVsDelegate;
        const unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];
        const passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];
        function copyEventListenerOptions(options) {
            if (typeof options === 'object' && options !== null) {
                // We need to destructure the target `options` object since it may
                // be frozen or sealed (possibly provided implicitly by a third-party
                // library), or its properties may be readonly.
                const newOptions = {
                    ...options
                };
                // The `signal` option was recently introduced, which caused regressions in
                // third-party scenarios where `AbortController` was directly provided to
                // `addEventListener` as options. For instance, in cases like
                // `document.addEventListener('keydown', callback, abortControllerInstance)`,
                // which is valid because `AbortController` includes a `signal` getter, spreading
                // `{...options}` wouldn't copy the `signal`. Additionally, using `Object.create`
                // isn't feasible since `AbortController` is a built-in object type, and attempting
                // to create a new object directly with it as the prototype might result in
                // unexpected behavior.
                if (options.signal) newOptions.signal = options.signal;
                return newOptions;
            }
            return options;
        }
        const makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {
            return function() {
                const target = this || _global;
                let eventName = arguments[0];
                if (patchOptions && patchOptions.transferEventName) eventName = patchOptions.transferEventName(eventName);
                let delegate = arguments[1];
                if (!delegate) return nativeListener.apply(this, arguments);
                if (isNode && eventName === 'uncaughtException') // don't patch uncaughtException of nodejs to prevent endless loop
                return nativeListener.apply(this, arguments);
                // don't create the bind delegate function for handleEvent
                // case here to improve addEventListener performance
                // we will create the bind delegate when invoke
                let isHandleEvent = false;
                if (typeof delegate !== 'function') {
                    if (!delegate.handleEvent) return nativeListener.apply(this, arguments);
                    isHandleEvent = true;
                }
                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) return;
                const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
                const options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));
                const signal = options?.signal;
                if (signal?.aborted) // the signal is an aborted one, just return without attaching the event listener.
                return;
                if (unpatchedEvents) {
                    // check unpatched list
                    for(let i = 0; i < unpatchedEvents.length; i++)if (eventName === unpatchedEvents[i]) {
                        if (passive) return nativeListener.call(target, eventName, delegate, options);
                        else return nativeListener.apply(this, arguments);
                    }
                }
                const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;
                const once = options && typeof options === 'object' ? options.once : false;
                const zone = Zone.current;
                let symbolEventNames = zoneSymbolEventNames[eventName];
                if (!symbolEventNames) {
                    prepareEventNames(eventName, eventNameToString);
                    symbolEventNames = zoneSymbolEventNames[eventName];
                }
                const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
                let existingTasks = target[symbolEventName];
                let isExisting = false;
                if (existingTasks) {
                    // already have task registered
                    isExisting = true;
                    if (checkDuplicate) for(let i = 0; i < existingTasks.length; i++){
                        if (compare(existingTasks[i], delegate)) // same callback, same capture, same event name, just return
                        return;
                    }
                } else existingTasks = target[symbolEventName] = [];
                let source;
                const constructorName = target.constructor['name'];
                const targetSource = globalSources[constructorName];
                if (targetSource) source = targetSource[eventName];
                if (!source) source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
                // In the code below, `options` should no longer be reassigned; instead, it
                // should only be mutated. This is because we pass that object to the native
                // `addEventListener`.
                // It's generally recommended to use the same object reference for options.
                // This ensures consistency and avoids potential issues.
                taskData.options = options;
                if (once) // When using `addEventListener` with the `once` option, we don't pass
                // the `once` option directly to the native `addEventListener` method.
                // Instead, we keep the `once` setting and handle it ourselves.
                taskData.options.once = false;
                taskData.target = target;
                taskData.capture = capture;
                taskData.eventName = eventName;
                taskData.isExisting = isExisting;
                const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined;
                // keep taskData into data to allow onScheduleEventTask to access the task information
                if (data) data.taskData = taskData;
                if (signal) // When using `addEventListener` with the `signal` option, we don't pass
                // the `signal` option directly to the native `addEventListener` method.
                // Instead, we keep the `signal` setting and handle it ourselves.
                taskData.options.signal = undefined;
                // The `scheduleEventTask` function will ultimately call `customScheduleGlobal`,
                // which in turn calls the native `addEventListener`. This is why `taskData.options`
                // is updated before scheduling the task, as `customScheduleGlobal` uses
                // `taskData.options` to pass it to the native `addEventListener`.
                const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
                if (signal) {
                    // after task is scheduled, we need to store the signal back to task.options
                    taskData.options.signal = signal;
                    // Wrapping `task` in a weak reference would not prevent memory leaks. Weak references are
                    // primarily used for preventing strong references cycles. `onAbort` is always reachable
                    // as it's an event listener, so its closure retains a strong reference to the `task`.
                    const onAbort = ()=>task.zone.cancelTask(task);
                    nativeListener.call(signal, 'abort', onAbort, {
                        once: true
                    });
                    // We need to remove the `abort` listener when the event listener is going to be removed,
                    // as it creates a closure that captures `task`. This closure retains a reference to the
                    // `task` object even after it goes out of scope, preventing `task` from being garbage
                    // collected.
                    task.removeAbortListener = ()=>signal.removeEventListener('abort', onAbort);
                }
                // should clear taskData.target to avoid memory leak
                // issue, https://github.com/angular/angular/issues/20442
                taskData.target = null;
                // need to clear up taskData because it is a global object
                if (data) data.taskData = null;
                // have to save those information to task in case
                // application may call task.zone.cancelTask() directly
                if (once) taskData.options.once = true;
                if (!(!passiveSupported && typeof task.options === 'boolean')) // if not support passive, and we pass an option object
                // to addEventListener, we should save the options to task
                task.options = options;
                task.target = target;
                task.capture = capture;
                task.eventName = eventName;
                if (isHandleEvent) // save original delegate for compare to check duplicate
                task.originalDelegate = delegate;
                if (!prepend) existingTasks.push(task);
                else existingTasks.unshift(task);
                if (returnTarget) return target;
            };
        };
        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
        if (nativePrependEventListener) proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
        proto[REMOVE_EVENT_LISTENER] = function() {
            const target = this || _global;
            let eventName = arguments[0];
            if (patchOptions && patchOptions.transferEventName) eventName = patchOptions.transferEventName(eventName);
            const options = arguments[2];
            const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;
            const delegate = arguments[1];
            if (!delegate) return nativeRemoveEventListener.apply(this, arguments);
            if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) return;
            const symbolEventNames = zoneSymbolEventNames[eventName];
            let symbolEventName;
            if (symbolEventNames) symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
            const existingTasks = symbolEventName && target[symbolEventName];
            // `existingTasks` may not exist if the `addEventListener` was called before
            // it was patched by zone.js. Please refer to the attached issue for
            // clarification, particularly after the `if` condition, before calling
            // the native `removeEventListener`.
            if (existingTasks) for(let i = 0; i < existingTasks.length; i++){
                const existingTask = existingTasks[i];
                if (compare(existingTask, delegate)) {
                    existingTasks.splice(i, 1);
                    // set isRemoved to data for faster invokeTask check
                    existingTask.isRemoved = true;
                    if (existingTasks.length === 0) {
                        // all tasks for the eventName + capture have gone,
                        // remove globalZoneAwareCallback and remove the task cache from target
                        existingTask.allRemoved = true;
                        target[symbolEventName] = null;
                        // in the target, we have an event listener which is added by on_property
                        // such as target.onclick = function() {}, so we need to clear this internal
                        // property too if all delegates with capture=false were removed
                        // https:// github.com/angular/angular/issues/31643
                        // https://github.com/angular/angular/issues/54581
                        if (!capture && typeof eventName === 'string') {
                            const onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;
                            target[onPropertySymbol] = null;
                        }
                    }
                    // In all other conditions, when `addEventListener` is called after being
                    // patched by zone.js, we would always find an event task on the `EventTarget`.
                    // This will trigger `cancelFn` on the `existingTask`, leading to `customCancelGlobal`,
                    // which ultimately removes an event listener and cleans up the abort listener
                    // (if an `AbortSignal` was provided when scheduling a task).
                    existingTask.zone.cancelTask(existingTask);
                    if (returnTarget) return target;
                    return;
                }
            }
            // https://github.com/angular/zone.js/issues/930
            // We may encounter a situation where the `addEventListener` was
            // called on the event target before zone.js is loaded, resulting
            // in no task being stored on the event target due to its invocation
            // of the native implementation. In this scenario, we simply need to
            // invoke the native `removeEventListener`.
            return nativeRemoveEventListener.apply(this, arguments);
        };
        proto[LISTENERS_EVENT_LISTENER] = function() {
            const target = this || _global;
            let eventName = arguments[0];
            if (patchOptions && patchOptions.transferEventName) eventName = patchOptions.transferEventName(eventName);
            const listeners = [];
            const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
            for(let i = 0; i < tasks.length; i++){
                const task = tasks[i];
                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                listeners.push(delegate);
            }
            return listeners;
        };
        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {
            const target = this || _global;
            let eventName = arguments[0];
            if (!eventName) {
                const keys = Object.keys(target);
                for(let i = 0; i < keys.length; i++){
                    const prop = keys[i];
                    const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
                    let evtName = match && match[1];
                    // in nodejs EventEmitter, removeListener event is
                    // used for monitoring the removeListener call,
                    // so just keep removeListener eventListener until
                    // all other eventListeners are removed
                    if (evtName && evtName !== 'removeListener') this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
                }
                // remove removeListener listener finally
                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');
            } else {
                if (patchOptions && patchOptions.transferEventName) eventName = patchOptions.transferEventName(eventName);
                const symbolEventNames = zoneSymbolEventNames[eventName];
                if (symbolEventNames) {
                    const symbolEventName = symbolEventNames[FALSE_STR];
                    const symbolCaptureEventName = symbolEventNames[TRUE_STR];
                    const tasks = target[symbolEventName];
                    const captureTasks = target[symbolCaptureEventName];
                    if (tasks) {
                        const removeTasks = tasks.slice();
                        for(let i = 0; i < removeTasks.length; i++){
                            const task = removeTasks[i];
                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                        }
                    }
                    if (captureTasks) {
                        const removeTasks = captureTasks.slice();
                        for(let i = 0; i < removeTasks.length; i++){
                            const task = removeTasks[i];
                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                        }
                    }
                }
            }
            if (returnTarget) return this;
        };
        // for native toString patch
        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
        if (nativeRemoveAllListeners) attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
        if (nativeListeners) attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
        return true;
    }
    let results = [];
    for(let i = 0; i < apis.length; i++)results[i] = patchEventTargetMethods(apis[i], patchOptions);
    return results;
}
function findEventTasks(target, eventName) {
    if (!eventName) {
        const foundTasks = [];
        for(let prop in target){
            const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
            let evtName = match && match[1];
            if (evtName && (!eventName || evtName === eventName)) {
                const tasks = target[prop];
                if (tasks) for(let i = 0; i < tasks.length; i++)foundTasks.push(tasks[i]);
            }
        }
        return foundTasks;
    }
    let symbolEventName = zoneSymbolEventNames[eventName];
    if (!symbolEventName) {
        prepareEventNames(eventName);
        symbolEventName = zoneSymbolEventNames[eventName];
    }
    const captureFalseTasks = target[symbolEventName[FALSE_STR]];
    const captureTrueTasks = target[symbolEventName[TRUE_STR]];
    if (!captureFalseTasks) return captureTrueTasks ? captureTrueTasks.slice() : [];
    else return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
}
function patchEventPrototype(global, api) {
    const Event = global['Event'];
    if (Event && Event.prototype) api.patchMethod(Event.prototype, 'stopImmediatePropagation', (delegate)=>function(self1, args) {
            self1[IMMEDIATE_PROPAGATION_SYMBOL] = true;
            // we need to call the native stopImmediatePropagation
            // in case in some hybrid application, some part of
            // application will be controlled by zone, some are not
            delegate && delegate.apply(self1, args);
        });
}
/**
 * @fileoverview
 * @suppress {missingRequire}
 */ function patchQueueMicrotask(global, api) {
    api.patchMethod(global, 'queueMicrotask', (delegate)=>{
        return function(self1, args) {
            Zone.current.scheduleMicroTask('queueMicrotask', args[0]);
        };
    });
}
/**
 * @fileoverview
 * @suppress {missingRequire}
 */ const taskSymbol = zoneSymbol('zoneTask');
function patchTimer(window1, setName, cancelName, nameSuffix) {
    let setNative = null;
    let clearNative = null;
    setName += nameSuffix;
    cancelName += nameSuffix;
    const tasksByHandleId = {};
    function scheduleTask(task) {
        const data = task.data;
        data.args[0] = function() {
            return task.invoke.apply(this, arguments);
        };
        const handleOrId = setNative.apply(window1, data.args);
        // Whlist on Node.js when get can the ID by using `[Symbol.toPrimitive]()` we do
        // to this so that we do not cause potentally leaks when using `setTimeout`
        // since this can be periodic when using `.refresh`.
        if (isNumber(handleOrId)) data.handleId = handleOrId;
        else {
            data.handle = handleOrId;
            // On Node.js a timeout and interval can be restarted over and over again by using the `.refresh` method.
            data.isRefreshable = isFunction(handleOrId.refresh);
        }
        return task;
    }
    function clearTask(task) {
        const { handle, handleId } = task.data;
        return clearNative.call(window1, handle ?? handleId);
    }
    setNative = patchMethod(window1, setName, (delegate)=>function(self1, args) {
            if (isFunction(args[0])) {
                const options = {
                    isRefreshable: false,
                    isPeriodic: nameSuffix === 'Interval',
                    delay: nameSuffix === 'Timeout' || nameSuffix === 'Interval' ? args[1] || 0 : undefined,
                    args: args
                };
                const callback = args[0];
                args[0] = function timer() {
                    try {
                        return callback.apply(this, arguments);
                    } finally{
                        // issue-934, task will be cancelled
                        // even it is a periodic task such as
                        // setInterval
                        // https://github.com/angular/angular/issues/40387
                        // Cleanup tasksByHandleId should be handled before scheduleTask
                        // Since some zoneSpec may intercept and doesn't trigger
                        // scheduleFn(scheduleTask) provided here.
                        const { handle, handleId, isPeriodic, isRefreshable } = options;
                        if (!isPeriodic && !isRefreshable) {
                            if (handleId) // in non-nodejs env, we remove timerId
                            // from local cache
                            delete tasksByHandleId[handleId];
                            else if (handle) // Node returns complex objects as handleIds
                            // we remove task reference from timer object
                            handle[taskSymbol] = null;
                        }
                    }
                };
                const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
                if (!task) return task;
                // Node.js must additionally support the ref and unref functions.
                const { handleId, handle, isRefreshable, isPeriodic } = task.data;
                if (handleId) // for non nodejs env, we save handleId: task
                // mapping in local cache for clearTimeout
                tasksByHandleId[handleId] = task;
                else if (handle) {
                    // for nodejs env, we save task
                    // reference in timerId Object for clearTimeout
                    handle[taskSymbol] = task;
                    if (isRefreshable && !isPeriodic) {
                        const originalRefresh = handle.refresh;
                        handle.refresh = function() {
                            const { zone, state } = task;
                            if (state === 'notScheduled') {
                                task._state = 'scheduled';
                                zone._updateTaskCount(task, 1);
                            } else if (state === 'running') task._state = 'scheduling';
                            return originalRefresh.call(this);
                        };
                    }
                }
                return handle ?? handleId ?? task;
            } else // cause an error by calling it directly.
            return delegate.apply(window1, args);
        });
    clearNative = patchMethod(window1, cancelName, (delegate)=>function(self1, args) {
            const id = args[0];
            let task;
            if (isNumber(id)) {
                // non nodejs env.
                task = tasksByHandleId[id];
                delete tasksByHandleId[id];
            } else {
                // nodejs env ?? other environments.
                task = id?.[taskSymbol];
                if (task) id[taskSymbol] = null;
                else task = id;
            }
            if (task?.type) {
                if (task.cancelFn) // Do not cancel already canceled functions
                task.zone.cancelTask(task);
            } else // cause an error by calling it directly.
            delegate.apply(window1, args);
        });
}
function patchCustomElements(_global, api) {
    const { isBrowser, isMix } = api.getGlobalObjects();
    if (!isBrowser && !isMix || !_global['customElements'] || !('customElements' in _global)) return;
    // https://html.spec.whatwg.org/multipage/custom-elements.html#concept-custom-element-definition-lifecycle-callbacks
    const callbacks = [
        'connectedCallback',
        'disconnectedCallback',
        'adoptedCallback',
        'attributeChangedCallback',
        'formAssociatedCallback',
        'formDisabledCallback',
        'formResetCallback',
        'formStateRestoreCallback'
    ];
    api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);
}
function eventTargetPatch(_global, api) {
    if (Zone[api.symbol('patchEventTarget')]) // EventTarget is already patched.
    return;
    const { eventNames, zoneSymbolEventNames, TRUE_STR, FALSE_STR, ZONE_SYMBOL_PREFIX } = api.getGlobalObjects();
    //  predefine all __zone_symbol__ + eventName + true/false string
    for(let i = 0; i < eventNames.length; i++){
        const eventName = eventNames[i];
        const falseEventName = eventName + FALSE_STR;
        const trueEventName = eventName + TRUE_STR;
        const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
        const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
        zoneSymbolEventNames[eventName] = {};
        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
    }
    const EVENT_TARGET = _global['EventTarget'];
    if (!EVENT_TARGET || !EVENT_TARGET.prototype) return;
    api.patchEventTarget(_global, api, [
        EVENT_TARGET && EVENT_TARGET.prototype
    ]);
    return true;
}
function patchEvent(global, api) {
    api.patchEventPrototype(global, api);
}
/**
 * @fileoverview
 * @suppress {globalThis}
 */ function filterProperties(target, onProperties, ignoreProperties) {
    if (!ignoreProperties || ignoreProperties.length === 0) return onProperties;
    const tip = ignoreProperties.filter((ip)=>ip.target === target);
    if (!tip || tip.length === 0) return onProperties;
    const targetIgnoreProperties = tip[0].ignoreProperties;
    return onProperties.filter((op)=>targetIgnoreProperties.indexOf(op) === -1);
}
function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
    // check whether target is available, sometimes target will be undefined
    // because different browser or some 3rd party plugin.
    if (!target) return;
    const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
    patchOnProperties(target, filteredProperties, prototype);
}
/**
 * Get all event name properties which the event name startsWith `on`
 * from the target object itself, inherited properties are not considered.
 */ function getOnEventNames(target) {
    return Object.getOwnPropertyNames(target).filter((name)=>name.startsWith('on') && name.length > 2).map((name)=>name.substring(2));
}
function propertyDescriptorPatch(api, _global) {
    if (isNode && !isMix) return;
    if (Zone[api.symbol('patchEvents')]) // events are already been patched by legacy patch.
    return;
    const ignoreProperties = _global['__Zone_ignore_on_properties'];
    // for browsers that we can patch the descriptor:  Chrome & Firefox
    let patchTargets = [];
    if (isBrowser) {
        const internalWindow = window;
        patchTargets = patchTargets.concat([
            'Document',
            'SVGElement',
            'Element',
            'HTMLElement',
            'HTMLBodyElement',
            'HTMLMediaElement',
            'HTMLFrameSetElement',
            'HTMLFrameElement',
            'HTMLIFrameElement',
            'HTMLMarqueeElement',
            'Worker'
        ]);
        const ignoreErrorProperties = isIE() ? [
            {
                target: internalWindow,
                ignoreProperties: [
                    'error'
                ]
            }
        ] : [];
        // in IE/Edge, onProp not exist in window object, but in WindowPrototype
        // so we need to pass WindowPrototype to check onProp exist or not
        patchFilteredProperties(internalWindow, getOnEventNames(internalWindow), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));
    }
    patchTargets = patchTargets.concat([
        'XMLHttpRequest',
        'XMLHttpRequestEventTarget',
        'IDBIndex',
        'IDBRequest',
        'IDBOpenDBRequest',
        'IDBDatabase',
        'IDBTransaction',
        'IDBCursor',
        'WebSocket'
    ]);
    for(let i = 0; i < patchTargets.length; i++){
        const target = _global[patchTargets[i]];
        target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
    }
}
/**
 * @fileoverview
 * @suppress {missingRequire}
 */ function patchBrowser(Zone1) {
    Zone1.__load_patch('legacy', (global)=>{
        const legacyPatch = global[Zone1.__symbol__('legacyPatch')];
        if (legacyPatch) legacyPatch();
    });
    Zone1.__load_patch('timers', (global)=>{
        const set = 'set';
        const clear = 'clear';
        patchTimer(global, set, clear, 'Timeout');
        patchTimer(global, set, clear, 'Interval');
        patchTimer(global, set, clear, 'Immediate');
    });
    Zone1.__load_patch('requestAnimationFrame', (global)=>{
        patchTimer(global, 'request', 'cancel', 'AnimationFrame');
        patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');
        patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
    });
    Zone1.__load_patch('blocking', (global, Zone1)=>{
        const blockingMethods = [
            'alert',
            'prompt',
            'confirm'
        ];
        for(let i = 0; i < blockingMethods.length; i++){
            const name = blockingMethods[i];
            patchMethod(global, name, (delegate, symbol, name)=>{
                return function(s, args) {
                    return Zone1.current.run(delegate, global, args, name);
                };
            });
        }
    });
    Zone1.__load_patch('EventTarget', (global, Zone1, api)=>{
        patchEvent(global, api);
        eventTargetPatch(global, api);
        // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener
        const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];
        if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) api.patchEventTarget(global, api, [
            XMLHttpRequestEventTarget.prototype
        ]);
    });
    Zone1.__load_patch('MutationObserver', (global, Zone1, api)=>{
        patchClass('MutationObserver');
        patchClass('WebKitMutationObserver');
    });
    Zone1.__load_patch('IntersectionObserver', (global, Zone1, api)=>{
        patchClass('IntersectionObserver');
    });
    Zone1.__load_patch('FileReader', (global, Zone1, api)=>{
        patchClass('FileReader');
    });
    Zone1.__load_patch('on_property', (global, Zone1, api)=>{
        propertyDescriptorPatch(api, global);
    });
    Zone1.__load_patch('customElements', (global, Zone1, api)=>{
        patchCustomElements(global, api);
    });
    Zone1.__load_patch('XHR', (global, Zone1)=>{
        // Treat XMLHttpRequest as a macrotask.
        patchXHR(global);
        const XHR_TASK = zoneSymbol('xhrTask');
        const XHR_SYNC = zoneSymbol('xhrSync');
        const XHR_LISTENER = zoneSymbol('xhrListener');
        const XHR_SCHEDULED = zoneSymbol('xhrScheduled');
        const XHR_URL = zoneSymbol('xhrURL');
        const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');
        function patchXHR(window1) {
            const XMLHttpRequest = window1['XMLHttpRequest'];
            if (!XMLHttpRequest) // XMLHttpRequest is not available in service worker
            return;
            const XMLHttpRequestPrototype = XMLHttpRequest.prototype;
            function findPendingTask(target) {
                return target[XHR_TASK];
            }
            let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
            let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
            if (!oriAddListener) {
                const XMLHttpRequestEventTarget = window1['XMLHttpRequestEventTarget'];
                if (XMLHttpRequestEventTarget) {
                    const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
                    oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
                    oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
                }
            }
            const READY_STATE_CHANGE = 'readystatechange';
            const SCHEDULED = 'scheduled';
            function scheduleTask(task) {
                const data = task.data;
                const target = data.target;
                target[XHR_SCHEDULED] = false;
                target[XHR_ERROR_BEFORE_SCHEDULED] = false;
                // remove existing event listener
                const listener = target[XHR_LISTENER];
                if (!oriAddListener) {
                    oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
                    oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
                }
                if (listener) oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
                const newListener = target[XHR_LISTENER] = ()=>{
                    if (target.readyState === target.DONE) {
                        // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with
                        // readyState=4 multiple times, so we need to check task state here
                        if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
                            // check whether the xhr has registered onload listener
                            // if that is the case, the task should invoke after all
                            // onload listeners finish.
                            // Also if the request failed without response (status = 0), the load event handler
                            // will not be triggered, in that case, we should also invoke the placeholder callback
                            // to close the XMLHttpRequest::send macroTask.
                            // https://github.com/angular/angular/issues/38795
                            const loadTasks = target[Zone1.__symbol__('loadfalse')];
                            if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
                                const oriInvoke = task.invoke;
                                task.invoke = function() {
                                    // need to load the tasks again, because in other
                                    // load listener, they may remove themselves
                                    const loadTasks = target[Zone1.__symbol__('loadfalse')];
                                    for(let i = 0; i < loadTasks.length; i++)if (loadTasks[i] === task) loadTasks.splice(i, 1);
                                    if (!data.aborted && task.state === SCHEDULED) oriInvoke.call(task);
                                };
                                loadTasks.push(task);
                            } else task.invoke();
                        } else if (!data.aborted && target[XHR_SCHEDULED] === false) // error occurs when xhr.send()
                        target[XHR_ERROR_BEFORE_SCHEDULED] = true;
                    }
                };
                oriAddListener.call(target, READY_STATE_CHANGE, newListener);
                const storedTask = target[XHR_TASK];
                if (!storedTask) target[XHR_TASK] = task;
                sendNative.apply(target, data.args);
                target[XHR_SCHEDULED] = true;
                return task;
            }
            function placeholderCallback() {}
            function clearTask(task) {
                const data = task.data;
                // Note - ideally, we would call data.target.removeEventListener here, but it's too late
                // to prevent it from firing. So instead, we store info for the event listener.
                data.aborted = true;
                return abortNative.apply(data.target, data.args);
            }
            const openNative = patchMethod(XMLHttpRequestPrototype, 'open', ()=>function(self1, args) {
                    self1[XHR_SYNC] = args[2] == false;
                    self1[XHR_URL] = args[1];
                    return openNative.apply(self1, args);
                });
            const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';
            const fetchTaskAborting = zoneSymbol('fetchTaskAborting');
            const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');
            const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', ()=>function(self1, args) {
                    if (Zone1.current[fetchTaskScheduling] === true) // a fetch is scheduling, so we are using xhr to polyfill fetch
                    // and because we already schedule macroTask for fetch, we should
                    // not schedule a macroTask for xhr again
                    return sendNative.apply(self1, args);
                    if (self1[XHR_SYNC]) // if the XHR is sync there is no task to schedule, just execute the code.
                    return sendNative.apply(self1, args);
                    else {
                        const options = {
                            target: self1,
                            url: self1[XHR_URL],
                            isPeriodic: false,
                            args: args,
                            aborted: false
                        };
                        const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
                        if (self1 && self1[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) // xhr request throw error when send
                        // we should invoke task instead of leaving a scheduled
                        // pending macroTask
                        task.invoke();
                    }
                });
            const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', ()=>function(self1, args) {
                    const task = findPendingTask(self1);
                    if (task && typeof task.type == 'string') {
                        // If the XHR has already completed, do nothing.
                        // If the XHR has already been aborted, do nothing.
                        // Fix #569, call abort multiple times before done will cause
                        // macroTask task count be negative number
                        if (task.cancelFn == null || task.data && task.data.aborted) return;
                        task.zone.cancelTask(task);
                    } else if (Zone1.current[fetchTaskAborting] === true) // the abort is called from fetch polyfill, we need to call native abort of XHR.
                    return abortNative.apply(self1, args);
                // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no
                // task
                // to cancel. Do nothing.
                });
        }
    });
    Zone1.__load_patch('geolocation', (global)=>{
        /// GEO_LOCATION
        if (global['navigator'] && global['navigator'].geolocation) patchPrototype(global['navigator'].geolocation, [
            'getCurrentPosition',
            'watchPosition'
        ]);
    });
    Zone1.__load_patch('PromiseRejectionEvent', (global, Zone1)=>{
        // handle unhandled promise rejection
        function findPromiseRejectionHandler(evtName) {
            return function(e) {
                const eventTasks = findEventTasks(global, evtName);
                eventTasks.forEach((eventTask)=>{
                    // windows has added unhandledrejection event listener
                    // trigger the event listener
                    const PromiseRejectionEvent = global['PromiseRejectionEvent'];
                    if (PromiseRejectionEvent) {
                        const evt = new PromiseRejectionEvent(evtName, {
                            promise: e.promise,
                            reason: e.rejection
                        });
                        eventTask.invoke(evt);
                    }
                });
            };
        }
        if (global['PromiseRejectionEvent']) {
            Zone1[zoneSymbol('unhandledPromiseRejectionHandler')] = findPromiseRejectionHandler('unhandledrejection');
            Zone1[zoneSymbol('rejectionHandledHandler')] = findPromiseRejectionHandler('rejectionhandled');
        }
    });
    Zone1.__load_patch('queueMicrotask', (global, Zone1, api)=>{
        patchQueueMicrotask(global, api);
    });
}
function patchPromise(Zone1) {
    Zone1.__load_patch('ZoneAwarePromise', (global, Zone1, api)=>{
        const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        const ObjectDefineProperty = Object.defineProperty;
        function readableObjectToString(obj) {
            if (obj && obj.toString === Object.prototype.toString) {
                const className = obj.constructor && obj.constructor.name;
                return (className ? className : '') + ': ' + JSON.stringify(obj);
            }
            return obj ? obj.toString() : Object.prototype.toString.call(obj);
        }
        const __symbol__ = api.symbol;
        const _uncaughtPromiseErrors = [];
        const isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] !== false;
        const symbolPromise = __symbol__('Promise');
        const symbolThen = __symbol__('then');
        const creationTrace = '__creationTrace__';
        api.onUnhandledError = (e)=>{
            if (api.showUncaughtError()) {
                const rejection = e && e.rejection;
                if (rejection) console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
                else console.error(e);
            }
        };
        api.microtaskDrainDone = ()=>{
            while(_uncaughtPromiseErrors.length){
                const uncaughtPromiseError = _uncaughtPromiseErrors.shift();
                try {
                    uncaughtPromiseError.zone.runGuarded(()=>{
                        if (uncaughtPromiseError.throwOriginal) throw uncaughtPromiseError.rejection;
                        throw uncaughtPromiseError;
                    });
                } catch (error) {
                    handleUnhandledRejection(error);
                }
            }
        };
        const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');
        function handleUnhandledRejection(e) {
            api.onUnhandledError(e);
            try {
                const handler = Zone1[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
                if (typeof handler === 'function') handler.call(this, e);
            } catch (err) {}
        }
        function isThenable(value) {
            return value && value.then;
        }
        function forwardResolution(value) {
            return value;
        }
        function forwardRejection(rejection) {
            return ZoneAwarePromise.reject(rejection);
        }
        const symbolState = __symbol__('state');
        const symbolValue = __symbol__('value');
        const symbolFinally = __symbol__('finally');
        const symbolParentPromiseValue = __symbol__('parentPromiseValue');
        const symbolParentPromiseState = __symbol__('parentPromiseState');
        const source = 'Promise.then';
        const UNRESOLVED = null;
        const RESOLVED = true;
        const REJECTED = false;
        const REJECTED_NO_CATCH = 0;
        function makeResolver(promise, state) {
            return (v)=>{
                try {
                    resolvePromise(promise, state, v);
                } catch (err) {
                    resolvePromise(promise, false, err);
                }
            // Do not return value or you will break the Promise spec.
            };
        }
        const once = function() {
            let wasCalled = false;
            return function wrapper(wrappedFunction) {
                return function() {
                    if (wasCalled) return;
                    wasCalled = true;
                    wrappedFunction.apply(null, arguments);
                };
            };
        };
        const TYPE_ERROR = 'Promise resolved with itself';
        const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace');
        // Promise Resolution
        function resolvePromise(promise, state, value) {
            const onceWrapper = once();
            if (promise === value) throw new TypeError(TYPE_ERROR);
            if (promise[symbolState] === UNRESOLVED) {
                // should only get value.then once based on promise spec.
                let then = null;
                try {
                    if (typeof value === 'object' || typeof value === 'function') then = value && value.then;
                } catch (err) {
                    onceWrapper(()=>{
                        resolvePromise(promise, false, err);
                    })();
                    return promise;
                }
                // if (value instanceof ZoneAwarePromise) {
                if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
                    clearRejectedNoCatch(value);
                    resolvePromise(promise, value[symbolState], value[symbolValue]);
                } else if (state !== REJECTED && typeof then === 'function') try {
                    then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
                } catch (err) {
                    onceWrapper(()=>{
                        resolvePromise(promise, false, err);
                    })();
                }
                else {
                    promise[symbolState] = state;
                    const queue = promise[symbolValue];
                    promise[symbolValue] = value;
                    if (promise[symbolFinally] === symbolFinally) // the promise is generated by Promise.prototype.finally
                    {
                        if (state === RESOLVED) {
                            // the state is resolved, should ignore the value
                            // and use parent promise value
                            promise[symbolState] = promise[symbolParentPromiseState];
                            promise[symbolValue] = promise[symbolParentPromiseValue];
                        }
                    }
                    // record task information in value when error occurs, so we can
                    // do some additional work such as render longStackTrace
                    if (state === REJECTED && value instanceof Error) {
                        // check if longStackTraceZone is here
                        const trace = Zone1.currentTask && Zone1.currentTask.data && Zone1.currentTask.data[creationTrace];
                        if (trace) // only keep the long stack trace into error when in longStackTraceZone
                        ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, {
                            configurable: true,
                            enumerable: false,
                            writable: true,
                            value: trace
                        });
                    }
                    for(let i = 0; i < queue.length;)scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
                    if (queue.length == 0 && state == REJECTED) {
                        promise[symbolState] = REJECTED_NO_CATCH;
                        let uncaughtPromiseError = value;
                        try {
                            // Here we throws a new Error to print more readable error log
                            // and if the value is not an error, zone.js builds an `Error`
                            // Object here to attach the stack information.
                            throw new Error('Uncaught (in promise): ' + readableObjectToString(value) + (value && value.stack ? '\n' + value.stack : ''));
                        } catch (err) {
                            uncaughtPromiseError = err;
                        }
                        if (isDisableWrappingUncaughtPromiseRejection) // If disable wrapping uncaught promise reject
                        // use the value instead of wrapping it.
                        uncaughtPromiseError.throwOriginal = true;
                        uncaughtPromiseError.rejection = value;
                        uncaughtPromiseError.promise = promise;
                        uncaughtPromiseError.zone = Zone1.current;
                        uncaughtPromiseError.task = Zone1.currentTask;
                        _uncaughtPromiseErrors.push(uncaughtPromiseError);
                        api.scheduleMicroTask(); // to make sure that it is running
                    }
                }
            }
            // Resolving an already resolved promise is a noop.
            return promise;
        }
        const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');
        function clearRejectedNoCatch(promise) {
            if (promise[symbolState] === REJECTED_NO_CATCH) {
                // if the promise is rejected no catch status
                // and queue.length > 0, means there is a error handler
                // here to handle the rejected promise, we should trigger
                // windows.rejectionhandled eventHandler or nodejs rejectionHandled
                // eventHandler
                try {
                    const handler = Zone1[REJECTION_HANDLED_HANDLER];
                    if (handler && typeof handler === 'function') handler.call(this, {
                        rejection: promise[symbolValue],
                        promise: promise
                    });
                } catch (err) {}
                promise[symbolState] = REJECTED;
                for(let i = 0; i < _uncaughtPromiseErrors.length; i++)if (promise === _uncaughtPromiseErrors[i].promise) _uncaughtPromiseErrors.splice(i, 1);
            }
        }
        function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
            clearRejectedNoCatch(promise);
            const promiseState = promise[symbolState];
            const delegate = promiseState ? typeof onFulfilled === 'function' ? onFulfilled : forwardResolution : typeof onRejected === 'function' ? onRejected : forwardRejection;
            zone.scheduleMicroTask(source, ()=>{
                try {
                    const parentPromiseValue = promise[symbolValue];
                    const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
                    if (isFinallyPromise) {
                        // if the promise is generated from finally call, keep parent promise's state and value
                        chainPromise[symbolParentPromiseValue] = parentPromiseValue;
                        chainPromise[symbolParentPromiseState] = promiseState;
                    }
                    // should not pass value to finally callback
                    const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [
                        parentPromiseValue
                    ]);
                    resolvePromise(chainPromise, true, value);
                } catch (error) {
                    // if error occurs, should always return this error
                    resolvePromise(chainPromise, false, error);
                }
            }, chainPromise);
        }
        const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';
        const noop = function() {};
        const AggregateError = global.AggregateError;
        class ZoneAwarePromise {
            static toString() {
                return ZONE_AWARE_PROMISE_TO_STRING;
            }
            static resolve(value) {
                if (value instanceof ZoneAwarePromise) return value;
                return resolvePromise(new this(null), RESOLVED, value);
            }
            static reject(error) {
                return resolvePromise(new this(null), REJECTED, error);
            }
            static withResolvers() {
                const result = {};
                result.promise = new ZoneAwarePromise((res, rej)=>{
                    result.resolve = res;
                    result.reject = rej;
                });
                return result;
            }
            static any(values) {
                if (!values || typeof values[Symbol.iterator] !== 'function') return Promise.reject(new AggregateError([], 'All promises were rejected'));
                const promises = [];
                let count = 0;
                try {
                    for (let v of values){
                        count++;
                        promises.push(ZoneAwarePromise.resolve(v));
                    }
                } catch (err) {
                    return Promise.reject(new AggregateError([], 'All promises were rejected'));
                }
                if (count === 0) return Promise.reject(new AggregateError([], 'All promises were rejected'));
                let finished = false;
                const errors = [];
                return new ZoneAwarePromise((resolve, reject)=>{
                    for(let i = 0; i < promises.length; i++)promises[i].then((v)=>{
                        if (finished) return;
                        finished = true;
                        resolve(v);
                    }, (err)=>{
                        errors.push(err);
                        count--;
                        if (count === 0) {
                            finished = true;
                            reject(new AggregateError(errors, 'All promises were rejected'));
                        }
                    });
                });
            }
            static race(values) {
                let resolve;
                let reject;
                let promise = new this((res, rej)=>{
                    resolve = res;
                    reject = rej;
                });
                function onResolve(value) {
                    resolve(value);
                }
                function onReject(error) {
                    reject(error);
                }
                for (let value of values){
                    if (!isThenable(value)) value = this.resolve(value);
                    value.then(onResolve, onReject);
                }
                return promise;
            }
            static all(values) {
                return ZoneAwarePromise.allWithCallback(values);
            }
            static allSettled(values) {
                const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
                return P.allWithCallback(values, {
                    thenCallback: (value)=>({
                            status: 'fulfilled',
                            value
                        }),
                    errorCallback: (err)=>({
                            status: 'rejected',
                            reason: err
                        })
                });
            }
            static allWithCallback(values, callback) {
                let resolve;
                let reject;
                let promise = new this((res, rej)=>{
                    resolve = res;
                    reject = rej;
                });
                // Start at 2 to prevent prematurely resolving if .then is called immediately.
                let unresolvedCount = 2;
                let valueIndex = 0;
                const resolvedValues = [];
                for (let value of values){
                    if (!isThenable(value)) value = this.resolve(value);
                    const curValueIndex = valueIndex;
                    try {
                        value.then((value)=>{
                            resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;
                            unresolvedCount--;
                            if (unresolvedCount === 0) resolve(resolvedValues);
                        }, (err)=>{
                            if (!callback) reject(err);
                            else {
                                resolvedValues[curValueIndex] = callback.errorCallback(err);
                                unresolvedCount--;
                                if (unresolvedCount === 0) resolve(resolvedValues);
                            }
                        });
                    } catch (thenErr) {
                        reject(thenErr);
                    }
                    unresolvedCount++;
                    valueIndex++;
                }
                // Make the unresolvedCount zero-based again.
                unresolvedCount -= 2;
                if (unresolvedCount === 0) resolve(resolvedValues);
                return promise;
            }
            constructor(executor){
                const promise = this;
                if (!(promise instanceof ZoneAwarePromise)) throw new Error('Must be an instanceof Promise.');
                promise[symbolState] = UNRESOLVED;
                promise[symbolValue] = []; // queue;
                try {
                    const onceWrapper = once();
                    executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));
                } catch (error) {
                    resolvePromise(promise, false, error);
                }
            }
            get [Symbol.toStringTag]() {
                return 'Promise';
            }
            get [Symbol.species]() {
                return ZoneAwarePromise;
            }
            then(onFulfilled, onRejected) {
                // We must read `Symbol.species` safely because `this` may be anything. For instance, `this`
                // may be an object without a prototype (created through `Object.create(null)`); thus
                // `this.constructor` will be undefined. One of the use cases is SystemJS creating
                // prototype-less objects (modules) via `Object.create(null)`. The SystemJS creates an empty
                // object and copies promise properties into that object (within the `getOrCreateLoad`
                // function). The zone.js then checks if the resolved value has the `then` method and
                // invokes it with the `value` context. Otherwise, this will throw an error: `TypeError:
                // Cannot read properties of undefined (reading 'Symbol(Symbol.species)')`.
                let C = this.constructor?.[Symbol.species];
                if (!C || typeof C !== 'function') C = this.constructor || ZoneAwarePromise;
                const chainPromise = new C(noop);
                const zone = Zone1.current;
                if (this[symbolState] == UNRESOLVED) this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
                else scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
                return chainPromise;
            }
            catch(onRejected) {
                return this.then(null, onRejected);
            }
            finally(onFinally) {
                // See comment on the call to `then` about why thee `Symbol.species` is safely accessed.
                let C = this.constructor?.[Symbol.species];
                if (!C || typeof C !== 'function') C = ZoneAwarePromise;
                const chainPromise = new C(noop);
                chainPromise[symbolFinally] = symbolFinally;
                const zone = Zone1.current;
                if (this[symbolState] == UNRESOLVED) this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
                else scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
                return chainPromise;
            }
        }
        // Protect against aggressive optimizers dropping seemingly unused properties.
        // E.g. Closure Compiler in advanced mode.
        ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
        ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
        ZoneAwarePromise['race'] = ZoneAwarePromise.race;
        ZoneAwarePromise['all'] = ZoneAwarePromise.all;
        const NativePromise = global[symbolPromise] = global['Promise'];
        global['Promise'] = ZoneAwarePromise;
        const symbolThenPatched = __symbol__('thenPatched');
        function patchThen(Ctor) {
            const proto = Ctor.prototype;
            const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');
            if (prop && (prop.writable === false || !prop.configurable)) // check Ctor.prototype.then propertyDescriptor is writable or not
            // in meteor env, writable is false, we should ignore such case
            return;
            const originalThen = proto.then;
            // Keep a reference to the original method.
            proto[symbolThen] = originalThen;
            Ctor.prototype.then = function(onResolve, onReject) {
                const wrapped = new ZoneAwarePromise((resolve, reject)=>{
                    originalThen.call(this, resolve, reject);
                });
                return wrapped.then(onResolve, onReject);
            };
            Ctor[symbolThenPatched] = true;
        }
        api.patchThen = patchThen;
        function zoneify(fn) {
            return function(self1, args) {
                let resultPromise = fn.apply(self1, args);
                if (resultPromise instanceof ZoneAwarePromise) return resultPromise;
                let ctor = resultPromise.constructor;
                if (!ctor[symbolThenPatched]) patchThen(ctor);
                return resultPromise;
            };
        }
        if (NativePromise) {
            patchThen(NativePromise);
            patchMethod(global, 'fetch', (delegate)=>zoneify(delegate));
        }
        // This is not part of public API, but it is useful for tests, so we expose it.
        Promise[Zone1.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
        return ZoneAwarePromise;
    });
}
function patchToString(Zone1) {
    // override Function.prototype.toString to make zone.js patched function
    // look like native function
    Zone1.__load_patch('toString', (global)=>{
        // patch Func.prototype.toString to let them look like native
        const originalFunctionToString = Function.prototype.toString;
        const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');
        const PROMISE_SYMBOL = zoneSymbol('Promise');
        const ERROR_SYMBOL = zoneSymbol('Error');
        const newFunctionToString = function toString() {
            if (typeof this === 'function') {
                const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
                if (originalDelegate) {
                    if (typeof originalDelegate === 'function') return originalFunctionToString.call(originalDelegate);
                    else return Object.prototype.toString.call(originalDelegate);
                }
                if (this === Promise) {
                    const nativePromise = global[PROMISE_SYMBOL];
                    if (nativePromise) return originalFunctionToString.call(nativePromise);
                }
                if (this === Error) {
                    const nativeError = global[ERROR_SYMBOL];
                    if (nativeError) return originalFunctionToString.call(nativeError);
                }
            }
            return originalFunctionToString.call(this);
        };
        newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
        Function.prototype.toString = newFunctionToString;
        // patch Object.prototype.toString to let them look like native
        const originalObjectToString = Object.prototype.toString;
        const PROMISE_OBJECT_TO_STRING = '[object Promise]';
        Object.prototype.toString = function() {
            if (typeof Promise === 'function' && this instanceof Promise) return PROMISE_OBJECT_TO_STRING;
            return originalObjectToString.call(this);
        };
    });
}
function patchCallbacks(api, target, targetName, method, callbacks) {
    const symbol = Zone.__symbol__(method);
    if (target[symbol]) return;
    const nativeDelegate = target[symbol] = target[method];
    target[method] = function(name, opts, options) {
        if (opts && opts.prototype) callbacks.forEach(function(callback) {
            const source = `${targetName}.${method}::` + callback;
            const prototype = opts.prototype;
            // Note: the `patchCallbacks` is used for patching the `document.registerElement` and
            // `customElements.define`. We explicitly wrap the patching code into try-catch since
            // callbacks may be already patched by other web components frameworks (e.g. LWC), and they
            // make those properties non-writable. This means that patching callback will throw an error
            // `cannot assign to read-only property`. See this code as an example:
            // https://github.com/salesforce/lwc/blob/master/packages/@lwc/engine-core/src/framework/base-bridge-element.ts#L180-L186
            // We don't want to stop the application rendering if we couldn't patch some
            // callback, e.g. `attributeChangedCallback`.
            try {
                if (prototype.hasOwnProperty(callback)) {
                    const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
                    if (descriptor && descriptor.value) {
                        descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
                        api._redefineProperty(opts.prototype, callback, descriptor);
                    } else if (prototype[callback]) prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
                } else if (prototype[callback]) prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
            } catch  {
            // Note: we leave the catch block empty since there's no way to handle the error related
            // to non-writable property.
            }
        });
        return nativeDelegate.call(target, name, opts, options);
    };
    api.attachOriginToPatched(target[method], nativeDelegate);
}
function patchUtil(Zone1) {
    Zone1.__load_patch('util', (global, Zone1, api)=>{
        // Collect native event names by looking at properties
        // on the global namespace, e.g. 'onclick'.
        const eventNames = getOnEventNames(global);
        api.patchOnProperties = patchOnProperties;
        api.patchMethod = patchMethod;
        api.bindArguments = bindArguments;
        api.patchMacroTask = patchMacroTask;
        // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS`
        // to define which events will not be patched by `Zone.js`. In newer version (>=0.9.0), we
        // change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep the name consistent with
        // angular repo. The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be
        // supported for backwards compatibility.
        const SYMBOL_BLACK_LISTED_EVENTS = Zone1.__symbol__('BLACK_LISTED_EVENTS');
        const SYMBOL_UNPATCHED_EVENTS = Zone1.__symbol__('UNPATCHED_EVENTS');
        if (global[SYMBOL_UNPATCHED_EVENTS]) global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];
        if (global[SYMBOL_BLACK_LISTED_EVENTS]) Zone1[SYMBOL_BLACK_LISTED_EVENTS] = Zone1[SYMBOL_UNPATCHED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];
        api.patchEventPrototype = patchEventPrototype;
        api.patchEventTarget = patchEventTarget;
        api.isIEOrEdge = isIEOrEdge;
        api.ObjectDefineProperty = ObjectDefineProperty;
        api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
        api.ObjectCreate = ObjectCreate;
        api.ArraySlice = ArraySlice;
        api.patchClass = patchClass;
        api.wrapWithCurrentZone = wrapWithCurrentZone;
        api.filterProperties = filterProperties;
        api.attachOriginToPatched = attachOriginToPatched;
        api._redefineProperty = Object.defineProperty;
        api.patchCallbacks = patchCallbacks;
        api.getGlobalObjects = ()=>({
                globalSources,
                zoneSymbolEventNames,
                eventNames,
                isBrowser,
                isMix,
                isNode,
                TRUE_STR,
                FALSE_STR,
                ZONE_SYMBOL_PREFIX,
                ADD_EVENT_LISTENER_STR,
                REMOVE_EVENT_LISTENER_STR
            });
    });
}
function patchCommon(Zone1) {
    patchPromise(Zone1);
    patchToString(Zone1);
    patchUtil(Zone1);
}
const Zone$1 = loadZone();
patchCommon(Zone$1);
patchBrowser(Zone$1);

},{}],"kKfrn":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AggregationTemporality", ()=>(0, _aggregationTemporality.AggregationTemporality));
parcelHelpers.export(exports, "DataPointType", ()=>(0, _metricData.DataPointType));
parcelHelpers.export(exports, "MetricReader", ()=>(0, _metricReader.MetricReader));
parcelHelpers.export(exports, "PeriodicExportingMetricReader", ()=>(0, _periodicExportingMetricReader.PeriodicExportingMetricReader));
parcelHelpers.export(exports, "InMemoryMetricExporter", ()=>(0, _inMemoryMetricExporter.InMemoryMetricExporter));
parcelHelpers.export(exports, "ConsoleMetricExporter", ()=>(0, _consoleMetricExporter.ConsoleMetricExporter));
parcelHelpers.export(exports, "InstrumentType", ()=>(0, _instrumentDescriptor.InstrumentType));
parcelHelpers.export(exports, "MeterProvider", ()=>(0, _meterProvider.MeterProvider));
parcelHelpers.export(exports, "DefaultAggregation", ()=>(0, _aggregation.DefaultAggregation));
parcelHelpers.export(exports, "ExplicitBucketHistogramAggregation", ()=>(0, _aggregation.ExplicitBucketHistogramAggregation));
parcelHelpers.export(exports, "ExponentialHistogramAggregation", ()=>(0, _aggregation.ExponentialHistogramAggregation));
parcelHelpers.export(exports, "DropAggregation", ()=>(0, _aggregation.DropAggregation));
parcelHelpers.export(exports, "HistogramAggregation", ()=>(0, _aggregation.HistogramAggregation));
parcelHelpers.export(exports, "LastValueAggregation", ()=>(0, _aggregation.LastValueAggregation));
parcelHelpers.export(exports, "SumAggregation", ()=>(0, _aggregation.SumAggregation));
parcelHelpers.export(exports, "Aggregation", ()=>(0, _aggregation.Aggregation));
parcelHelpers.export(exports, "View", ()=>(0, _view.View));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _utils.TimeoutError));
var _aggregationTemporality = require("./export/AggregationTemporality");
var _metricData = require("./export/MetricData");
var _metricReader = require("./export/MetricReader");
var _periodicExportingMetricReader = require("./export/PeriodicExportingMetricReader");
var _inMemoryMetricExporter = require("./export/InMemoryMetricExporter");
var _consoleMetricExporter = require("./export/ConsoleMetricExporter");
var _instrumentDescriptor = require("./InstrumentDescriptor");
var _meterProvider = require("./MeterProvider");
var _aggregation = require("./view/Aggregation");
var _view = require("./view/View");
var _utils = require("./utils");

},{"./export/AggregationTemporality":false,"./export/MetricData":false,"./export/MetricReader":false,"./export/PeriodicExportingMetricReader":"5frcI","./export/InMemoryMetricExporter":false,"./export/ConsoleMetricExporter":"6kxES","./InstrumentDescriptor":false,"./MeterProvider":"2BGfA","./view/Aggregation":false,"./view/View":false,"./utils":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Gkq0r":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * AggregationTemporality indicates the way additive quantities are expressed.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AggregationTemporality", ()=>AggregationTemporality);
var AggregationTemporality;
(function(AggregationTemporality) {
    AggregationTemporality[AggregationTemporality["DELTA"] = 0] = "DELTA";
    AggregationTemporality[AggregationTemporality["CUMULATIVE"] = 1] = "CUMULATIVE";
})(AggregationTemporality || (AggregationTemporality = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"buI5y":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * The aggregated point data type.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DataPointType", ()=>DataPointType);
var DataPointType;
(function(DataPointType) {
    /**
     * A histogram data point contains a histogram statistics of collected
     * values with a list of explicit bucket boundaries and statistics such
     * as min, max, count, and sum of all collected values.
     */ DataPointType[DataPointType["HISTOGRAM"] = 0] = "HISTOGRAM";
    /**
     * An exponential histogram data point contains a histogram statistics of
     * collected values where bucket boundaries are automatically calculated
     * using an exponential function, and statistics such as min, max, count,
     * and sum of all collected values.
     */ DataPointType[DataPointType["EXPONENTIAL_HISTOGRAM"] = 1] = "EXPONENTIAL_HISTOGRAM";
    /**
     * A gauge metric data point has only a single numeric value.
     */ DataPointType[DataPointType["GAUGE"] = 2] = "GAUGE";
    /**
     * A sum metric data point has a single numeric value and a
     * monotonicity-indicator.
     */ DataPointType[DataPointType["SUM"] = 3] = "SUM";
})(DataPointType || (DataPointType = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kuWQE":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricReader", ()=>MetricReader);
var _api = require("@opentelemetry/api");
var _utils = require("../utils");
var _aggregationSelector = require("./AggregationSelector");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global
 * control over metrics.
 */ var MetricReader = /** @class */ function() {
    function MetricReader(options) {
        var _a, _b, _c;
        // Tracks the shutdown state.
        // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.
        this._shutdown = false;
        this._aggregationSelector = (_a = options === null || options === void 0 ? void 0 : options.aggregationSelector) !== null && _a !== void 0 ? _a : (0, _aggregationSelector.DEFAULT_AGGREGATION_SELECTOR);
        this._aggregationTemporalitySelector = (_b = options === null || options === void 0 ? void 0 : options.aggregationTemporalitySelector) !== null && _b !== void 0 ? _b : (0, _aggregationSelector.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR);
        this._metricProducers = (_c = options === null || options === void 0 ? void 0 : options.metricProducers) !== null && _c !== void 0 ? _c : [];
        this._cardinalitySelector = options === null || options === void 0 ? void 0 : options.cardinalitySelector;
    }
    /**
     * Set the {@link MetricProducer} used by this instance. **This should only be called by the
     * SDK and should be considered internal.**
     *
     * To add additional {@link MetricProducer}s to a {@link MetricReader}, pass them to the
     * constructor as {@link MetricReaderOptions.metricProducers}.
     *
     * @internal
     * @param metricProducer
     */ MetricReader.prototype.setMetricProducer = function(metricProducer) {
        if (this._sdkMetricProducer) throw new Error('MetricReader can not be bound to a MeterProvider again.');
        this._sdkMetricProducer = metricProducer;
        this.onInitialized();
    };
    /**
     * Select the {@link Aggregation} for the given {@link InstrumentType} for this
     * reader.
     */ MetricReader.prototype.selectAggregation = function(instrumentType) {
        return this._aggregationSelector(instrumentType);
    };
    /**
     * Select the {@link AggregationTemporality} for the given
     * {@link InstrumentType} for this reader.
     */ MetricReader.prototype.selectAggregationTemporality = function(instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
    };
    /**
     * Select the cardinality limit for the given {@link InstrumentType} for this
     * reader.
     */ MetricReader.prototype.selectCardinalityLimit = function(instrumentType) {
        return this._cardinalitySelector ? this._cardinalitySelector(instrumentType) : 2000; // default value if no selector is provided
    };
    /**
     * Handle once the SDK has initialized this {@link MetricReader}
     * Overriding this method is optional.
     */ MetricReader.prototype.onInitialized = function() {
    // Default implementation is empty.
    };
    /**
     * Collect all metrics from the associated {@link MetricProducer}
     */ MetricReader.prototype.collect = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            var _a, sdkCollectionResults, additionalCollectionResults, errors, resource, scopeMetrics;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        if (this._sdkMetricProducer === undefined) throw new Error('MetricReader is not bound to a MetricProducer');
                        // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.
                        if (this._shutdown) throw new Error('MetricReader is shutdown');
                        return [
                            4 /*yield*/ ,
                            Promise.all(__spreadArray([
                                this._sdkMetricProducer.collect({
                                    timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis
                                })
                            ], __read(this._metricProducers.map(function(producer) {
                                return producer.collect({
                                    timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis
                                });
                            })), false))
                        ];
                    case 1:
                        _a = __read.apply(void 0, [
                            _b.sent()
                        ]), sdkCollectionResults = _a[0], additionalCollectionResults = _a.slice(1);
                        errors = sdkCollectionResults.errors.concat((0, _utils.FlatMap)(additionalCollectionResults, function(result) {
                            return result.errors;
                        }));
                        resource = sdkCollectionResults.resourceMetrics.resource;
                        scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat((0, _utils.FlatMap)(additionalCollectionResults, function(result) {
                            return result.resourceMetrics.scopeMetrics;
                        }));
                        return [
                            2 /*return*/ ,
                            {
                                resourceMetrics: {
                                    resource: resource,
                                    scopeMetrics: scopeMetrics
                                },
                                errors: errors
                            }
                        ];
                }
            });
        });
    };
    /**
     * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.
     *
     * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
     * @param options options with timeout.
     */ MetricReader.prototype.shutdown = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        // Do not call shutdown again if it has already been called.
                        if (this._shutdown) {
                            _api.diag.error('Cannot call shutdown twice.');
                            return [
                                2 /*return*/ 
                            ];
                        }
                        if (!((options === null || options === void 0 ? void 0 : options.timeoutMillis) == null)) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.onShutdown()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            4
                        ];
                    case 2:
                        return [
                            4 /*yield*/ ,
                            (0, _utils.callWithTimeout)(this.onShutdown(), options.timeoutMillis)
                        ];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        this._shutdown = true;
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.
     *
     * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
     * @param options options with timeout.
     */ MetricReader.prototype.forceFlush = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this._shutdown) {
                            _api.diag.warn('Cannot forceFlush on already shutdown MetricReader.');
                            return [
                                2 /*return*/ 
                            ];
                        }
                        if (!((options === null || options === void 0 ? void 0 : options.timeoutMillis) == null)) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.onForceFlush()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                    case 2:
                        return [
                            4 /*yield*/ ,
                            (0, _utils.callWithTimeout)(this.onForceFlush(), options.timeoutMillis)
                        ];
                    case 3:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return MetricReader;
}();

},{"@opentelemetry/api":"6AC4z","../utils":"ai7q3","./AggregationSelector":"9BrXY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ai7q3":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNotNullish", ()=>isNotNullish);
/**
 * Converting the unordered attributes into unique identifier string.
 * @param attributes user provided unordered Attributes.
 */ parcelHelpers.export(exports, "hashAttributes", ()=>hashAttributes);
/**
 * Converting the instrumentation scope object to a unique identifier string.
 * @param instrumentationScope
 */ parcelHelpers.export(exports, "instrumentationScopeId", ()=>instrumentationScopeId);
parcelHelpers.export(exports, "TimeoutError", ()=>TimeoutError);
/**
 * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise
 * rejects, and resolves if the specified promise resolves.
 *
 * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.
 *
 * @param promise promise to use with timeout.
 * @param timeout the timeout in milliseconds until the returned promise is rejected.
 */ parcelHelpers.export(exports, "callWithTimeout", ()=>callWithTimeout);
/**
 * Node.js v12.9 lower and browser compatible `Promise.allSettled`.
 */ parcelHelpers.export(exports, "PromiseAllSettled", ()=>PromiseAllSettled);
parcelHelpers.export(exports, "isPromiseAllSettledRejectionResult", ()=>isPromiseAllSettledRejectionResult);
/**
 * Node.js v11.0 lower and browser compatible `Array.prototype.flatMap`.
 */ parcelHelpers.export(exports, "FlatMap", ()=>FlatMap);
parcelHelpers.export(exports, "setEquals", ()=>setEquals);
/**
 * Binary search the sorted array to the find upper bound for the value.
 * @param arr
 * @param value
 * @returns
 */ parcelHelpers.export(exports, "binarySearchUB", ()=>binarySearchUB);
parcelHelpers.export(exports, "equalsCaseInsensitive", ()=>equalsCaseInsensitive);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function isNotNullish(item) {
    return item !== undefined && item !== null;
}
function hashAttributes(attributes) {
    var keys = Object.keys(attributes);
    if (keys.length === 0) return '';
    // Return a string that is stable on key orders.
    keys = keys.sort();
    return JSON.stringify(keys.map(function(key) {
        return [
            key,
            attributes[key]
        ];
    }));
}
function instrumentationScopeId(instrumentationScope) {
    var _a, _b;
    return instrumentationScope.name + ":" + ((_a = instrumentationScope.version) !== null && _a !== void 0 ? _a : '') + ":" + ((_b = instrumentationScope.schemaUrl) !== null && _b !== void 0 ? _b : '');
}
/**
 * Error that is thrown on timeouts.
 */ var TimeoutError = /** @class */ function(_super) {
    __extends(TimeoutError, _super);
    function TimeoutError(message) {
        var _this = _super.call(this, message) || this;
        // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:
        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error);
function callWithTimeout(promise, timeout) {
    var timeoutHandle;
    var timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
            reject(new TimeoutError('Operation timed out.'));
        }, timeout);
    });
    return Promise.race([
        promise,
        timeoutPromise
    ]).then(function(result) {
        clearTimeout(timeoutHandle);
        return result;
    }, function(reason) {
        clearTimeout(timeoutHandle);
        throw reason;
    });
}
function PromiseAllSettled(promises) {
    return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a) {
            return [
                2 /*return*/ ,
                Promise.all(promises.map(function(p) {
                    return __awaiter(_this, void 0, void 0, function() {
                        var ret, e_1;
                        return __generator(this, function(_a) {
                            switch(_a.label){
                                case 0:
                                    _a.trys.push([
                                        0,
                                        2,
                                        ,
                                        3
                                    ]);
                                    return [
                                        4 /*yield*/ ,
                                        p
                                    ];
                                case 1:
                                    ret = _a.sent();
                                    return [
                                        2 /*return*/ ,
                                        {
                                            status: 'fulfilled',
                                            value: ret
                                        }
                                    ];
                                case 2:
                                    e_1 = _a.sent();
                                    return [
                                        2 /*return*/ ,
                                        {
                                            status: 'rejected',
                                            reason: e_1
                                        }
                                    ];
                                case 3:
                                    return [
                                        2 /*return*/ 
                                    ];
                            }
                        });
                    });
                }))
            ];
        });
    });
}
function isPromiseAllSettledRejectionResult(it) {
    return it.status === 'rejected';
}
function FlatMap(arr, fn) {
    var result = [];
    arr.forEach(function(it) {
        result.push.apply(result, __spreadArray([], __read(fn(it)), false));
    });
    return result;
}
function setEquals(lhs, rhs) {
    var e_2, _a;
    if (lhs.size !== rhs.size) return false;
    try {
        for(var lhs_1 = __values(lhs), lhs_1_1 = lhs_1.next(); !lhs_1_1.done; lhs_1_1 = lhs_1.next()){
            var item = lhs_1_1.value;
            if (!rhs.has(item)) return false;
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (lhs_1_1 && !lhs_1_1.done && (_a = lhs_1.return)) _a.call(lhs_1);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return true;
}
function binarySearchUB(arr, value) {
    var lo = 0;
    var hi = arr.length - 1;
    var ret = arr.length;
    while(hi >= lo){
        var mid = lo + Math.trunc((hi - lo) / 2);
        if (arr[mid] < value) lo = mid + 1;
        else {
            ret = mid;
            hi = mid - 1;
        }
    }
    return ret;
}
function equalsCaseInsensitive(lhs, rhs) {
    return lhs.toLowerCase() === rhs.toLowerCase();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9BrXY":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_AGGREGATION_SELECTOR", ()=>DEFAULT_AGGREGATION_SELECTOR);
parcelHelpers.export(exports, "DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR", ()=>DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR);
var _aggregation = require("../view/Aggregation");
var _aggregationTemporality = require("./AggregationTemporality");
var DEFAULT_AGGREGATION_SELECTOR = function(_instrumentType) {
    return (0, _aggregation.Aggregation).Default();
};
var DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = function(_instrumentType) {
    return (0, _aggregationTemporality.AggregationTemporality).CUMULATIVE;
};

},{"../view/Aggregation":"bu2d1","./AggregationTemporality":"Gkq0r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bu2d1":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Aggregation", ()=>Aggregation);
parcelHelpers.export(exports, "DropAggregation", ()=>DropAggregation);
parcelHelpers.export(exports, "SumAggregation", ()=>SumAggregation);
parcelHelpers.export(exports, "LastValueAggregation", ()=>LastValueAggregation);
parcelHelpers.export(exports, "HistogramAggregation", ()=>HistogramAggregation);
parcelHelpers.export(exports, "ExplicitBucketHistogramAggregation", ()=>ExplicitBucketHistogramAggregation);
parcelHelpers.export(exports, "ExponentialHistogramAggregation", ()=>ExponentialHistogramAggregation);
parcelHelpers.export(exports, "DefaultAggregation", ()=>DefaultAggregation);
var _api = require("@opentelemetry/api");
var _aggregator = require("../aggregator");
var _instrumentDescriptor = require("../InstrumentDescriptor");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Configures how measurements are combined into metrics for views.
 *
 * Aggregation provides a set of built-in aggregations via static methods.
 */ var Aggregation = /** @class */ function() {
    function Aggregation() {}
    Aggregation.Drop = function() {
        return DROP_AGGREGATION;
    };
    Aggregation.Sum = function() {
        return SUM_AGGREGATION;
    };
    Aggregation.LastValue = function() {
        return LAST_VALUE_AGGREGATION;
    };
    Aggregation.Histogram = function() {
        return HISTOGRAM_AGGREGATION;
    };
    Aggregation.ExponentialHistogram = function() {
        return EXPONENTIAL_HISTOGRAM_AGGREGATION;
    };
    Aggregation.Default = function() {
        return DEFAULT_AGGREGATION;
    };
    return Aggregation;
}();
/**
 * The default drop aggregation.
 */ var DropAggregation = /** @class */ function(_super) {
    __extends(DropAggregation, _super);
    function DropAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DropAggregation.prototype.createAggregator = function(_instrument) {
        return DropAggregation.DEFAULT_INSTANCE;
    };
    DropAggregation.DEFAULT_INSTANCE = new (0, _aggregator.DropAggregator)();
    return DropAggregation;
}(Aggregation);
/**
 * The default sum aggregation.
 */ var SumAggregation = /** @class */ function(_super) {
    __extends(SumAggregation, _super);
    function SumAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SumAggregation.prototype.createAggregator = function(instrument) {
        switch(instrument.type){
            case (0, _instrumentDescriptor.InstrumentType).COUNTER:
            case (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_COUNTER:
            case (0, _instrumentDescriptor.InstrumentType).HISTOGRAM:
                return SumAggregation.MONOTONIC_INSTANCE;
            default:
                return SumAggregation.NON_MONOTONIC_INSTANCE;
        }
    };
    SumAggregation.MONOTONIC_INSTANCE = new (0, _aggregator.SumAggregator)(true);
    SumAggregation.NON_MONOTONIC_INSTANCE = new (0, _aggregator.SumAggregator)(false);
    return SumAggregation;
}(Aggregation);
/**
 * The default last value aggregation.
 */ var LastValueAggregation = /** @class */ function(_super) {
    __extends(LastValueAggregation, _super);
    function LastValueAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LastValueAggregation.prototype.createAggregator = function(_instrument) {
        return LastValueAggregation.DEFAULT_INSTANCE;
    };
    LastValueAggregation.DEFAULT_INSTANCE = new (0, _aggregator.LastValueAggregator)();
    return LastValueAggregation;
}(Aggregation);
/**
 * The default histogram aggregation.
 */ var HistogramAggregation = /** @class */ function(_super) {
    __extends(HistogramAggregation, _super);
    function HistogramAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HistogramAggregation.prototype.createAggregator = function(_instrument) {
        return HistogramAggregation.DEFAULT_INSTANCE;
    };
    HistogramAggregation.DEFAULT_INSTANCE = new (0, _aggregator.HistogramAggregator)([
        0,
        5,
        10,
        25,
        50,
        75,
        100,
        250,
        500,
        750,
        1000,
        2500,
        5000,
        7500,
        10000
    ], true);
    return HistogramAggregation;
}(Aggregation);
/**
 * The explicit bucket histogram aggregation.
 */ var ExplicitBucketHistogramAggregation = /** @class */ function(_super) {
    __extends(ExplicitBucketHistogramAggregation, _super);
    /**
     * @param boundaries the bucket boundaries of the histogram aggregation
     * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
     */ function ExplicitBucketHistogramAggregation(boundaries, _recordMinMax) {
        if (_recordMinMax === void 0) _recordMinMax = true;
        var _this = _super.call(this) || this;
        _this._recordMinMax = _recordMinMax;
        if (boundaries == null) throw new Error('ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array');
        // Copy the boundaries array for modification.
        boundaries = boundaries.concat();
        // We need to an ordered set to be able to correctly compute count for each
        // boundary since we'll iterate on each in order.
        boundaries = boundaries.sort(function(a, b) {
            return a - b;
        });
        // Remove all Infinity from the boundaries.
        var minusInfinityIndex = boundaries.lastIndexOf(-Infinity);
        var infinityIndex = boundaries.indexOf(Infinity);
        if (infinityIndex === -1) infinityIndex = undefined;
        _this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
        return _this;
    }
    ExplicitBucketHistogramAggregation.prototype.createAggregator = function(_instrument) {
        return new (0, _aggregator.HistogramAggregator)(this._boundaries, this._recordMinMax);
    };
    return ExplicitBucketHistogramAggregation;
}(Aggregation);
var ExponentialHistogramAggregation = /** @class */ function(_super) {
    __extends(ExponentialHistogramAggregation, _super);
    function ExponentialHistogramAggregation(_maxSize, _recordMinMax) {
        if (_maxSize === void 0) _maxSize = 160;
        if (_recordMinMax === void 0) _recordMinMax = true;
        var _this = _super.call(this) || this;
        _this._maxSize = _maxSize;
        _this._recordMinMax = _recordMinMax;
        return _this;
    }
    ExponentialHistogramAggregation.prototype.createAggregator = function(_instrument) {
        return new (0, _aggregator.ExponentialHistogramAggregator)(this._maxSize, this._recordMinMax);
    };
    return ExponentialHistogramAggregation;
}(Aggregation);
/**
 * The default aggregation.
 */ var DefaultAggregation = /** @class */ function(_super) {
    __extends(DefaultAggregation, _super);
    function DefaultAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultAggregation.prototype._resolve = function(instrument) {
        // cast to unknown to disable complaints on the (unreachable) fallback.
        switch(instrument.type){
            case (0, _instrumentDescriptor.InstrumentType).COUNTER:
            case (0, _instrumentDescriptor.InstrumentType).UP_DOWN_COUNTER:
            case (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_COUNTER:
            case (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_UP_DOWN_COUNTER:
                return SUM_AGGREGATION;
            case (0, _instrumentDescriptor.InstrumentType).GAUGE:
            case (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_GAUGE:
                return LAST_VALUE_AGGREGATION;
            case (0, _instrumentDescriptor.InstrumentType).HISTOGRAM:
                if (instrument.advice.explicitBucketBoundaries) return new ExplicitBucketHistogramAggregation(instrument.advice.explicitBucketBoundaries);
                return HISTOGRAM_AGGREGATION;
        }
        _api.diag.warn("Unable to recognize instrument type: " + instrument.type);
        return DROP_AGGREGATION;
    };
    DefaultAggregation.prototype.createAggregator = function(instrument) {
        return this._resolve(instrument).createAggregator(instrument);
    };
    return DefaultAggregation;
}(Aggregation);
var DROP_AGGREGATION = new DropAggregation();
var SUM_AGGREGATION = new SumAggregation();
var LAST_VALUE_AGGREGATION = new LastValueAggregation();
var HISTOGRAM_AGGREGATION = new HistogramAggregation();
var EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation();
var DEFAULT_AGGREGATION = new DefaultAggregation();

},{"@opentelemetry/api":"6AC4z","../aggregator":"1Fnsf","../InstrumentDescriptor":"ibIoU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Fnsf":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DropAggregator", ()=>(0, _drop.DropAggregator));
parcelHelpers.export(exports, "HistogramAccumulation", ()=>(0, _histogram.HistogramAccumulation));
parcelHelpers.export(exports, "HistogramAggregator", ()=>(0, _histogram.HistogramAggregator));
parcelHelpers.export(exports, "ExponentialHistogramAccumulation", ()=>(0, _exponentialHistogram.ExponentialHistogramAccumulation));
parcelHelpers.export(exports, "ExponentialHistogramAggregator", ()=>(0, _exponentialHistogram.ExponentialHistogramAggregator));
parcelHelpers.export(exports, "LastValueAccumulation", ()=>(0, _lastValue.LastValueAccumulation));
parcelHelpers.export(exports, "LastValueAggregator", ()=>(0, _lastValue.LastValueAggregator));
parcelHelpers.export(exports, "SumAccumulation", ()=>(0, _sum.SumAccumulation));
parcelHelpers.export(exports, "SumAggregator", ()=>(0, _sum.SumAggregator));
var _drop = require("./Drop");
var _histogram = require("./Histogram");
var _exponentialHistogram = require("./ExponentialHistogram");
var _lastValue = require("./LastValue");
var _sum = require("./Sum");

},{"./Drop":"8mNiX","./Histogram":"5zEFS","./ExponentialHistogram":"kEAT3","./LastValue":"eCQSK","./Sum":"fspee","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8mNiX":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DropAggregator", ()=>DropAggregator);
var _types = require("./types");
/** Basic aggregator for None which keeps no recorded value. */ var DropAggregator = /** @class */ function() {
    function DropAggregator() {
        this.kind = (0, _types.AggregatorKind).DROP;
    }
    DropAggregator.prototype.createAccumulation = function() {
        return undefined;
    };
    DropAggregator.prototype.merge = function(_previous, _delta) {
        return undefined;
    };
    DropAggregator.prototype.diff = function(_previous, _current) {
        return undefined;
    };
    DropAggregator.prototype.toMetricData = function(_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
        return undefined;
    };
    return DropAggregator;
}();

},{"./types":"5JQCw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JQCw":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** The kind of aggregator. */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AggregatorKind", ()=>AggregatorKind);
var AggregatorKind;
(function(AggregatorKind) {
    AggregatorKind[AggregatorKind["DROP"] = 0] = "DROP";
    AggregatorKind[AggregatorKind["SUM"] = 1] = "SUM";
    AggregatorKind[AggregatorKind["LAST_VALUE"] = 2] = "LAST_VALUE";
    AggregatorKind[AggregatorKind["HISTOGRAM"] = 3] = "HISTOGRAM";
    AggregatorKind[AggregatorKind["EXPONENTIAL_HISTOGRAM"] = 4] = "EXPONENTIAL_HISTOGRAM";
})(AggregatorKind || (AggregatorKind = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5zEFS":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HistogramAccumulation", ()=>HistogramAccumulation);
parcelHelpers.export(exports, "HistogramAggregator", ()=>HistogramAggregator);
var _types = require("./types");
var _metricData = require("../export/MetricData");
var _instrumentDescriptor = require("../InstrumentDescriptor");
var _utils = require("../utils");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
function createNewEmptyCheckpoint(boundaries) {
    var counts = boundaries.map(function() {
        return 0;
    });
    counts.push(0);
    return {
        buckets: {
            boundaries: boundaries,
            counts: counts
        },
        sum: 0,
        count: 0,
        hasMinMax: false,
        min: Infinity,
        max: -Infinity
    };
}
var HistogramAccumulation = /** @class */ function() {
    function HistogramAccumulation(startTime, _boundaries, _recordMinMax, _current) {
        if (_recordMinMax === void 0) _recordMinMax = true;
        if (_current === void 0) _current = createNewEmptyCheckpoint(_boundaries);
        this.startTime = startTime;
        this._boundaries = _boundaries;
        this._recordMinMax = _recordMinMax;
        this._current = _current;
    }
    HistogramAccumulation.prototype.record = function(value) {
        // NaN does not fall into any bucket, is not zero and should not be counted,
        // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.
        if (Number.isNaN(value)) return;
        this._current.count += 1;
        this._current.sum += value;
        if (this._recordMinMax) {
            this._current.min = Math.min(value, this._current.min);
            this._current.max = Math.max(value, this._current.max);
            this._current.hasMinMax = true;
        }
        var idx = (0, _utils.binarySearchUB)(this._boundaries, value);
        this._current.buckets.counts[idx] += 1;
    };
    HistogramAccumulation.prototype.setStartTime = function(startTime) {
        this.startTime = startTime;
    };
    HistogramAccumulation.prototype.toPointValue = function() {
        return this._current;
    };
    return HistogramAccumulation;
}();
/**
 * Basic aggregator which observes events and counts them in pre-defined buckets
 * and provides the total sum and count of all observations.
 */ var HistogramAggregator = /** @class */ function() {
    /**
     * @param _boundaries sorted upper bounds of recorded values.
     * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
     */ function HistogramAggregator(_boundaries, _recordMinMax) {
        this._boundaries = _boundaries;
        this._recordMinMax = _recordMinMax;
        this.kind = (0, _types.AggregatorKind).HISTOGRAM;
    }
    HistogramAggregator.prototype.createAccumulation = function(startTime) {
        return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
    };
    /**
     * Return the result of the merge of two histogram accumulations. As long as one Aggregator
     * instance produces all Accumulations with constant boundaries we don't need to worry about
     * merging accumulations with different boundaries.
     */ HistogramAggregator.prototype.merge = function(previous, delta) {
        var previousValue = previous.toPointValue();
        var deltaValue = delta.toPointValue();
        var previousCounts = previousValue.buckets.counts;
        var deltaCounts = deltaValue.buckets.counts;
        var mergedCounts = new Array(previousCounts.length);
        for(var idx = 0; idx < previousCounts.length; idx++)mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
        var min = Infinity;
        var max = -Infinity;
        if (this._recordMinMax) {
            if (previousValue.hasMinMax && deltaValue.hasMinMax) {
                min = Math.min(previousValue.min, deltaValue.min);
                max = Math.max(previousValue.max, deltaValue.max);
            } else if (previousValue.hasMinMax) {
                min = previousValue.min;
                max = previousValue.max;
            } else if (deltaValue.hasMinMax) {
                min = deltaValue.min;
                max = deltaValue.max;
            }
        }
        return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
            buckets: {
                boundaries: previousValue.buckets.boundaries,
                counts: mergedCounts
            },
            count: previousValue.count + deltaValue.count,
            sum: previousValue.sum + deltaValue.sum,
            hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
            min: min,
            max: max
        });
    };
    /**
     * Returns a new DELTA aggregation by comparing two cumulative measurements.
     */ HistogramAggregator.prototype.diff = function(previous, current) {
        var previousValue = previous.toPointValue();
        var currentValue = current.toPointValue();
        var previousCounts = previousValue.buckets.counts;
        var currentCounts = currentValue.buckets.counts;
        var diffedCounts = new Array(previousCounts.length);
        for(var idx = 0; idx < previousCounts.length; idx++)diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
        return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
            buckets: {
                boundaries: previousValue.buckets.boundaries,
                counts: diffedCounts
            },
            count: currentValue.count - previousValue.count,
            sum: currentValue.sum - previousValue.sum,
            hasMinMax: false,
            min: Infinity,
            max: -Infinity
        });
    };
    HistogramAggregator.prototype.toMetricData = function(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
            descriptor: descriptor,
            aggregationTemporality: aggregationTemporality,
            dataPointType: (0, _metricData.DataPointType).HISTOGRAM,
            dataPoints: accumulationByAttributes.map(function(_a) {
                var _b = __read(_a, 2), attributes = _b[0], accumulation = _b[1];
                var pointValue = accumulation.toPointValue();
                // determine if instrument allows negative values.
                var allowsNegativeValues = descriptor.type === (0, _instrumentDescriptor.InstrumentType).GAUGE || descriptor.type === (0, _instrumentDescriptor.InstrumentType).UP_DOWN_COUNTER || descriptor.type === (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_GAUGE || descriptor.type === (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_UP_DOWN_COUNTER;
                return {
                    attributes: attributes,
                    startTime: accumulation.startTime,
                    endTime: endTime,
                    value: {
                        min: pointValue.hasMinMax ? pointValue.min : undefined,
                        max: pointValue.hasMinMax ? pointValue.max : undefined,
                        sum: !allowsNegativeValues ? pointValue.sum : undefined,
                        buckets: pointValue.buckets,
                        count: pointValue.count
                    }
                };
            })
        };
    };
    return HistogramAggregator;
}();

},{"./types":"5JQCw","../export/MetricData":"buI5y","../InstrumentDescriptor":"ibIoU","../utils":"ai7q3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ibIoU":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentType", ()=>InstrumentType);
parcelHelpers.export(exports, "createInstrumentDescriptor", ()=>createInstrumentDescriptor);
parcelHelpers.export(exports, "createInstrumentDescriptorWithView", ()=>createInstrumentDescriptorWithView);
parcelHelpers.export(exports, "isDescriptorCompatibleWith", ()=>isDescriptorCompatibleWith);
parcelHelpers.export(exports, "isValidName", ()=>isValidName);
var _api = require("@opentelemetry/api");
var _utils = require("./utils");
var InstrumentType;
(function(InstrumentType) {
    InstrumentType["COUNTER"] = "COUNTER";
    InstrumentType["GAUGE"] = "GAUGE";
    InstrumentType["HISTOGRAM"] = "HISTOGRAM";
    InstrumentType["UP_DOWN_COUNTER"] = "UP_DOWN_COUNTER";
    InstrumentType["OBSERVABLE_COUNTER"] = "OBSERVABLE_COUNTER";
    InstrumentType["OBSERVABLE_GAUGE"] = "OBSERVABLE_GAUGE";
    InstrumentType["OBSERVABLE_UP_DOWN_COUNTER"] = "OBSERVABLE_UP_DOWN_COUNTER";
})(InstrumentType || (InstrumentType = {}));
function createInstrumentDescriptor(name, type, options) {
    var _a, _b, _c, _d;
    if (!isValidName(name)) (0, _api.diag).warn("Invalid metric name: \"" + name + "\". The metric name should be a ASCII string with a length no greater than 255 characters.");
    return {
        name: name,
        type: type,
        description: (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : '',
        unit: (_b = options === null || options === void 0 ? void 0 : options.unit) !== null && _b !== void 0 ? _b : '',
        valueType: (_c = options === null || options === void 0 ? void 0 : options.valueType) !== null && _c !== void 0 ? _c : (0, _api.ValueType).DOUBLE,
        advice: (_d = options === null || options === void 0 ? void 0 : options.advice) !== null && _d !== void 0 ? _d : {}
    };
}
function createInstrumentDescriptorWithView(view, instrument) {
    var _a, _b;
    return {
        name: (_a = view.name) !== null && _a !== void 0 ? _a : instrument.name,
        description: (_b = view.description) !== null && _b !== void 0 ? _b : instrument.description,
        type: instrument.type,
        unit: instrument.unit,
        valueType: instrument.valueType,
        advice: instrument.advice
    };
}
function isDescriptorCompatibleWith(descriptor, otherDescriptor) {
    // Names are case-insensitive strings.
    return (0, _utils.equalsCaseInsensitive)(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;
}
// ASCII string with a length no greater than 255 characters.
// NB: the first character counted separately from the rest.
var NAME_REGEXP = /^[a-z][a-z0-9_.\-/]{0,254}$/i;
function isValidName(name) {
    return name.match(NAME_REGEXP) != null;
}

},{"@opentelemetry/api":"6AC4z","./utils":"ai7q3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kEAT3":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExponentialHistogramAccumulation", ()=>ExponentialHistogramAccumulation);
parcelHelpers.export(exports, "ExponentialHistogramAggregator", ()=>ExponentialHistogramAggregator);
var _types = require("./types");
var _metricData = require("../export/MetricData");
var _api = require("@opentelemetry/api");
var _instrumentDescriptor = require("../InstrumentDescriptor");
var _buckets = require("./exponential-histogram/Buckets");
var _getMapping = require("./exponential-histogram/mapping/getMapping");
var _util = require("./exponential-histogram/util");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
// HighLow is a utility class used for computing a common scale for
// two exponential histogram accumulations
var HighLow = /** @class */ function() {
    function HighLow(low, high) {
        this.low = low;
        this.high = high;
    }
    HighLow.combine = function(h1, h2) {
        return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));
    };
    return HighLow;
}();
var MAX_SCALE = 20;
var DEFAULT_MAX_SIZE = 160;
var MIN_MAX_SIZE = 2;
var ExponentialHistogramAccumulation = /** @class */ function() {
    function ExponentialHistogramAccumulation(startTime, _maxSize, _recordMinMax, _sum, _count, _zeroCount, _min, _max, _positive, _negative, _mapping) {
        if (startTime === void 0) startTime;
        if (_maxSize === void 0) _maxSize = DEFAULT_MAX_SIZE;
        if (_recordMinMax === void 0) _recordMinMax = true;
        if (_sum === void 0) _sum = 0;
        if (_count === void 0) _count = 0;
        if (_zeroCount === void 0) _zeroCount = 0;
        if (_min === void 0) _min = Number.POSITIVE_INFINITY;
        if (_max === void 0) _max = Number.NEGATIVE_INFINITY;
        if (_positive === void 0) _positive = new (0, _buckets.Buckets)();
        if (_negative === void 0) _negative = new (0, _buckets.Buckets)();
        if (_mapping === void 0) _mapping = (0, _getMapping.getMapping)(MAX_SCALE);
        this.startTime = startTime;
        this._maxSize = _maxSize;
        this._recordMinMax = _recordMinMax;
        this._sum = _sum;
        this._count = _count;
        this._zeroCount = _zeroCount;
        this._min = _min;
        this._max = _max;
        this._positive = _positive;
        this._negative = _negative;
        this._mapping = _mapping;
        if (this._maxSize < MIN_MAX_SIZE) {
            (0, _api.diag).warn("Exponential Histogram Max Size set to " + this._maxSize + ",                 changing to the minimum size of: " + MIN_MAX_SIZE);
            this._maxSize = MIN_MAX_SIZE;
        }
    }
    /**
     * record updates a histogram with a single count
     * @param {Number} value
     */ ExponentialHistogramAccumulation.prototype.record = function(value) {
        this.updateByIncrement(value, 1);
    };
    /**
     * Sets the start time for this accumulation
     * @param {HrTime} startTime
     */ ExponentialHistogramAccumulation.prototype.setStartTime = function(startTime) {
        this.startTime = startTime;
    };
    /**
     * Returns the datapoint representation of this accumulation
     * @param {HrTime} startTime
     */ ExponentialHistogramAccumulation.prototype.toPointValue = function() {
        return {
            hasMinMax: this._recordMinMax,
            min: this.min,
            max: this.max,
            sum: this.sum,
            positive: {
                offset: this.positive.offset,
                bucketCounts: this.positive.counts()
            },
            negative: {
                offset: this.negative.offset,
                bucketCounts: this.negative.counts()
            },
            count: this.count,
            scale: this.scale,
            zeroCount: this.zeroCount
        };
    };
    Object.defineProperty(ExponentialHistogramAccumulation.prototype, "sum", {
        /**
         * @returns {Number} The sum of values recorded by this accumulation
         */ get: function() {
            return this._sum;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExponentialHistogramAccumulation.prototype, "min", {
        /**
         * @returns {Number} The minimum value recorded by this accumulation
         */ get: function() {
            return this._min;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExponentialHistogramAccumulation.prototype, "max", {
        /**
         * @returns {Number} The maximum value recorded by this accumulation
         */ get: function() {
            return this._max;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExponentialHistogramAccumulation.prototype, "count", {
        /**
         * @returns {Number} The count of values recorded by this accumulation
         */ get: function() {
            return this._count;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExponentialHistogramAccumulation.prototype, "zeroCount", {
        /**
         * @returns {Number} The number of 0 values recorded by this accumulation
         */ get: function() {
            return this._zeroCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExponentialHistogramAccumulation.prototype, "scale", {
        /**
         * @returns {Number} The scale used by this accumulation
         */ get: function() {
            if (this._count === this._zeroCount) // all zeros! scale doesn't matter, use zero
            return 0;
            return this._mapping.scale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExponentialHistogramAccumulation.prototype, "positive", {
        /**
         * positive holds the positive values
         * @returns {Buckets}
         */ get: function() {
            return this._positive;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExponentialHistogramAccumulation.prototype, "negative", {
        /**
         * negative holds the negative values by their absolute value
         * @returns {Buckets}
         */ get: function() {
            return this._negative;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * updateByIncr supports updating a histogram with a non-negative
     * increment.
     * @param value
     * @param increment
     */ ExponentialHistogramAccumulation.prototype.updateByIncrement = function(value, increment) {
        // NaN does not fall into any bucket, is not zero and should not be counted,
        // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.
        if (Number.isNaN(value)) return;
        if (value > this._max) this._max = value;
        if (value < this._min) this._min = value;
        this._count += increment;
        if (value === 0) {
            this._zeroCount += increment;
            return;
        }
        this._sum += value * increment;
        if (value > 0) this._updateBuckets(this._positive, value, increment);
        else this._updateBuckets(this._negative, -value, increment);
    };
    /**
     * merge combines data from previous value into self
     * @param {ExponentialHistogramAccumulation} previous
     */ ExponentialHistogramAccumulation.prototype.merge = function(previous) {
        if (this._count === 0) {
            this._min = previous.min;
            this._max = previous.max;
        } else if (previous.count !== 0) {
            if (previous.min < this.min) this._min = previous.min;
            if (previous.max > this.max) this._max = previous.max;
        }
        this.startTime = previous.startTime;
        this._sum += previous.sum;
        this._count += previous.count;
        this._zeroCount += previous.zeroCount;
        var minScale = this._minScale(previous);
        this._downscale(this.scale - minScale);
        this._mergeBuckets(this.positive, previous, previous.positive, minScale);
        this._mergeBuckets(this.negative, previous, previous.negative, minScale);
    };
    /**
     * diff subtracts other from self
     * @param {ExponentialHistogramAccumulation} other
     */ ExponentialHistogramAccumulation.prototype.diff = function(other) {
        this._min = Infinity;
        this._max = -Infinity;
        this._sum -= other.sum;
        this._count -= other.count;
        this._zeroCount -= other.zeroCount;
        var minScale = this._minScale(other);
        this._downscale(this.scale - minScale);
        this._diffBuckets(this.positive, other, other.positive, minScale);
        this._diffBuckets(this.negative, other, other.negative, minScale);
    };
    /**
     * clone returns a deep copy of self
     * @returns {ExponentialHistogramAccumulation}
     */ ExponentialHistogramAccumulation.prototype.clone = function() {
        return new ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);
    };
    /**
     * _updateBuckets maps the incoming value to a bucket index for the current
     * scale. If the bucket index is outside of the range of the backing array,
     * it will rescale the backing array and update the mapping for the new scale.
     */ ExponentialHistogramAccumulation.prototype._updateBuckets = function(buckets, value, increment) {
        var index = this._mapping.mapToIndex(value);
        // rescale the mapping if needed
        var rescalingNeeded = false;
        var high = 0;
        var low = 0;
        if (buckets.length === 0) {
            buckets.indexStart = index;
            buckets.indexEnd = buckets.indexStart;
            buckets.indexBase = buckets.indexStart;
        } else if (index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize) {
            rescalingNeeded = true;
            low = index;
            high = buckets.indexEnd;
        } else if (index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize) {
            rescalingNeeded = true;
            low = buckets.indexStart;
            high = index;
        }
        // rescale and compute index at new scale
        if (rescalingNeeded) {
            var change = this._changeScale(high, low);
            this._downscale(change);
            index = this._mapping.mapToIndex(value);
        }
        this._incrementIndexBy(buckets, index, increment);
    };
    /**
     * _incrementIndexBy increments the count of the bucket specified by `index`.
     * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]
     * the boundaries of the backing array will be adjusted and more buckets will
     * be added if needed.
     */ ExponentialHistogramAccumulation.prototype._incrementIndexBy = function(buckets, index, increment) {
        if (increment === 0) // nothing to do for a zero increment, can happen during a merge operation
        return;
        if (buckets.length === 0) buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;
        if (index < buckets.indexStart) {
            var span = buckets.indexEnd - index;
            if (span >= buckets.backing.length) this._grow(buckets, span + 1);
            buckets.indexStart = index;
        } else if (index > buckets.indexEnd) {
            var span = index - buckets.indexStart;
            if (span >= buckets.backing.length) this._grow(buckets, span + 1);
            buckets.indexEnd = index;
        }
        var bucketIndex = index - buckets.indexBase;
        if (bucketIndex < 0) bucketIndex += buckets.backing.length;
        buckets.incrementBucket(bucketIndex, increment);
    };
    /**
     * grow resizes the backing array by doubling in size up to maxSize.
     * This extends the array with a bunch of zeros and copies the
     * existing counts to the same position.
     */ ExponentialHistogramAccumulation.prototype._grow = function(buckets, needed) {
        var size = buckets.backing.length;
        var bias = buckets.indexBase - buckets.indexStart;
        var oldPositiveLimit = size - bias;
        var newSize = (0, _util.nextGreaterSquare)(needed);
        if (newSize > this._maxSize) newSize = this._maxSize;
        var newPositiveLimit = newSize - bias;
        buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);
    };
    /**
     * _changeScale computes how much downscaling is needed by shifting the
     * high and low values until they are separated by no more than size.
     */ ExponentialHistogramAccumulation.prototype._changeScale = function(high, low) {
        var change = 0;
        while(high - low >= this._maxSize){
            high >>= 1;
            low >>= 1;
            change++;
        }
        return change;
    };
    /**
     * _downscale subtracts `change` from the current mapping scale.
     */ ExponentialHistogramAccumulation.prototype._downscale = function(change) {
        if (change === 0) return;
        if (change < 0) // Note: this should be impossible. If we get here it's because
        // there is a bug in the implementation.
        throw new Error("impossible change of scale: " + this.scale);
        var newScale = this._mapping.scale - change;
        this._positive.downscale(change);
        this._negative.downscale(change);
        this._mapping = (0, _getMapping.getMapping)(newScale);
    };
    /**
     * _minScale is used by diff and merge to compute an ideal combined scale
     */ ExponentialHistogramAccumulation.prototype._minScale = function(other) {
        var minScale = Math.min(this.scale, other.scale);
        var highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));
        var highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));
        return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));
    };
    /**
     * _highLowAtScale is used by diff and merge to compute an ideal combined scale.
     */ ExponentialHistogramAccumulation.prototype._highLowAtScale = function(buckets, currentScale, newScale) {
        if (buckets.length === 0) return new HighLow(0, -1);
        var shift = currentScale - newScale;
        return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);
    };
    /**
     * _mergeBuckets translates index values from another histogram and
     * adds the values into the corresponding buckets of this histogram.
     */ ExponentialHistogramAccumulation.prototype._mergeBuckets = function(ours, other, theirs, scale) {
        var theirOffset = theirs.offset;
        var theirChange = other.scale - scale;
        for(var i = 0; i < theirs.length; i++)this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));
    };
    /**
     * _diffBuckets translates index values from another histogram and
     * subtracts the values in the corresponding buckets of this histogram.
     */ ExponentialHistogramAccumulation.prototype._diffBuckets = function(ours, other, theirs, scale) {
        var theirOffset = theirs.offset;
        var theirChange = other.scale - scale;
        for(var i = 0; i < theirs.length; i++){
            var ourIndex = theirOffset + i >> theirChange;
            var bucketIndex = ourIndex - ours.indexBase;
            if (bucketIndex < 0) bucketIndex += ours.backing.length;
            ours.decrementBucket(bucketIndex, theirs.at(i));
        }
        ours.trim();
    };
    return ExponentialHistogramAccumulation;
}();
/**
 * Aggregator for ExponentialHistogramAccumulations
 */ var ExponentialHistogramAggregator = /** @class */ function() {
    /**
     * @param _maxSize Maximum number of buckets for each of the positive
     *    and negative ranges, exclusive of the zero-bucket.
     * @param _recordMinMax If set to true, min and max will be recorded.
     *    Otherwise, min and max will not be recorded.
     */ function ExponentialHistogramAggregator(_maxSize, _recordMinMax) {
        this._maxSize = _maxSize;
        this._recordMinMax = _recordMinMax;
        this.kind = (0, _types.AggregatorKind).EXPONENTIAL_HISTOGRAM;
    }
    ExponentialHistogramAggregator.prototype.createAccumulation = function(startTime) {
        return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);
    };
    /**
     * Return the result of the merge of two exponential histogram accumulations.
     */ ExponentialHistogramAggregator.prototype.merge = function(previous, delta) {
        var result = delta.clone();
        result.merge(previous);
        return result;
    };
    /**
     * Returns a new DELTA aggregation by comparing two cumulative measurements.
     */ ExponentialHistogramAggregator.prototype.diff = function(previous, current) {
        var result = current.clone();
        result.diff(previous);
        return result;
    };
    ExponentialHistogramAggregator.prototype.toMetricData = function(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
            descriptor: descriptor,
            aggregationTemporality: aggregationTemporality,
            dataPointType: (0, _metricData.DataPointType).EXPONENTIAL_HISTOGRAM,
            dataPoints: accumulationByAttributes.map(function(_a) {
                var _b = __read(_a, 2), attributes = _b[0], accumulation = _b[1];
                var pointValue = accumulation.toPointValue();
                // determine if instrument allows negative values.
                var allowsNegativeValues = descriptor.type === (0, _instrumentDescriptor.InstrumentType).GAUGE || descriptor.type === (0, _instrumentDescriptor.InstrumentType).UP_DOWN_COUNTER || descriptor.type === (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_GAUGE || descriptor.type === (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_UP_DOWN_COUNTER;
                return {
                    attributes: attributes,
                    startTime: accumulation.startTime,
                    endTime: endTime,
                    value: {
                        min: pointValue.hasMinMax ? pointValue.min : undefined,
                        max: pointValue.hasMinMax ? pointValue.max : undefined,
                        sum: !allowsNegativeValues ? pointValue.sum : undefined,
                        positive: {
                            offset: pointValue.positive.offset,
                            bucketCounts: pointValue.positive.bucketCounts
                        },
                        negative: {
                            offset: pointValue.negative.offset,
                            bucketCounts: pointValue.negative.bucketCounts
                        },
                        count: pointValue.count,
                        scale: pointValue.scale,
                        zeroCount: pointValue.zeroCount
                    }
                };
            })
        };
    };
    return ExponentialHistogramAggregator;
}();

},{"./types":"5JQCw","../export/MetricData":"buI5y","@opentelemetry/api":"6AC4z","../InstrumentDescriptor":"ibIoU","./exponential-histogram/Buckets":"kjmao","./exponential-histogram/mapping/getMapping":"9KBBN","./exponential-histogram/util":"8Nbvm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kjmao":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Buckets", ()=>Buckets);
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Buckets = /** @class */ function() {
    /**
     * The term index refers to the number of the exponential histogram bucket
     * used to determine its boundaries. The lower boundary of a bucket is
     * determined by base ** index and the upper boundary of a bucket is
     * determined by base ** (index + 1). index values are signed to account
     * for values less than or equal to 1.
     *
     * indexBase is the index of the 0th position in the
     * backing array, i.e., backing[0] is the count
     * in the bucket with index `indexBase`.
     *
     * indexStart is the smallest index value represented
     * in the backing array.
     *
     * indexEnd is the largest index value represented in
     * the backing array.
     */ function Buckets(backing, indexBase, indexStart, indexEnd) {
        if (backing === void 0) backing = new BucketsBacking();
        if (indexBase === void 0) indexBase = 0;
        if (indexStart === void 0) indexStart = 0;
        if (indexEnd === void 0) indexEnd = 0;
        this.backing = backing;
        this.indexBase = indexBase;
        this.indexStart = indexStart;
        this.indexEnd = indexEnd;
    }
    Object.defineProperty(Buckets.prototype, "offset", {
        /**
         * Offset is the bucket index of the smallest entry in the counts array
         * @returns {number}
         */ get: function() {
            return this.indexStart;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Buckets.prototype, "length", {
        /**
         * Buckets is a view into the backing array.
         * @returns {number}
         */ get: function() {
            if (this.backing.length === 0) return 0;
            if (this.indexEnd === this.indexStart && this.at(0) === 0) return 0;
            return this.indexEnd - this.indexStart + 1;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * An array of counts, where count[i] carries the count
     * of the bucket at index (offset+i).  count[i] is the count of
     * values greater than base^(offset+i) and less than or equal to
     * base^(offset+i+1).
     * @returns {number} The logical counts based on the backing array
     */ Buckets.prototype.counts = function() {
        var _this = this;
        return Array.from({
            length: this.length
        }, function(_, i) {
            return _this.at(i);
        });
    };
    /**
     * At returns the count of the bucket at a position in the logical
     * array of counts.
     * @param position
     * @returns {number}
     */ Buckets.prototype.at = function(position) {
        var bias = this.indexBase - this.indexStart;
        if (position < bias) position += this.backing.length;
        position -= bias;
        return this.backing.countAt(position);
    };
    /**
     * incrementBucket increments the backing array index by `increment`
     * @param bucketIndex
     * @param increment
     */ Buckets.prototype.incrementBucket = function(bucketIndex, increment) {
        this.backing.increment(bucketIndex, increment);
    };
    /**
     * decrementBucket decrements the backing array index by `decrement`
     * if decrement is greater than the current value, it's set to 0.
     * @param bucketIndex
     * @param decrement
     */ Buckets.prototype.decrementBucket = function(bucketIndex, decrement) {
        this.backing.decrement(bucketIndex, decrement);
    };
    /**
     * trim removes leading and / or trailing zero buckets (which can occur
     * after diffing two histos) and rotates the backing array so that the
     * smallest non-zero index is in the 0th position of the backing array
     */ Buckets.prototype.trim = function() {
        for(var i = 0; i < this.length; i++){
            if (this.at(i) !== 0) {
                this.indexStart += i;
                break;
            } else if (i === this.length - 1) {
                //the entire array is zeroed out
                this.indexStart = this.indexEnd = this.indexBase = 0;
                return;
            }
        }
        for(var i = this.length - 1; i >= 0; i--)if (this.at(i) !== 0) {
            this.indexEnd -= this.length - i - 1;
            break;
        }
        this._rotate();
    };
    /**
     * downscale first rotates, then collapses 2**`by`-to-1 buckets.
     * @param by
     */ Buckets.prototype.downscale = function(by) {
        this._rotate();
        var size = 1 + this.indexEnd - this.indexStart;
        var each = 1 << by;
        var inpos = 0;
        var outpos = 0;
        for(var pos = this.indexStart; pos <= this.indexEnd;){
            var mod = pos % each;
            if (mod < 0) mod += each;
            for(var i = mod; i < each && inpos < size; i++){
                this._relocateBucket(outpos, inpos);
                inpos++;
                pos++;
            }
            outpos++;
        }
        this.indexStart >>= by;
        this.indexEnd >>= by;
        this.indexBase = this.indexStart;
    };
    /**
     * Clone returns a deep copy of Buckets
     * @returns {Buckets}
     */ Buckets.prototype.clone = function() {
        return new Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);
    };
    /**
     * _rotate shifts the backing array contents so that indexStart ==
     * indexBase to simplify the downscale logic.
     */ Buckets.prototype._rotate = function() {
        var bias = this.indexBase - this.indexStart;
        if (bias === 0) return;
        else if (bias > 0) {
            this.backing.reverse(0, this.backing.length);
            this.backing.reverse(0, bias);
            this.backing.reverse(bias, this.backing.length);
        } else {
            // negative bias, this can happen when diffing two histograms
            this.backing.reverse(0, this.backing.length);
            this.backing.reverse(0, this.backing.length + bias);
        }
        this.indexBase = this.indexStart;
    };
    /**
     * _relocateBucket adds the count in counts[src] to counts[dest] and
     * resets count[src] to zero.
     */ Buckets.prototype._relocateBucket = function(dest, src) {
        if (dest === src) return;
        this.incrementBucket(dest, this.backing.emptyBucket(src));
    };
    return Buckets;
}();
/**
 * BucketsBacking holds the raw buckets and some utility methods to
 * manage them.
 */ var BucketsBacking = /** @class */ function() {
    function BucketsBacking(_counts) {
        if (_counts === void 0) _counts = [
            0
        ];
        this._counts = _counts;
    }
    Object.defineProperty(BucketsBacking.prototype, "length", {
        /**
         * length returns the physical size of the backing array, which
         * is >= buckets.length()
         */ get: function() {
            return this._counts.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * countAt returns the count in a specific bucket
     */ BucketsBacking.prototype.countAt = function(pos) {
        return this._counts[pos];
    };
    /**
     * growTo grows a backing array and copies old entries
     * into their correct new positions.
     */ BucketsBacking.prototype.growTo = function(newSize, oldPositiveLimit, newPositiveLimit) {
        var tmp = new Array(newSize).fill(0);
        tmp.splice.apply(tmp, __spreadArray([
            newPositiveLimit,
            this._counts.length - oldPositiveLimit
        ], __read(this._counts.slice(oldPositiveLimit)), false));
        tmp.splice.apply(tmp, __spreadArray([
            0,
            oldPositiveLimit
        ], __read(this._counts.slice(0, oldPositiveLimit)), false));
        this._counts = tmp;
    };
    /**
     * reverse the items in the backing array in the range [from, limit).
     */ BucketsBacking.prototype.reverse = function(from, limit) {
        var num = Math.floor((from + limit) / 2) - from;
        for(var i = 0; i < num; i++){
            var tmp = this._counts[from + i];
            this._counts[from + i] = this._counts[limit - i - 1];
            this._counts[limit - i - 1] = tmp;
        }
    };
    /**
     * emptyBucket empties the count from a bucket, for
     * moving into another.
     */ BucketsBacking.prototype.emptyBucket = function(src) {
        var tmp = this._counts[src];
        this._counts[src] = 0;
        return tmp;
    };
    /**
     * increments a bucket by `increment`
     */ BucketsBacking.prototype.increment = function(bucketIndex, increment) {
        this._counts[bucketIndex] += increment;
    };
    /**
     * decrements a bucket by `decrement`
     */ BucketsBacking.prototype.decrement = function(bucketIndex, decrement) {
        if (this._counts[bucketIndex] >= decrement) this._counts[bucketIndex] -= decrement;
        else // this should not happen, but we're being defensive against
        // negative counts.
        this._counts[bucketIndex] = 0;
    };
    /**
     * clone returns a deep copy of BucketsBacking
     */ BucketsBacking.prototype.clone = function() {
        return new BucketsBacking(__spreadArray([], __read(this._counts), false));
    };
    return BucketsBacking;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9KBBN":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * getMapping returns an appropriate mapping for the given scale. For scales -10
 * to 0 the underlying type will be ExponentMapping. For scales 1 to 20 the
 * underlying type will be LogarithmMapping.
 * @param scale a number in the range [-10, 20]
 * @returns {Mapping}
 */ parcelHelpers.export(exports, "getMapping", ()=>getMapping);
var _exponentMapping = require("./ExponentMapping");
var _logarithmMapping = require("./LogarithmMapping");
var _types = require("./types");
var MIN_SCALE = -10;
var MAX_SCALE = 20;
var PREBUILT_MAPPINGS = Array.from({
    length: 31
}, function(_, i) {
    if (i > 10) return new (0, _logarithmMapping.LogarithmMapping)(i - 10);
    return new (0, _exponentMapping.ExponentMapping)(i - 10);
});
function getMapping(scale) {
    if (scale > MAX_SCALE || scale < MIN_SCALE) throw new (0, _types.MappingError)("expected scale >= " + MIN_SCALE + " && <= " + MAX_SCALE + ", got: " + scale);
    // mappings are offset by 10. scale -10 is at position 0 and scale 20 is at 30
    return PREBUILT_MAPPINGS[scale + 10];
}

},{"./ExponentMapping":"eLZnC","./LogarithmMapping":"hjsbS","./types":"e2c4b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLZnC":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExponentMapping", ()=>ExponentMapping);
var _ieee754 = require("./ieee754");
var _util = require("../util");
var _types = require("./types");
/**
 * ExponentMapping implements exponential mapping functions for
 * scales <=0. For scales > 0 LogarithmMapping should be used.
 */ var ExponentMapping = /** @class */ function() {
    function ExponentMapping(scale) {
        this._shift = -scale;
    }
    /**
     * Maps positive floating point values to indexes corresponding to scale
     * @param value
     * @returns {number} index for provided value at the current scale
     */ ExponentMapping.prototype.mapToIndex = function(value) {
        if (value < _ieee754.MIN_VALUE) return this._minNormalLowerBoundaryIndex();
        var exp = _ieee754.getNormalBase2(value);
        // In case the value is an exact power of two, compute a
        // correction of -1. Note, we are using a custom _rightShift
        // to accommodate a 52-bit argument, which the native bitwise
        // operators do not support
        var correction = this._rightShift(_ieee754.getSignificand(value) - 1, _ieee754.SIGNIFICAND_WIDTH);
        return exp + correction >> this._shift;
    };
    /**
     * Returns the lower bucket boundary for the given index for scale
     *
     * @param index
     * @returns {number}
     */ ExponentMapping.prototype.lowerBoundary = function(index) {
        var minIndex = this._minNormalLowerBoundaryIndex();
        if (index < minIndex) throw new (0, _types.MappingError)("underflow: " + index + " is < minimum lower boundary: " + minIndex);
        var maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index > maxIndex) throw new (0, _types.MappingError)("overflow: " + index + " is > maximum lower boundary: " + maxIndex);
        return _util.ldexp(1, index << this._shift);
    };
    Object.defineProperty(ExponentMapping.prototype, "scale", {
        /**
         * The scale used by this mapping
         * @returns {number}
         */ get: function() {
            if (this._shift === 0) return 0;
            return -this._shift;
        },
        enumerable: false,
        configurable: true
    });
    ExponentMapping.prototype._minNormalLowerBoundaryIndex = function() {
        var index = _ieee754.MIN_NORMAL_EXPONENT >> this._shift;
        if (this._shift < 2) index--;
        return index;
    };
    ExponentMapping.prototype._maxNormalLowerBoundaryIndex = function() {
        return _ieee754.MAX_NORMAL_EXPONENT >> this._shift;
    };
    ExponentMapping.prototype._rightShift = function(value, shift) {
        return Math.floor(value * Math.pow(2, -shift));
    };
    return ExponentMapping;
}();

},{"./ieee754":"jqjCj","../util":"8Nbvm","./types":"e2c4b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jqjCj":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * The functions and constants in this file allow us to interact
 * with the internal representation of an IEEE 64-bit floating point
 * number. We need to work with all 64-bits, thus, care needs to be
 * taken when working with Javascript's bitwise operators (<<, >>, &,
 * |, etc) as they truncate operands to 32-bits. In order to work around
 * this we work with the 64-bits as two 32-bit halves, perform bitwise
 * operations on them independently, and combine the results (if needed).
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SIGNIFICAND_WIDTH", ()=>SIGNIFICAND_WIDTH);
parcelHelpers.export(exports, "MIN_NORMAL_EXPONENT", ()=>MIN_NORMAL_EXPONENT);
parcelHelpers.export(exports, "MAX_NORMAL_EXPONENT", ()=>MAX_NORMAL_EXPONENT);
parcelHelpers.export(exports, "MIN_VALUE", ()=>MIN_VALUE);
/**
 * getNormalBase2 extracts the normalized base-2 fractional exponent.
 * This returns k for the equation f x 2**k where f is
 * in the range [1, 2).  Note that this function is not called for
 * subnormal numbers.
 * @param {number} value - the value to determine normalized base-2 fractional
 *    exponent for
 * @returns {number} the normalized base-2 exponent
 */ parcelHelpers.export(exports, "getNormalBase2", ()=>getNormalBase2);
/**
 * GetSignificand returns the 52 bit (unsigned) significand as a signed value.
 * @param {number} value - the floating point number to extract the significand from
 * @returns {number} The 52-bit significand
 */ parcelHelpers.export(exports, "getSignificand", ()=>getSignificand);
var SIGNIFICAND_WIDTH = 52;
/**
 * EXPONENT_MASK is set to 1 for the hi 32-bits of an IEEE 754
 * floating point exponent: 0x7ff00000.
 */ var EXPONENT_MASK = 0x7ff00000;
/**
 * SIGNIFICAND_MASK is the mask for the significand portion of the hi 32-bits
 * of an IEEE 754 double-precision floating-point value: 0xfffff
 */ var SIGNIFICAND_MASK = 0xfffff;
/**
 * EXPONENT_BIAS is the exponent bias specified for encoding
 * the IEEE 754 double-precision floating point exponent: 1023
 */ var EXPONENT_BIAS = 1023;
var MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;
var MAX_NORMAL_EXPONENT = EXPONENT_BIAS;
var MIN_VALUE = Math.pow(2, -1022);
function getNormalBase2(value) {
    var dv = new DataView(new ArrayBuffer(8));
    dv.setFloat64(0, value);
    // access the raw 64-bit float as 32-bit uints
    var hiBits = dv.getUint32(0);
    var expBits = (hiBits & EXPONENT_MASK) >> 20;
    return expBits - EXPONENT_BIAS;
}
function getSignificand(value) {
    var dv = new DataView(new ArrayBuffer(8));
    dv.setFloat64(0, value);
    // access the raw 64-bit float as two 32-bit uints
    var hiBits = dv.getUint32(0);
    var loBits = dv.getUint32(4);
    // extract the significand bits from the hi bits and left shift 32 places note:
    // we can't use the native << operator as it will truncate the result to 32-bits
    var significandHiBits = (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32);
    // combine the hi and lo bits and return
    return significandHiBits + loBits;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Nbvm":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Note: other languages provide this as a built in function. This is
 * a naive, but functionally correct implementation. This is used sparingly,
 * when creating a new mapping in a running application.
 *
 * ldexp returns frac  2**exp. With the following special cases:
 *   ldexp(0, exp) = 0
 *   ldexp(Inf, exp) = Inf
 *   ldexp(NaN, exp) = NaN
 * @param frac
 * @param exp
 * @returns {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ldexp", ()=>ldexp);
/**
 * Computes the next power of two that is greater than or equal to v.
 * This implementation more efficient than, but functionally equivalent
 * to Math.pow(2, Math.ceil(Math.log(x)/Math.log(2))).
 * @param v
 * @returns {number}
 */ parcelHelpers.export(exports, "nextGreaterSquare", ()=>nextGreaterSquare);
function ldexp(frac, exp) {
    if (frac === 0 || frac === Number.POSITIVE_INFINITY || frac === Number.NEGATIVE_INFINITY || Number.isNaN(frac)) return frac;
    return frac * Math.pow(2, exp);
}
function nextGreaterSquare(v) {
    // The following expression computes the least power-of-two
    // that is >= v.  There are a number of tricky ways to
    // do this, see https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e2c4b":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MappingError", ()=>MappingError);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var MappingError = /** @class */ function(_super) {
    __extends(MappingError, _super);
    function MappingError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return MappingError;
}(Error);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hjsbS":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LogarithmMapping", ()=>LogarithmMapping);
var _ieee754 = require("./ieee754");
var _util = require("../util");
var _types = require("./types");
/**
 * LogarithmMapping implements exponential mapping functions for scale > 0.
 * For scales <= 0 the exponent mapping should be used.
 */ var LogarithmMapping = /** @class */ function() {
    function LogarithmMapping(scale) {
        this._scale = scale;
        this._scaleFactor = _util.ldexp(Math.LOG2E, scale);
        this._inverseFactor = _util.ldexp(Math.LN2, -scale);
    }
    /**
     * Maps positive floating point values to indexes corresponding to scale
     * @param value
     * @returns {number} index for provided value at the current scale
     */ LogarithmMapping.prototype.mapToIndex = function(value) {
        if (value <= _ieee754.MIN_VALUE) return this._minNormalLowerBoundaryIndex() - 1;
        // exact power of two special case
        if (_ieee754.getSignificand(value) === 0) {
            var exp = _ieee754.getNormalBase2(value);
            return (exp << this._scale) - 1;
        }
        // non-power of two cases. use Math.floor to round the scaled logarithm
        var index = Math.floor(Math.log(value) * this._scaleFactor);
        var maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) return maxIndex;
        return index;
    };
    /**
     * Returns the lower bucket boundary for the given index for scale
     *
     * @param index
     * @returns {number}
     */ LogarithmMapping.prototype.lowerBoundary = function(index) {
        var maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) {
            if (index === maxIndex) return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);
            throw new (0, _types.MappingError)("overflow: " + index + " is > maximum lower boundary: " + maxIndex);
        }
        var minIndex = this._minNormalLowerBoundaryIndex();
        if (index <= minIndex) {
            if (index === minIndex) return _ieee754.MIN_VALUE;
            else if (index === minIndex - 1) return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;
            throw new (0, _types.MappingError)("overflow: " + index + " is < minimum lower boundary: " + minIndex);
        }
        return Math.exp(index * this._inverseFactor);
    };
    Object.defineProperty(LogarithmMapping.prototype, "scale", {
        /**
         * The scale used by this mapping
         * @returns {number}
         */ get: function() {
            return this._scale;
        },
        enumerable: false,
        configurable: true
    });
    LogarithmMapping.prototype._minNormalLowerBoundaryIndex = function() {
        return _ieee754.MIN_NORMAL_EXPONENT << this._scale;
    };
    LogarithmMapping.prototype._maxNormalLowerBoundaryIndex = function() {
        return (_ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;
    };
    return LogarithmMapping;
}();

},{"./ieee754":"jqjCj","../util":"8Nbvm","./types":"e2c4b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eCQSK":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LastValueAccumulation", ()=>LastValueAccumulation);
parcelHelpers.export(exports, "LastValueAggregator", ()=>LastValueAggregator);
var _types = require("./types");
var _core = require("@opentelemetry/core");
var _metricData = require("../export/MetricData");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var LastValueAccumulation = /** @class */ function() {
    function LastValueAccumulation(startTime, _current, sampleTime) {
        if (_current === void 0) _current = 0;
        if (sampleTime === void 0) sampleTime = [
            0,
            0
        ];
        this.startTime = startTime;
        this._current = _current;
        this.sampleTime = sampleTime;
    }
    LastValueAccumulation.prototype.record = function(value) {
        this._current = value;
        this.sampleTime = (0, _core.millisToHrTime)(Date.now());
    };
    LastValueAccumulation.prototype.setStartTime = function(startTime) {
        this.startTime = startTime;
    };
    LastValueAccumulation.prototype.toPointValue = function() {
        return this._current;
    };
    return LastValueAccumulation;
}();
/** Basic aggregator which calculates a LastValue from individual measurements. */ var LastValueAggregator = /** @class */ function() {
    function LastValueAggregator() {
        this.kind = (0, _types.AggregatorKind).LAST_VALUE;
    }
    LastValueAggregator.prototype.createAccumulation = function(startTime) {
        return new LastValueAccumulation(startTime);
    };
    /**
     * Returns the result of the merge of the given accumulations.
     *
     * Return the newly captured (delta) accumulation for LastValueAggregator.
     */ LastValueAggregator.prototype.merge = function(previous, delta) {
        // nanoseconds may lose precisions.
        var latestAccumulation = (0, _core.hrTimeToMicroseconds)(delta.sampleTime) >= (0, _core.hrTimeToMicroseconds)(previous.sampleTime) ? delta : previous;
        return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
    };
    /**
     * Returns a new DELTA aggregation by comparing two cumulative measurements.
     *
     * A delta aggregation is not meaningful to LastValueAggregator, just return
     * the newly captured (delta) accumulation for LastValueAggregator.
     */ LastValueAggregator.prototype.diff = function(previous, current) {
        // nanoseconds may lose precisions.
        var latestAccumulation = (0, _core.hrTimeToMicroseconds)(current.sampleTime) >= (0, _core.hrTimeToMicroseconds)(previous.sampleTime) ? current : previous;
        return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
    };
    LastValueAggregator.prototype.toMetricData = function(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
            descriptor: descriptor,
            aggregationTemporality: aggregationTemporality,
            dataPointType: (0, _metricData.DataPointType).GAUGE,
            dataPoints: accumulationByAttributes.map(function(_a) {
                var _b = __read(_a, 2), attributes = _b[0], accumulation = _b[1];
                return {
                    attributes: attributes,
                    startTime: accumulation.startTime,
                    endTime: endTime,
                    value: accumulation.toPointValue()
                };
            })
        };
    };
    return LastValueAggregator;
}();

},{"./types":"5JQCw","@opentelemetry/core":"5eoQV","../export/MetricData":"buI5y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5eoQV":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "W3CBaggagePropagator", ()=>(0, _w3CbaggagePropagator.W3CBaggagePropagator));
parcelHelpers.export(exports, "AnchoredClock", ()=>(0, _anchoredClock.AnchoredClock));
parcelHelpers.export(exports, "isAttributeKey", ()=>(0, _attributes.isAttributeKey));
parcelHelpers.export(exports, "isAttributeValue", ()=>(0, _attributes.isAttributeValue));
parcelHelpers.export(exports, "sanitizeAttributes", ()=>(0, _attributes.sanitizeAttributes));
parcelHelpers.export(exports, "globalErrorHandler", ()=>(0, _globalErrorHandler.globalErrorHandler));
parcelHelpers.export(exports, "setGlobalErrorHandler", ()=>(0, _globalErrorHandler.setGlobalErrorHandler));
parcelHelpers.export(exports, "loggingErrorHandler", ()=>(0, _loggingErrorHandler.loggingErrorHandler));
parcelHelpers.export(exports, "addHrTimes", ()=>(0, _time.addHrTimes));
parcelHelpers.export(exports, "getTimeOrigin", ()=>(0, _time.getTimeOrigin));
parcelHelpers.export(exports, "hrTime", ()=>(0, _time.hrTime));
parcelHelpers.export(exports, "hrTimeDuration", ()=>(0, _time.hrTimeDuration));
parcelHelpers.export(exports, "hrTimeToMicroseconds", ()=>(0, _time.hrTimeToMicroseconds));
parcelHelpers.export(exports, "hrTimeToMilliseconds", ()=>(0, _time.hrTimeToMilliseconds));
parcelHelpers.export(exports, "hrTimeToNanoseconds", ()=>(0, _time.hrTimeToNanoseconds));
parcelHelpers.export(exports, "hrTimeToTimeStamp", ()=>(0, _time.hrTimeToTimeStamp));
parcelHelpers.export(exports, "isTimeInput", ()=>(0, _time.isTimeInput));
parcelHelpers.export(exports, "isTimeInputHrTime", ()=>(0, _time.isTimeInputHrTime));
parcelHelpers.export(exports, "millisToHrTime", ()=>(0, _time.millisToHrTime));
parcelHelpers.export(exports, "timeInputToHrTime", ()=>(0, _time.timeInputToHrTime));
parcelHelpers.export(exports, "hexToBinary", ()=>(0, _hexToBinary.hexToBinary));
parcelHelpers.export(exports, "ExportResultCode", ()=>(0, _exportResult.ExportResultCode));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _platform.RandomIdGenerator));
parcelHelpers.export(exports, "SDK_INFO", ()=>(0, _platform.SDK_INFO));
parcelHelpers.export(exports, "_globalThis", ()=>(0, _platform._globalThis));
parcelHelpers.export(exports, "getEnv", ()=>(0, _platform.getEnv));
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>(0, _platform.getEnvWithoutDefaults));
parcelHelpers.export(exports, "hexToBase64", ()=>(0, _platform.hexToBase64));
parcelHelpers.export(exports, "otperformance", ()=>(0, _platform.otperformance));
parcelHelpers.export(exports, "unrefTimer", ()=>(0, _platform.unrefTimer));
parcelHelpers.export(exports, "CompositePropagator", ()=>(0, _composite.CompositePropagator));
parcelHelpers.export(exports, "TRACE_PARENT_HEADER", ()=>(0, _w3CtraceContextPropagator.TRACE_PARENT_HEADER));
parcelHelpers.export(exports, "TRACE_STATE_HEADER", ()=>(0, _w3CtraceContextPropagator.TRACE_STATE_HEADER));
parcelHelpers.export(exports, "W3CTraceContextPropagator", ()=>(0, _w3CtraceContextPropagator.W3CTraceContextPropagator));
parcelHelpers.export(exports, "parseTraceParent", ()=>(0, _w3CtraceContextPropagator.parseTraceParent));
parcelHelpers.export(exports, "RPCType", ()=>(0, _rpcMetadata.RPCType));
parcelHelpers.export(exports, "deleteRPCMetadata", ()=>(0, _rpcMetadata.deleteRPCMetadata));
parcelHelpers.export(exports, "getRPCMetadata", ()=>(0, _rpcMetadata.getRPCMetadata));
parcelHelpers.export(exports, "setRPCMetadata", ()=>(0, _rpcMetadata.setRPCMetadata));
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>(0, _alwaysOffSampler.AlwaysOffSampler));
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>(0, _alwaysOnSampler.AlwaysOnSampler));
parcelHelpers.export(exports, "ParentBasedSampler", ()=>(0, _parentBasedSampler.ParentBasedSampler));
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>(0, _traceIdRatioBasedSampler.TraceIdRatioBasedSampler));
parcelHelpers.export(exports, "isTracingSuppressed", ()=>(0, _suppressTracing.isTracingSuppressed));
parcelHelpers.export(exports, "suppressTracing", ()=>(0, _suppressTracing.suppressTracing));
parcelHelpers.export(exports, "unsuppressTracing", ()=>(0, _suppressTracing.unsuppressTracing));
parcelHelpers.export(exports, "TraceState", ()=>(0, _traceState.TraceState));
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_ATTRIBUTE_COUNT_LIMIT));
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", ()=>(0, _environment.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT));
parcelHelpers.export(exports, "DEFAULT_ENVIRONMENT", ()=>(0, _environment.DEFAULT_ENVIRONMENT));
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT));
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT));
parcelHelpers.export(exports, "parseEnvironment", ()=>(0, _environment.parseEnvironment));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "TracesSamplerValues", ()=>(0, _sampling.TracesSamplerValues));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _timeout.TimeoutError));
parcelHelpers.export(exports, "callWithTimeout", ()=>(0, _timeout.callWithTimeout));
parcelHelpers.export(exports, "isUrlIgnored", ()=>(0, _url.isUrlIgnored));
parcelHelpers.export(exports, "urlMatches", ()=>(0, _url.urlMatches));
parcelHelpers.export(exports, "isWrapped", ()=>(0, _wrap.isWrapped));
parcelHelpers.export(exports, "BindOnceFuture", ()=>(0, _callback.BindOnceFuture));
parcelHelpers.export(exports, "VERSION", ()=>(0, _version.VERSION));
parcelHelpers.export(exports, "baggageUtils", ()=>baggageUtils);
parcelHelpers.export(exports, "internal", ()=>internal);
var _w3CbaggagePropagator = require("./baggage/propagation/W3CBaggagePropagator");
var _anchoredClock = require("./common/anchored-clock");
var _attributes = require("./common/attributes");
var _globalErrorHandler = require("./common/global-error-handler");
var _loggingErrorHandler = require("./common/logging-error-handler");
var _time = require("./common/time");
var _hexToBinary = require("./common/hex-to-binary");
var _exportResult = require("./ExportResult");
var _utils = require("./baggage/utils");
var _platform = require("./platform");
var _composite = require("./propagation/composite");
var _w3CtraceContextPropagator = require("./trace/W3CTraceContextPropagator");
var _rpcMetadata = require("./trace/rpc-metadata");
var _alwaysOffSampler = require("./trace/sampler/AlwaysOffSampler");
var _alwaysOnSampler = require("./trace/sampler/AlwaysOnSampler");
var _parentBasedSampler = require("./trace/sampler/ParentBasedSampler");
var _traceIdRatioBasedSampler = require("./trace/sampler/TraceIdRatioBasedSampler");
var _suppressTracing = require("./trace/suppress-tracing");
var _traceState = require("./trace/TraceState");
var _environment = require("./utils/environment");
var _merge = require("./utils/merge");
var _sampling = require("./utils/sampling");
var _timeout = require("./utils/timeout");
var _url = require("./utils/url");
var _wrap = require("./utils/wrap");
var _callback = require("./utils/callback");
var _version = require("./version");
var _exporter = require("./internal/exporter");
var baggageUtils = {
    getKeyPairs: (0, _utils.getKeyPairs),
    serializeKeyPairs: (0, _utils.serializeKeyPairs),
    parseKeyPairsIntoRecord: (0, _utils.parseKeyPairsIntoRecord),
    parsePairKeyValue: (0, _utils.parsePairKeyValue)
};
var internal = {
    _export: (0, _exporter._export)
};

},{"./baggage/propagation/W3CBaggagePropagator":"jATN1","./common/anchored-clock":"8muQg","./common/attributes":"8apqq","./common/global-error-handler":"4sysR","./common/logging-error-handler":"6MsS5","./common/time":"axrJ0","./common/hex-to-binary":"fwPl9","./ExportResult":"iPUeB","./baggage/utils":"1eeGr","./platform":"e5QQh","./propagation/composite":"3FRgl","./trace/W3CTraceContextPropagator":"bnCFv","./trace/rpc-metadata":"dejh8","./trace/sampler/AlwaysOffSampler":"fxkhU","./trace/sampler/AlwaysOnSampler":"4RsPK","./trace/sampler/ParentBasedSampler":"1ebXi","./trace/sampler/TraceIdRatioBasedSampler":"baCVl","./trace/suppress-tracing":"6isaL","./trace/TraceState":"lxki1","./utils/environment":"ji5xt","./utils/merge":"1sRRq","./utils/sampling":"2moDe","./utils/timeout":"bvHNU","./utils/url":"jTVuX","./utils/wrap":"5Hk1G","./utils/callback":"3StTD","./version":"8WEeU","./internal/exporter":"jvx6I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jATN1":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "W3CBaggagePropagator", ()=>W3CBaggagePropagator);
var _api = require("@opentelemetry/api");
var _suppressTracing = require("../../trace/suppress-tracing");
var _constants = require("../constants");
var _utils = require("../utils");
/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */ var W3CBaggagePropagator = /** @class */ function() {
    function W3CBaggagePropagator() {}
    W3CBaggagePropagator.prototype.inject = function(context, carrier, setter) {
        var baggage = (0, _api.propagation).getBaggage(context);
        if (!baggage || (0, _suppressTracing.isTracingSuppressed)(context)) return;
        var keyPairs = (0, _utils.getKeyPairs)(baggage).filter(function(pair) {
            return pair.length <= (0, _constants.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS);
        }).slice(0, (0, _constants.BAGGAGE_MAX_NAME_VALUE_PAIRS));
        var headerValue = (0, _utils.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) setter.set(carrier, (0, _constants.BAGGAGE_HEADER), headerValue);
    };
    W3CBaggagePropagator.prototype.extract = function(context, carrier, getter) {
        var headerValue = getter.get(carrier, (0, _constants.BAGGAGE_HEADER));
        var baggageString = Array.isArray(headerValue) ? headerValue.join((0, _constants.BAGGAGE_ITEMS_SEPARATOR)) : headerValue;
        if (!baggageString) return context;
        var baggage = {};
        if (baggageString.length === 0) return context;
        var pairs = baggageString.split((0, _constants.BAGGAGE_ITEMS_SEPARATOR));
        pairs.forEach(function(entry) {
            var keyPair = (0, _utils.parsePairKeyValue)(entry);
            if (keyPair) {
                var baggageEntry = {
                    value: keyPair.value
                };
                if (keyPair.metadata) baggageEntry.metadata = keyPair.metadata;
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) return context;
        return (0, _api.propagation).setBaggage(context, (0, _api.propagation).createBaggage(baggage));
    };
    W3CBaggagePropagator.prototype.fields = function() {
        return [
            (0, _constants.BAGGAGE_HEADER)
        ];
    };
    return W3CBaggagePropagator;
}();

},{"@opentelemetry/api":"6AC4z","../../trace/suppress-tracing":"6isaL","../constants":"69LTR","../utils":"1eeGr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6isaL":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "suppressTracing", ()=>suppressTracing);
parcelHelpers.export(exports, "unsuppressTracing", ()=>unsuppressTracing);
parcelHelpers.export(exports, "isTracingSuppressed", ()=>isTracingSuppressed);
var _api = require("@opentelemetry/api");
var SUPPRESS_TRACING_KEY = (0, _api.createContextKey)('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
}
function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
}
function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"69LTR":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BAGGAGE_KEY_PAIR_SEPARATOR", ()=>BAGGAGE_KEY_PAIR_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_PROPERTIES_SEPARATOR", ()=>BAGGAGE_PROPERTIES_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_ITEMS_SEPARATOR", ()=>BAGGAGE_ITEMS_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_HEADER", ()=>BAGGAGE_HEADER);
parcelHelpers.export(exports, "BAGGAGE_MAX_NAME_VALUE_PAIRS", ()=>BAGGAGE_MAX_NAME_VALUE_PAIRS);
parcelHelpers.export(exports, "BAGGAGE_MAX_PER_NAME_VALUE_PAIRS", ()=>BAGGAGE_MAX_PER_NAME_VALUE_PAIRS);
parcelHelpers.export(exports, "BAGGAGE_MAX_TOTAL_LENGTH", ()=>BAGGAGE_MAX_TOTAL_LENGTH);
var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var BAGGAGE_PROPERTIES_SEPARATOR = ';';
var BAGGAGE_ITEMS_SEPARATOR = ',';
var BAGGAGE_HEADER = 'baggage';
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1eeGr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeKeyPairs", ()=>serializeKeyPairs);
parcelHelpers.export(exports, "getKeyPairs", ()=>getKeyPairs);
parcelHelpers.export(exports, "parsePairKeyValue", ()=>parsePairKeyValue);
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */ parcelHelpers.export(exports, "parseKeyPairsIntoRecord", ()=>parseKeyPairsIntoRecord);
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var _api = require("@opentelemetry/api");
var _constants = require("./constants");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function(hValue, current) {
        var value = "" + hValue + (hValue !== '' ? (0, _constants.BAGGAGE_ITEMS_SEPARATOR) : '') + current;
        return value.length > (0, _constants.BAGGAGE_MAX_TOTAL_LENGTH) ? hValue : value;
    }, '');
}
function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) entry += (0, _constants.BAGGAGE_PROPERTIES_SEPARATOR) + value.metadata.toString();
        return entry;
    });
}
function parsePairKeyValue(entry) {
    var valueProps = entry.split((0, _constants.BAGGAGE_PROPERTIES_SEPARATOR));
    if (valueProps.length <= 0) return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart) return;
    var separatorIndex = keyPairPart.indexOf((0, _constants.BAGGAGE_KEY_PAIR_SEPARATOR));
    if (separatorIndex <= 0) return;
    var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    var metadata;
    if (valueProps.length > 0) metadata = (0, _api.baggageEntryMetadataFromString)(valueProps.join((0, _constants.BAGGAGE_PROPERTIES_SEPARATOR)));
    return {
        key: key,
        value: value,
        metadata: metadata
    };
}
function parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0) return {};
    return value.split((0, _constants.BAGGAGE_ITEMS_SEPARATOR)).map(function(entry) {
        return parsePairKeyValue(entry);
    }).filter(function(keyPair) {
        return keyPair !== undefined && keyPair.value.length > 0;
    }).reduce(function(headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}

},{"@opentelemetry/api":"6AC4z","./constants":"69LTR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8muQg":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A utility for returning wall times anchored to a given point in time. Wall time measurements will
 * not be taken from the system, but instead are computed by adding a monotonic clock time
 * to the anchor point.
 *
 * This is needed because the system time can change and result in unexpected situations like
 * spans ending before they are started. Creating an anchored clock for each local root span
 * ensures that span timings and durations are accurate while preventing span times from drifting
 * too far from the system clock.
 *
 * Only creating an anchored clock once per local trace ensures span times are correct relative
 * to each other. For example, a child span will never have a start time before its parent even
 * if the system clock is corrected during the local trace.
 *
 * Heavily inspired by the OTel Java anchored clock
 * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/AnchoredClock.java
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnchoredClock", ()=>AnchoredClock);
var AnchoredClock = /** @class */ function() {
    /**
     * Create a new AnchoredClock anchored to the current time returned by systemClock.
     *
     * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
     * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
     */ function AnchoredClock(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
    }
    /**
     * Returns the current time by adding the number of milliseconds since the
     * AnchoredClock was created to the creation epoch time
     */ AnchoredClock.prototype.now = function() {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
    };
    return AnchoredClock;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8apqq":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sanitizeAttributes", ()=>sanitizeAttributes);
parcelHelpers.export(exports, "isAttributeKey", ()=>isAttributeKey);
parcelHelpers.export(exports, "isAttributeValue", ()=>isAttributeValue);
var _api = require("@opentelemetry/api");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
function sanitizeAttributes(attributes) {
    var e_1, _a;
    var out = {};
    if (typeof attributes !== 'object' || attributes == null) return out;
    try {
        for(var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()){
            var _d = __read(_c.value, 2), key = _d[0], val = _d[1];
            if (!isAttributeKey(key)) {
                (0, _api.diag).warn("Invalid attribute key: " + key);
                continue;
            }
            if (!isAttributeValue(val)) {
                (0, _api.diag).warn("Invalid attribute value set for key: " + key);
                continue;
            }
            if (Array.isArray(val)) out[key] = val.slice();
            else out[key] = val;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return out;
}
function isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function isAttributeValue(val) {
    if (val == null) return true;
    if (Array.isArray(val)) return isHomogeneousAttributeValueArray(val);
    return isValidPrimitiveAttributeValue(val);
}
function isHomogeneousAttributeValueArray(arr) {
    var e_2, _a;
    var type;
    try {
        for(var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()){
            var element = arr_1_1.value;
            // null/undefined elements are allowed
            if (element == null) continue;
            if (!type) {
                if (isValidPrimitiveAttributeValue(element)) {
                    type = typeof element;
                    continue;
                }
                // encountered an invalid primitive
                return false;
            }
            if (typeof element === type) continue;
            return false;
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return true;
}
function isValidPrimitiveAttributeValue(val) {
    switch(typeof val){
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4sysR":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */ parcelHelpers.export(exports, "setGlobalErrorHandler", ()=>setGlobalErrorHandler);
/**
 * Return the global error handler
 * @param {Exception} ex
 */ parcelHelpers.export(exports, "globalErrorHandler", ()=>globalErrorHandler);
var _loggingErrorHandler = require("./logging-error-handler");
/** The global error handler delegate */ var delegateHandler = (0, _loggingErrorHandler.loggingErrorHandler)();
function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
}
function globalErrorHandler(ex) {
    try {
        delegateHandler(ex);
    } catch (_a) {} // eslint-disable-line no-empty
}

},{"./logging-error-handler":"6MsS5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6MsS5":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */ parcelHelpers.export(exports, "loggingErrorHandler", ()=>loggingErrorHandler);
var _api = require("@opentelemetry/api");
function loggingErrorHandler() {
    return function(ex) {
        (0, _api.diag).error(stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */ function stringifyException(ex) {
    if (typeof ex === 'string') return ex;
    else return JSON.stringify(flattenException(ex));
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */ function flattenException(ex) {
    var result = {};
    var current = ex;
    while(current !== null){
        Object.getOwnPropertyNames(current).forEach(function(propertyName) {
            if (result[propertyName]) return;
            var value = current[propertyName];
            if (value) result[propertyName] = String(value);
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"axrJ0":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */ parcelHelpers.export(exports, "millisToHrTime", ()=>millisToHrTime);
parcelHelpers.export(exports, "getTimeOrigin", ()=>getTimeOrigin);
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */ parcelHelpers.export(exports, "hrTime", ()=>hrTime);
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */ parcelHelpers.export(exports, "timeInputToHrTime", ()=>timeInputToHrTime);
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */ parcelHelpers.export(exports, "hrTimeDuration", ()=>hrTimeDuration);
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToTimeStamp", ()=>hrTimeToTimeStamp);
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToNanoseconds", ()=>hrTimeToNanoseconds);
/**
 * Convert hrTime to milliseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToMilliseconds", ()=>hrTimeToMilliseconds);
/**
 * Convert hrTime to microseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToMicroseconds", ()=>hrTimeToMicroseconds);
/**
 * check if time is HrTime
 * @param value
 */ parcelHelpers.export(exports, "isTimeInputHrTime", ()=>isTimeInputHrTime);
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */ parcelHelpers.export(exports, "isTimeInput", ()=>isTimeInput);
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */ parcelHelpers.export(exports, "addHrTimes", ()=>addHrTimes);
var _platform = require("../platform");
var NANOSECOND_DIGITS = 9;
var NANOSECOND_DIGITS_IN_MILLIS = 6;
var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
function millisToHrTime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
    return [
        seconds,
        nanos
    ];
}
function getTimeOrigin() {
    var timeOrigin = (0, _platform.otperformance).timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = (0, _platform.otperformance);
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
function hrTime(performanceNow) {
    var timeOrigin = millisToHrTime(getTimeOrigin());
    var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : (0, _platform.otperformance).now());
    return addHrTimes(timeOrigin, now);
}
function timeInputToHrTime(time) {
    // process.hrtime
    if (isTimeInputHrTime(time)) return time;
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < getTimeOrigin()) return hrTime(time);
        else // epoch milliseconds or performance.timeOrigin
        return millisToHrTime(time);
    } else if (time instanceof Date) return millisToHrTime(time.getTime());
    else throw TypeError('Invalid input type');
}
function hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS;
    }
    return [
        seconds,
        nanos
    ];
}
function hrTimeToTimeStamp(time) {
    var precision = NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substring(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
function hrTimeToMilliseconds(time) {
    return time[0] * 1e3 + time[1] / 1e6;
}
function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1e3;
}
function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
}
function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;
}
function addHrTimes(time1, time2) {
    var out = [
        time1[0] + time2[0],
        time1[1] + time2[1]
    ];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
    }
    return out;
}

},{"../platform":"e5QQh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5QQh":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>(0, _environment.getEnvWithoutDefaults));
parcelHelpers.export(exports, "getEnv", ()=>(0, _environment.getEnv));
parcelHelpers.export(exports, "_globalThis", ()=>(0, _globalThis._globalThis));
parcelHelpers.export(exports, "hexToBase64", ()=>(0, _hexToBase64.hexToBase64));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _randomIdGenerator.RandomIdGenerator));
parcelHelpers.export(exports, "otperformance", ()=>(0, _performance.otperformance));
parcelHelpers.export(exports, "SDK_INFO", ()=>(0, _sdkInfo.SDK_INFO));
parcelHelpers.export(exports, "unrefTimer", ()=>(0, _timerUtil.unrefTimer));
var _environment = require("./environment");
var _globalThis = require("./globalThis");
var _hexToBase64 = require("./hex-to-base64");
var _randomIdGenerator = require("./RandomIdGenerator");
var _performance = require("./performance");
var _sdkInfo = require("./sdk-info");
var _timerUtil = require("./timer-util");

},{"./environment":"6UkLf","./globalThis":"habkf","./hex-to-base64":"4SWie","./RandomIdGenerator":"27zGa","./performance":"jEqgB","./sdk-info":"4kHWS","./timer-util":"etlVJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6UkLf":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the environment variables
 */ parcelHelpers.export(exports, "getEnv", ()=>getEnv);
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>getEnvWithoutDefaults);
var _environment = require("../../utils/environment");
var _globalThis = require("./globalThis");
function getEnv() {
    var globalEnv = (0, _environment.parseEnvironment)((0, _globalThis._globalThis));
    return Object.assign({}, (0, _environment.DEFAULT_ENVIRONMENT), globalEnv);
}
function getEnvWithoutDefaults() {
    return (0, _environment.parseEnvironment)((0, _globalThis._globalThis));
}

},{"../../utils/environment":"ji5xt","./globalThis":"habkf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ji5xt":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", ()=>DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT);
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", ()=>DEFAULT_ATTRIBUTE_COUNT_LIMIT);
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", ()=>DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT);
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", ()=>DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT);
parcelHelpers.export(exports, "DEFAULT_ENVIRONMENT", ()=>DEFAULT_ENVIRONMENT);
/**
 * Parses environment values
 * @param values
 */ parcelHelpers.export(exports, "parseEnvironment", ()=>parseEnvironment);
var _api = require("@opentelemetry/api");
var _sampling = require("./sampling");
var DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */ var ENVIRONMENT_BOOLEAN_KEYS = [
    'OTEL_SDK_DISABLED'
];
function isEnvVarABoolean(key) {
    return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_NUMBERS_KEYS = [
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_BLRP_EXPORT_TIMEOUT',
    'OTEL_BLRP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BLRP_MAX_QUEUE_SIZE',
    'OTEL_BLRP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT'
];
function isEnvVarANumber(key) {
    return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_LISTS_KEYS = [
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
    'OTEL_SEMCONV_STABILITY_OPT_IN'
];
function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
var DEFAULT_ENVIRONMENT = {
    OTEL_SDK_DISABLED: false,
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_BLRP_EXPORT_TIMEOUT: 30000,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: (0, _api.DiagLogLevel).INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: [
        'tracecontext',
        'baggage'
    ],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    OTEL_TRACES_EXPORTER: '',
    OTEL_TRACES_SAMPLER: (0, _sampling.TracesSamplerValues).ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_LOGS_EXPORTER: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative',
    OTEL_SEMCONV_STABILITY_OPT_IN: []
};
/**
 * @param key
 * @param environment
 * @param values
 */ function parseBoolean(key, environment, values) {
    if (typeof values[key] === 'undefined') return;
    var value = String(values[key]);
    // support case-insensitive "true"
    environment[key] = value.toLowerCase() === 'true';
}
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */ function parseNumber(name, environment, values, min, max) {
    if (min === void 0) min = -Infinity;
    if (max === void 0) max = Infinity;
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) environment[name] = min;
            else if (value > max) environment[name] = max;
            else environment[name] = value;
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */ function parseStringList(name, output, input, separator) {
    if (separator === void 0) separator = DEFAULT_LIST_SEPARATOR;
    var givenValue = input[name];
    if (typeof givenValue === 'string') output[name] = givenValue.split(separator).map(function(v) {
        return v.trim();
    });
}
// The support string -> DiagLogLevel mappings
var logLevelMap = {
    ALL: (0, _api.DiagLogLevel).ALL,
    VERBOSE: (0, _api.DiagLogLevel).VERBOSE,
    DEBUG: (0, _api.DiagLogLevel).DEBUG,
    INFO: (0, _api.DiagLogLevel).INFO,
    WARN: (0, _api.DiagLogLevel).WARN,
    ERROR: (0, _api.DiagLogLevel).ERROR,
    NONE: (0, _api.DiagLogLevel).NONE
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */ function setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) environment[key] = theLevel;
    }
}
function parseEnvironment(values) {
    var environment = {};
    for(var env in DEFAULT_ENVIRONMENT){
        var key = env;
        switch(key){
            case 'OTEL_LOG_LEVEL':
                setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (isEnvVarABoolean(key)) parseBoolean(key, environment, values);
                else if (isEnvVarANumber(key)) parseNumber(key, environment, values);
                else if (isEnvVarAList(key)) parseStringList(key, environment, values);
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) environment[key] = String(value);
                }
        }
    }
    return environment;
}

},{"@opentelemetry/api":"6AC4z","./sampling":"2moDe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2moDe":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TracesSamplerValues", ()=>TracesSamplerValues);
var TracesSamplerValues;
(function(TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues || (TracesSamplerValues = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"habkf":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Updates to this file should also be replicated to @opentelemetry/api too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */ /** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>_globalThis);
var global = arguments[3];
var _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4SWie":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hexToBase64", ()=>hexToBase64);
var _hexToBinary = require("../../common/hex-to-binary");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
function hexToBase64(hexStr) {
    return btoa(String.fromCharCode.apply(String, __spreadArray([], __read((0, _hexToBinary.hexToBinary)(hexStr)), false)));
}

},{"../../common/hex-to-binary":"fwPl9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fwPl9":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hexToBinary", ()=>hexToBinary);
function intValue(charCode) {
    // 0-9
    if (charCode >= 48 && charCode <= 57) return charCode - 48;
    // a-f
    if (charCode >= 97 && charCode <= 102) return charCode - 87;
    // A-F
    return charCode - 55;
}
function hexToBinary(hexStr) {
    var buf = new Uint8Array(hexStr.length / 2);
    var offset = 0;
    for(var i = 0; i < hexStr.length; i += 2){
        var hi = intValue(hexStr.charCodeAt(i));
        var lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = hi << 4 | lo;
    }
    return buf;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"27zGa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RandomIdGenerator", ()=>RandomIdGenerator);
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 */ var RandomIdGenerator = /** @class */ function() {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */ this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */ this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}();
var SHARED_CHAR_CODES_ARRAY = Array(32);
function getIdGenerator(bytes) {
    return function generateId() {
        for(var i = 0; i < bytes * 2; i++){
            SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (SHARED_CHAR_CODES_ARRAY[i] >= 58) SHARED_CHAR_CODES_ARRAY[i] += 39;
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jEqgB":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "otperformance", ()=>otperformance);
var otperformance = performance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kHWS":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SDK_INFO", ()=>SDK_INFO);
var _version = require("../../version");
var _semanticConventions = require("@opentelemetry/semantic-conventions");
var _a;
var SDK_INFO = (_a = {}, _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_NAME] = 'opentelemetry', _a[0, _semanticConventions.SEMRESATTRS_PROCESS_RUNTIME_NAME] = 'browser', _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = (0, _semanticConventions.TELEMETRYSDKLANGUAGEVALUES_WEBJS), _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_VERSION] = (0, _version.VERSION), _a);

},{"../../version":"8WEeU","@opentelemetry/semantic-conventions":"lCgfj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8WEeU":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // this is autogenerated file, see scripts/version-update.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
var VERSION = '1.29.0';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"etlVJ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unrefTimer", ()=>unrefTimer);
function unrefTimer(_timer) {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iPUeB":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExportResultCode", ()=>ExportResultCode);
var ExportResultCode;
(function(ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3FRgl":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CompositePropagator", ()=>CompositePropagator);
var _api = require("@opentelemetry/api");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/** Combines multiple propagators into a single propagator. */ var CompositePropagator = /** @class */ function() {
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */ function CompositePropagator(config) {
        if (config === void 0) config = {};
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators// older propagators may not have fields function, null check to be sure
        .map(function(p) {
            return typeof p.fields === 'function' ? p.fields() : [];
        }).reduce(function(x, y) {
            return x.concat(y);
        }, [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */ CompositePropagator.prototype.inject = function(context, carrier, setter) {
        var e_1, _a;
        try {
            for(var _b = __values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()){
                var propagator = _c.value;
                try {
                    propagator.inject(context, carrier, setter);
                } catch (err) {
                    (0, _api.diag).warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
                }
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    };
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */ CompositePropagator.prototype.extract = function(context, carrier, getter) {
        return this._propagators.reduce(function(ctx, propagator) {
            try {
                return propagator.extract(ctx, carrier, getter);
            } catch (err) {
                (0, _api.diag).warn("Failed to extract with " + propagator.constructor.name + ". Err: " + err.message);
            }
            return ctx;
        }, context);
    };
    CompositePropagator.prototype.fields = function() {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    };
    return CompositePropagator;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bnCFv":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TRACE_PARENT_HEADER", ()=>TRACE_PARENT_HEADER);
parcelHelpers.export(exports, "TRACE_STATE_HEADER", ()=>TRACE_STATE_HEADER);
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */ parcelHelpers.export(exports, "parseTraceParent", ()=>parseTraceParent);
parcelHelpers.export(exports, "W3CTraceContextPropagator", ()=>W3CTraceContextPropagator);
var _api = require("@opentelemetry/api");
var _suppressTracing = require("./suppress-tracing");
var _traceState = require("./TraceState");
var TRACE_PARENT_HEADER = 'traceparent';
var TRACE_STATE_HEADER = 'tracestate';
var VERSION = '00';
var VERSION_PART = '(?!ff)[\\da-f]{2}';
var TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var FLAGS_PART = '[\\da-f]{2}';
var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
function parseTraceParent(traceParent) {
    var match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match) return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5]) return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */ var W3CTraceContextPropagator = /** @class */ function() {
    function W3CTraceContextPropagator() {}
    W3CTraceContextPropagator.prototype.inject = function(context, carrier, setter) {
        var spanContext = (0, _api.trace).getSpanContext(context);
        if (!spanContext || (0, _suppressTracing.isTracingSuppressed)(context) || !(0, _api.isSpanContextValid)(spanContext)) return;
        var traceParent = VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || (0, _api.TraceFlags).NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
    };
    W3CTraceContextPropagator.prototype.extract = function(context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader) return context;
        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== 'string') return context;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext) return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(',') : traceStateHeader;
            spanContext.traceState = new (0, _traceState.TraceState)(typeof state === 'string' ? state : undefined);
        }
        return (0, _api.trace).setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function() {
        return [
            TRACE_PARENT_HEADER,
            TRACE_STATE_HEADER
        ];
    };
    return W3CTraceContextPropagator;
}();

},{"@opentelemetry/api":"6AC4z","./suppress-tracing":"6isaL","./TraceState":"lxki1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lxki1":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceState", ()=>TraceState);
var _validators = require("../internal/validators");
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ',';
var LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */ var TraceState = /** @class */ function() {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState) this._parse(rawTraceState);
    }
    TraceState.prototype.set = function(key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) traceState._internalState.delete(key);
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function(key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
        .reduce(function(agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if ((0, _validators.validateKey)(key) && (0, _validators.validateValue)(value)) agg.set(key, value);
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain
        .slice(0, MAX_TRACE_STATE_ITEMS));
    };
    TraceState.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function() {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}();

},{"../internal/validators":"jqyLP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jqyLP":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */ parcelHelpers.export(exports, "validateKey", ()=>validateKey);
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */ parcelHelpers.export(exports, "validateValue", ()=>validateValue);
var VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dejh8":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RPCType", ()=>RPCType);
parcelHelpers.export(exports, "setRPCMetadata", ()=>setRPCMetadata);
parcelHelpers.export(exports, "deleteRPCMetadata", ()=>deleteRPCMetadata);
parcelHelpers.export(exports, "getRPCMetadata", ()=>getRPCMetadata);
var _api = require("@opentelemetry/api");
var RPC_METADATA_KEY = (0, _api.createContextKey)('OpenTelemetry SDK Context Key RPC_METADATA');
var RPCType;
(function(RPCType) {
    RPCType["HTTP"] = "http";
})(RPCType || (RPCType = {}));
function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
}
function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
}
function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fxkhU":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>AlwaysOffSampler);
var _api = require("@opentelemetry/api");
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples no traces.
 */ var AlwaysOffSampler = /** @class */ function() {
    function AlwaysOffSampler() {}
    AlwaysOffSampler.prototype.shouldSample = function() {
        return {
            decision: (0, _api.SamplingDecision).NOT_RECORD
        };
    };
    AlwaysOffSampler.prototype.toString = function() {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4RsPK":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>AlwaysOnSampler);
var _api = require("@opentelemetry/api");
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples all traces.
 */ var AlwaysOnSampler = /** @class */ function() {
    function AlwaysOnSampler() {}
    AlwaysOnSampler.prototype.shouldSample = function() {
        return {
            decision: (0, _api.SamplingDecision).RECORD_AND_SAMPLED
        };
    };
    AlwaysOnSampler.prototype.toString = function() {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ebXi":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ParentBasedSampler", ()=>ParentBasedSampler);
var _api = require("@opentelemetry/api");
var _globalErrorHandler = require("../../common/global-error-handler");
var _alwaysOffSampler = require("./AlwaysOffSampler");
var _alwaysOnSampler = require("./AlwaysOnSampler");
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */ var ParentBasedSampler = /** @class */ function() {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            (0, _globalErrorHandler.globalErrorHandler)(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new (0, _alwaysOnSampler.AlwaysOnSampler)();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new (0, _alwaysOnSampler.AlwaysOnSampler)();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new (0, _alwaysOffSampler.AlwaysOffSampler)();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new (0, _alwaysOnSampler.AlwaysOnSampler)();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new (0, _alwaysOffSampler.AlwaysOffSampler)();
    }
    ParentBasedSampler.prototype.shouldSample = function(context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = (0, _api.trace).getSpanContext(context);
        if (!parentContext || !(0, _api.isSpanContextValid)(parentContext)) return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & (0, _api.TraceFlags).SAMPLED) return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & (0, _api.TraceFlags).SAMPLED) return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function() {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}();

},{"@opentelemetry/api":"6AC4z","../../common/global-error-handler":"4sysR","./AlwaysOffSampler":"fxkhU","./AlwaysOnSampler":"4RsPK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baCVl":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>TraceIdRatioBasedSampler);
var _api = require("@opentelemetry/api");
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples a given fraction of traces based of trace id deterministically.
 */ var TraceIdRatioBasedSampler = /** @class */ function() {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) _ratio = 0;
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function(context, traceId) {
        return {
            decision: (0, _api.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? (0, _api.SamplingDecision).RECORD_AND_SAMPLED : (0, _api.SamplingDecision).NOT_RECORD
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function() {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function(ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio)) return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function(traceId) {
        var accumulation = 0;
        for(var i = 0; i < traceId.length / 8; i++){
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}();

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1sRRq":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* eslint-disable @typescript-eslint/no-explicit-any */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */ parcelHelpers.export(exports, "merge", ()=>merge);
var _lodashMerge = require("./lodash.merge");
var MAX_LEVEL = 20;
function merge() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var result = args.shift();
    var objects = new WeakMap();
    while(args.length > 0)result = mergeTwoObjects(result, args.shift(), 0, objects);
    return result;
}
function takeValue(value) {
    if (isArray(value)) return value.slice();
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */ function mergeTwoObjects(one, two, level, objects) {
    if (level === void 0) level = 0;
    var result;
    if (level > MAX_LEVEL) return undefined;
    level++;
    if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) result = takeValue(two);
    else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) for(var i = 0, j = two.length; i < j; i++)result.push(takeValue(two[i]));
        else if (isObject(two)) {
            var keys = Object.keys(two);
            for(var i = 0, j = keys.length; i < j; i++){
                var key = keys[i];
                result[key] = takeValue(two[key]);
            }
        }
    } else if (isObject(one)) {
        if (isObject(two)) {
            if (!shouldMerge(one, two)) return two;
            result = Object.assign({}, one);
            var keys = Object.keys(two);
            for(var i = 0, j = keys.length; i < j; i++){
                var key = keys[i];
                var twoValue = two[key];
                if (isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') delete result[key];
                    else // result[key] = takeValue(twoValue);
                    result[key] = twoValue;
                } else {
                    var obj1 = result[key];
                    var obj2 = twoValue;
                    if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) delete result[key];
                    else {
                        if (isObject(obj1) && isObject(obj2)) {
                            var arr1 = objects.get(obj1) || [];
                            var arr2 = objects.get(obj2) || [];
                            arr1.push({
                                obj: one,
                                key: key
                            });
                            arr2.push({
                                obj: two,
                                key: key
                            });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        } else result = two;
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */ function wasObjectReferenced(obj, key, objects) {
    var arr = objects.get(obj[key]) || [];
    for(var i = 0, j = arr.length; i < j; i++){
        var info = arr[i];
        if (info.key === key && info.obj === obj) return true;
    }
    return false;
}
function isArray(value) {
    return Array.isArray(value);
}
function isFunction(value) {
    return typeof value === 'function';
}
function isObject(value) {
    return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === 'object';
}
function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value instanceof Date || value instanceof RegExp || value === null;
}
function shouldMerge(one, two) {
    if (!(0, _lodashMerge.isPlainObject)(one) || !(0, _lodashMerge.isPlainObject)(two)) return false;
    return true;
}

},{"./lodash.merge":"aYKTV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aYKTV":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */ parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
var objectTag = '[object Object]';
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
var objectCtorString = funcToString.call(Object);
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var nativeObjectToString = objectProto.toString;
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) return false;
    var proto = getPrototype(value);
    if (proto === null) return true;
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) return value === undefined ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    var unmasked = false;
    try {
        value[symToStringTag] = undefined;
        unmasked = true;
    } catch (e) {
    // silence
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) value[symToStringTag] = tag;
        else delete value[symToStringTag];
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bvHNU":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimeoutError", ()=>TimeoutError);
/**
 * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise
 * rejects, and resolves if the specified promise resolves.
 *
 * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.
 *
 * @param promise promise to use with timeout.
 * @param timeout the timeout in milliseconds until the returned promise is rejected.
 */ parcelHelpers.export(exports, "callWithTimeout", ()=>callWithTimeout);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Error that is thrown on timeouts.
 */ var TimeoutError = /** @class */ function(_super) {
    __extends(TimeoutError, _super);
    function TimeoutError(message) {
        var _this = _super.call(this, message) || this;
        // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:
        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error);
function callWithTimeout(promise, timeout) {
    var timeoutHandle;
    var timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
            reject(new TimeoutError('Operation timed out.'));
        }, timeout);
    });
    return Promise.race([
        promise,
        timeoutPromise
    ]).then(function(result) {
        clearTimeout(timeoutHandle);
        return result;
    }, function(reason) {
        clearTimeout(timeoutHandle);
        throw reason;
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jTVuX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ parcelHelpers.export(exports, "urlMatches", ()=>urlMatches);
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */ parcelHelpers.export(exports, "isUrlIgnored", ()=>isUrlIgnored);
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') return url === urlToMatch;
    else return !!url.match(urlToMatch);
}
function isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) return false;
    try {
        for(var ignoredUrls_1 = __values(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()){
            var ignoreUrl = ignoredUrls_1_1.value;
            if (urlMatches(url, ignoreUrl)) return true;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Hk1G":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Checks if certain function has been already wrapped
 * @param func
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isWrapped", ()=>isWrapped);
function isWrapped(func) {
    return typeof func === 'function' && typeof func.__original === 'function' && typeof func.__unwrap === 'function' && func.__wrapped === true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3StTD":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BindOnceFuture", ()=>BindOnceFuture);
var _promise = require("./promise");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */ var BindOnceFuture = /** @class */ function() {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new (0, _promise.Deferred)();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function() {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function() {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function() {
        var _a;
        var _this = this;
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, __spreadArray([
                    this._that
                ], __read(args), false))).then(function(val) {
                    return _this._deferred.resolve(val);
                }, function(err) {
                    return _this._deferred.reject(err);
                });
            } catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}();

},{"./promise":"3dEa6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3dEa6":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Deferred", ()=>Deferred);
var Deferred = /** @class */ function() {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function(resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function() {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function(val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function(err) {
        this._reject(err);
    };
    return Deferred;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jvx6I":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @internal
 * Shared functionality used by Exporters while exporting data, including suppression of Traces.
 */ parcelHelpers.export(exports, "_export", ()=>_export);
var _api = require("@opentelemetry/api");
var _suppressTracing = require("../trace/suppress-tracing");
function _export(exporter, arg) {
    return new Promise(function(resolve) {
        // prevent downstream exporter calls from generating spans
        (0, _api.context).with((0, _suppressTracing.suppressTracing)((0, _api.context).active()), function() {
            exporter.export(arg, function(result) {
                resolve(result);
            });
        });
    });
}

},{"@opentelemetry/api":"6AC4z","../trace/suppress-tracing":"6isaL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fspee":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SumAccumulation", ()=>SumAccumulation);
parcelHelpers.export(exports, "SumAggregator", ()=>SumAggregator);
var _types = require("./types");
var _metricData = require("../export/MetricData");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var SumAccumulation = /** @class */ function() {
    function SumAccumulation(startTime, monotonic, _current, reset) {
        if (_current === void 0) _current = 0;
        if (reset === void 0) reset = false;
        this.startTime = startTime;
        this.monotonic = monotonic;
        this._current = _current;
        this.reset = reset;
    }
    SumAccumulation.prototype.record = function(value) {
        if (this.monotonic && value < 0) return;
        this._current += value;
    };
    SumAccumulation.prototype.setStartTime = function(startTime) {
        this.startTime = startTime;
    };
    SumAccumulation.prototype.toPointValue = function() {
        return this._current;
    };
    return SumAccumulation;
}();
/** Basic aggregator which calculates a Sum from individual measurements. */ var SumAggregator = /** @class */ function() {
    function SumAggregator(monotonic) {
        this.monotonic = monotonic;
        this.kind = (0, _types.AggregatorKind).SUM;
    }
    SumAggregator.prototype.createAccumulation = function(startTime) {
        return new SumAccumulation(startTime, this.monotonic);
    };
    /**
     * Returns the result of the merge of the given accumulations.
     */ SumAggregator.prototype.merge = function(previous, delta) {
        var prevPv = previous.toPointValue();
        var deltaPv = delta.toPointValue();
        if (delta.reset) return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);
        return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
    };
    /**
     * Returns a new DELTA aggregation by comparing two cumulative measurements.
     */ SumAggregator.prototype.diff = function(previous, current) {
        var prevPv = previous.toPointValue();
        var currPv = current.toPointValue();
        /**
         * If the SumAggregator is a monotonic one and the previous point value is
         * greater than the current one, a reset is deemed to be happened.
         * Return the current point value to prevent the value from been reset.
         */ if (this.monotonic && prevPv > currPv) return new SumAccumulation(current.startTime, this.monotonic, currPv, true);
        return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
    };
    SumAggregator.prototype.toMetricData = function(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
            descriptor: descriptor,
            aggregationTemporality: aggregationTemporality,
            dataPointType: (0, _metricData.DataPointType).SUM,
            dataPoints: accumulationByAttributes.map(function(_a) {
                var _b = __read(_a, 2), attributes = _b[0], accumulation = _b[1];
                return {
                    attributes: attributes,
                    startTime: accumulation.startTime,
                    endTime: endTime,
                    value: accumulation.toPointValue()
                };
            }),
            isMonotonic: this.monotonic
        };
    };
    return SumAggregator;
}();

},{"./types":"5JQCw","../export/MetricData":"buI5y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5frcI":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PeriodicExportingMetricReader", ()=>PeriodicExportingMetricReader);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var _metricReader = require("./MetricReader");
var _utils = require("../utils");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to
 * the configured {@link PushMetricExporter}
 */ var PeriodicExportingMetricReader = /** @class */ function(_super) {
    __extends(PeriodicExportingMetricReader, _super);
    function PeriodicExportingMetricReader(options) {
        var _a, _b, _c, _d;
        var _this = _super.call(this, {
            aggregationSelector: (_a = options.exporter.selectAggregation) === null || _a === void 0 ? void 0 : _a.bind(options.exporter),
            aggregationTemporalitySelector: (_b = options.exporter.selectAggregationTemporality) === null || _b === void 0 ? void 0 : _b.bind(options.exporter),
            metricProducers: options.metricProducers
        }) || this;
        if (options.exportIntervalMillis !== undefined && options.exportIntervalMillis <= 0) throw Error('exportIntervalMillis must be greater than 0');
        if (options.exportTimeoutMillis !== undefined && options.exportTimeoutMillis <= 0) throw Error('exportTimeoutMillis must be greater than 0');
        if (options.exportTimeoutMillis !== undefined && options.exportIntervalMillis !== undefined && options.exportIntervalMillis < options.exportTimeoutMillis) throw Error('exportIntervalMillis must be greater than or equal to exportTimeoutMillis');
        _this._exportInterval = (_c = options.exportIntervalMillis) !== null && _c !== void 0 ? _c : 60000;
        _this._exportTimeout = (_d = options.exportTimeoutMillis) !== null && _d !== void 0 ? _d : 30000;
        _this._exporter = options.exporter;
        return _this;
    }
    PeriodicExportingMetricReader.prototype._runOnce = function() {
        return __awaiter(this, void 0, void 0, function() {
            var err_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        _a.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]);
                        return [
                            4 /*yield*/ ,
                            (0, _utils.callWithTimeout)(this._doRun(), this._exportTimeout)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 2:
                        err_1 = _a.sent();
                        if (err_1 instanceof (0, _utils.TimeoutError)) {
                            _api.diag.error('Export took longer than %s milliseconds and timed out.', this._exportTimeout);
                            return [
                                2 /*return*/ 
                            ];
                        }
                        (0, _core.globalErrorHandler)(err_1);
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    PeriodicExportingMetricReader.prototype._doRun = function() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function() {
            var _c, resourceMetrics, errors, e_1, result;
            var _d;
            return __generator(this, function(_e) {
                switch(_e.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.collect({
                                timeoutMillis: this._exportTimeout
                            })
                        ];
                    case 1:
                        _c = _e.sent(), resourceMetrics = _c.resourceMetrics, errors = _c.errors;
                        if (errors.length > 0) (_d = _api.diag).error.apply(_d, __spreadArray([
                            'PeriodicExportingMetricReader: metrics collection errors'
                        ], __read(errors), false));
                        if (!resourceMetrics.resource.asyncAttributesPending) return [
                            3 /*break*/ ,
                            5
                        ];
                        _e.label = 2;
                    case 2:
                        _e.trys.push([
                            2,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4 /*yield*/ ,
                            (_b = (_a = resourceMetrics.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a)
                        ];
                    case 3:
                        _e.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 4:
                        e_1 = _e.sent();
                        _api.diag.debug('Error while resolving async portion of resource: ', e_1);
                        (0, _core.globalErrorHandler)(e_1);
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 5:
                        return [
                            4 /*yield*/ ,
                            (0, _core.internal)._export(this._exporter, resourceMetrics)
                        ];
                    case 6:
                        result = _e.sent();
                        if (result.code !== (0, _core.ExportResultCode).SUCCESS) throw new Error("PeriodicExportingMetricReader: metrics export failed (error " + result.error + ")");
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    PeriodicExportingMetricReader.prototype.onInitialized = function() {
        var _this = this;
        // start running the interval as soon as this reader is initialized and keep handle for shutdown.
        this._interval = setInterval(function() {
            // this._runOnce never rejects. Using void operator to suppress @typescript-eslint/no-floating-promises.
            _this._runOnce();
        }, this._exportInterval);
        (0, _core.unrefTimer)(this._interval);
    };
    PeriodicExportingMetricReader.prototype.onForceFlush = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this._runOnce()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this._exporter.forceFlush()
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    PeriodicExportingMetricReader.prototype.onShutdown = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this._interval) clearInterval(this._interval);
                        return [
                            4 /*yield*/ ,
                            this._exporter.shutdown()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return PeriodicExportingMetricReader;
}((0, _metricReader.MetricReader));

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"5eoQV","./MetricReader":"kuWQE","../utils":"ai7q3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6kxES":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConsoleMetricExporter", ()=>ConsoleMetricExporter);
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var _core = require("@opentelemetry/core");
var _aggregationSelector = require("./AggregationSelector");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * This is an implementation of {@link PushMetricExporter} that prints metrics to the
 * console. This class can be used for diagnostic purposes.
 *
 * NOTE: This {@link PushMetricExporter} is intended for diagnostics use only, output rendered to the console may change at any time.
 */ /* eslint-disable no-console */ var ConsoleMetricExporter = /** @class */ function() {
    function ConsoleMetricExporter(options) {
        var _a;
        this._shutdown = false;
        this._temporalitySelector = (_a = options === null || options === void 0 ? void 0 : options.temporalitySelector) !== null && _a !== void 0 ? _a : (0, _aggregationSelector.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR);
    }
    ConsoleMetricExporter.prototype.export = function(metrics, resultCallback) {
        if (this._shutdown) {
            // If the exporter is shutting down, by spec, we need to return FAILED as export result
            setImmediate(resultCallback, {
                code: (0, _core.ExportResultCode).FAILED
            });
            return;
        }
        return ConsoleMetricExporter._sendMetrics(metrics, resultCallback);
    };
    ConsoleMetricExporter.prototype.forceFlush = function() {
        return Promise.resolve();
    };
    ConsoleMetricExporter.prototype.selectAggregationTemporality = function(_instrumentType) {
        return this._temporalitySelector(_instrumentType);
    };
    ConsoleMetricExporter.prototype.shutdown = function() {
        this._shutdown = true;
        return Promise.resolve();
    };
    ConsoleMetricExporter._sendMetrics = function(metrics, done) {
        var e_1, _a, e_2, _b;
        try {
            for(var _c = __values(metrics.scopeMetrics), _d = _c.next(); !_d.done; _d = _c.next()){
                var scopeMetrics = _d.value;
                try {
                    for(var _e = (e_2 = void 0, __values(scopeMetrics.metrics)), _f = _e.next(); !_f.done; _f = _e.next()){
                        var metric = _f.value;
                        console.dir({
                            descriptor: metric.descriptor,
                            dataPointType: metric.dataPointType,
                            dataPoints: metric.dataPoints
                        }, {
                            depth: null
                        });
                    }
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally{
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    } finally{
                        if (e_2) throw e_2.error;
                    }
                }
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        done({
            code: (0, _core.ExportResultCode).SUCCESS
        });
    };
    return ConsoleMetricExporter;
}();

},{"@opentelemetry/core":"5eoQV","./AggregationSelector":"9BrXY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2BGfA":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MeterProvider", ()=>MeterProvider);
var _api = require("@opentelemetry/api");
var _resources = require("@opentelemetry/resources");
var _meterProviderSharedState = require("./state/MeterProviderSharedState");
var _metricCollector = require("./state/MetricCollector");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * @param mergeWithDefaults
 * @param providedResource
 */ function prepareResource(mergeWithDefaults, providedResource) {
    var resource = providedResource !== null && providedResource !== void 0 ? providedResource : (0, _resources.Resource).empty();
    if (mergeWithDefaults) return (0, _resources.Resource).default().merge(resource);
    return resource;
}
/**
 * This class implements the {@link MeterProvider} interface.
 */ var MeterProvider = /** @class */ function() {
    function MeterProvider(options) {
        var e_1, _a, e_2, _b;
        var _c;
        this._shutdown = false;
        this._sharedState = new (0, _meterProviderSharedState.MeterProviderSharedState)(prepareResource((_c = options === null || options === void 0 ? void 0 : options.mergeResourceWithDefaults) !== null && _c !== void 0 ? _c : true, options === null || options === void 0 ? void 0 : options.resource));
        if ((options === null || options === void 0 ? void 0 : options.views) != null && options.views.length > 0) try {
            for(var _d = __values(options.views), _e = _d.next(); !_e.done; _e = _d.next()){
                var view = _e.value;
                this._sharedState.viewRegistry.addView(view);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.readers) != null && options.readers.length > 0) try {
            for(var _f = __values(options.readers), _g = _f.next(); !_g.done; _g = _f.next()){
                var metricReader = _g.value;
                this.addMetricReader(metricReader);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    }
    /**
     * Get a meter with the configuration of the MeterProvider.
     */ MeterProvider.prototype.getMeter = function(name, version, options) {
        if (version === void 0) version = '';
        if (options === void 0) options = {};
        // https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#meter-creation
        if (this._shutdown) {
            (0, _api.diag).warn('A shutdown MeterProvider cannot provide a Meter');
            return (0, _api.createNoopMeter)();
        }
        return this._sharedState.getMeterSharedState({
            name: name,
            version: version,
            schemaUrl: options.schemaUrl
        }).meter;
    };
    /**
     * Register a {@link MetricReader} to the meter provider. After the
     * registration, the MetricReader can start metrics collection.
     *
     * <p> NOTE: {@link MetricReader} instances MUST be added before creating any instruments.
     * A {@link MetricReader} instance registered later may receive no or incomplete metric data.
     *
     * @param metricReader the metric reader to be registered.
     *
     * @deprecated This method will be removed in SDK 2.0. Please use
     * {@link MeterProviderOptions.readers} via the {@link MeterProvider} constructor instead
     */ MeterProvider.prototype.addMetricReader = function(metricReader) {
        var collector = new (0, _metricCollector.MetricCollector)(this._sharedState, metricReader);
        metricReader.setMetricProducer(collector);
        this._sharedState.metricCollectors.push(collector);
    };
    /**
     * Flush all buffered data and shut down the MeterProvider and all registered
     * MetricReaders.
     *
     * Returns a promise which is resolved when all flushes are complete.
     */ MeterProvider.prototype.shutdown = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this._shutdown) {
                            (0, _api.diag).warn('shutdown may only be called once per MeterProvider');
                            return [
                                2 /*return*/ 
                            ];
                        }
                        this._shutdown = true;
                        return [
                            4 /*yield*/ ,
                            Promise.all(this._sharedState.metricCollectors.map(function(collector) {
                                return collector.shutdown(options);
                            }))
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Notifies all registered MetricReaders to flush any buffered data.
     *
     * Returns a promise which is resolved when all flushes are complete.
     */ MeterProvider.prototype.forceFlush = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        // do not flush after shutdown
                        if (this._shutdown) {
                            (0, _api.diag).warn('invalid attempt to force flush after MeterProvider shutdown');
                            return [
                                2 /*return*/ 
                            ];
                        }
                        return [
                            4 /*yield*/ ,
                            Promise.all(this._sharedState.metricCollectors.map(function(collector) {
                                return collector.forceFlush(options);
                            }))
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return MeterProvider;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/resources":"2KZDa","./state/MeterProviderSharedState":"lsSqe","./state/MetricCollector":"jJEUh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2KZDa":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Resource", ()=>(0, _resource.Resource));
parcelHelpers.export(exports, "defaultServiceName", ()=>(0, _platform.defaultServiceName));
parcelHelpers.export(exports, "browserDetector", ()=>(0, _detectors.browserDetector));
parcelHelpers.export(exports, "browserDetectorSync", ()=>(0, _detectors.browserDetectorSync));
parcelHelpers.export(exports, "envDetector", ()=>(0, _detectors.envDetector));
parcelHelpers.export(exports, "envDetectorSync", ()=>(0, _detectors.envDetectorSync));
parcelHelpers.export(exports, "hostDetector", ()=>(0, _detectors.hostDetector));
parcelHelpers.export(exports, "hostDetectorSync", ()=>(0, _detectors.hostDetectorSync));
parcelHelpers.export(exports, "osDetector", ()=>(0, _detectors.osDetector));
parcelHelpers.export(exports, "osDetectorSync", ()=>(0, _detectors.osDetectorSync));
parcelHelpers.export(exports, "processDetector", ()=>(0, _detectors.processDetector));
parcelHelpers.export(exports, "processDetectorSync", ()=>(0, _detectors.processDetectorSync));
parcelHelpers.export(exports, "serviceInstanceIdDetectorSync", ()=>(0, _detectors.serviceInstanceIdDetectorSync));
parcelHelpers.export(exports, "detectResourcesSync", ()=>(0, _detectResources.detectResourcesSync));
parcelHelpers.export(exports, "detectResources", ()=>(0, _detectResources.detectResources));
var _resource = require("./Resource");
var _platform = require("./platform");
var _detectors = require("./detectors");
var _detectResources = require("./detect-resources");

},{"./Resource":"7I81F","./platform":false,"./detectors":false,"./detect-resources":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7I81F":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Resource", ()=>Resource);
var _api = require("@opentelemetry/api");
var _semanticConventions = require("@opentelemetry/semantic-conventions");
var _core = require("@opentelemetry/core");
var _platform = require("./platform");
var __assign = undefined && undefined.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
/**
 * A Resource describes the entity for which a signals (metrics or trace) are
 * collected.
 */ var Resource = /** @class */ function() {
    function Resource(/**
     * A dictionary of attributes with string keys and values that provide
     * information about the entity as numbers, strings or booleans
     * TODO: Consider to add check/validation on attributes.
     */ attributes, asyncAttributesPromise) {
        var _this = this;
        var _a;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then(function(asyncAttributes) {
            _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);
            _this.asyncAttributesPending = false;
            return asyncAttributes;
        }, function(err) {
            (0, _api.diag).debug("a resource's async attributes promise rejected: %s", err);
            _this.asyncAttributesPending = false;
            return {};
        });
    }
    /**
     * Returns an empty Resource
     */ Resource.empty = function() {
        return Resource.EMPTY;
    };
    /**
     * Returns a Resource that identifies the SDK in use.
     */ Resource.default = function() {
        var _a;
        return new Resource((_a = {}, _a[0, _semanticConventions.SEMRESATTRS_SERVICE_NAME] = (0, _platform.defaultServiceName)(), _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = (0, _core.SDK_INFO)[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE], _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_NAME] = (0, _core.SDK_INFO)[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_NAME], _a[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_VERSION] = (0, _core.SDK_INFO)[0, _semanticConventions.SEMRESATTRS_TELEMETRY_SDK_VERSION], _a));
    };
    Object.defineProperty(Resource.prototype, "attributes", {
        get: function() {
            var _a;
            if (this.asyncAttributesPending) (0, _api.diag).error('Accessing resource attributes before async attributes settled');
            return (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
     * this Resource's attributes. This is useful in exporters to block until resource detection
     * has finished.
     */ Resource.prototype.waitForAsyncAttributes = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!this.asyncAttributesPending) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this._asyncAttributesPromise
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Returns a new, merged {@link Resource} by merging the current Resource
     * with the other Resource. In case of a collision, other Resource takes
     * precedence.
     *
     * @param other the Resource that will be merged with this.
     * @returns the newly merged Resource.
     */ Resource.prototype.merge = function(other) {
        var _this = this;
        var _a;
        if (!other) return this;
        // SpanAttributes from other resource overwrite attributes from this resource.
        var mergedSyncAttributes = __assign(__assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) return new Resource(mergedSyncAttributes);
        var mergedAttributesPromise = Promise.all([
            this._asyncAttributesPromise,
            other._asyncAttributesPromise
        ]).then(function(_a) {
            var _b;
            var _c = __read(_a, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];
            return __assign(__assign(__assign(__assign({}, _this._syncAttributes), thisAsyncAttributes), (_b = other._syncAttributes) !== null && _b !== void 0 ? _b : other.attributes), otherAsyncAttributes);
        });
        return new Resource(mergedSyncAttributes, mergedAttributesPromise);
    };
    Resource.EMPTY = new Resource({});
    return Resource;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/semantic-conventions":"lCgfj","@opentelemetry/core":"5eoQV","./platform":"kQlHI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kQlHI":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultServiceName", ()=>(0, _defaultServiceName.defaultServiceName));
var _defaultServiceName = require("./default-service-name");

},{"./default-service-name":"hS0sJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hS0sJ":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultServiceName", ()=>defaultServiceName);
function defaultServiceName() {
    return 'unknown_service';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lsSqe":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MeterProviderSharedState", ()=>MeterProviderSharedState);
var _utils = require("../utils");
var _viewRegistry = require("../view/ViewRegistry");
var _meterSharedState = require("./MeterSharedState");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * An internal record for shared meter provider states.
 */ var MeterProviderSharedState = /** @class */ function() {
    function MeterProviderSharedState(resource) {
        this.resource = resource;
        this.viewRegistry = new (0, _viewRegistry.ViewRegistry)();
        this.metricCollectors = [];
        this.meterSharedStates = new Map();
    }
    MeterProviderSharedState.prototype.getMeterSharedState = function(instrumentationScope) {
        var id = (0, _utils.instrumentationScopeId)(instrumentationScope);
        var meterSharedState = this.meterSharedStates.get(id);
        if (meterSharedState == null) {
            meterSharedState = new (0, _meterSharedState.MeterSharedState)(this, instrumentationScope);
            this.meterSharedStates.set(id, meterSharedState);
        }
        return meterSharedState;
    };
    MeterProviderSharedState.prototype.selectAggregations = function(instrumentType) {
        var e_1, _a;
        var result = [];
        try {
            for(var _b = __values(this.metricCollectors), _c = _b.next(); !_c.done; _c = _b.next()){
                var collector = _c.value;
                result.push([
                    collector,
                    collector.selectAggregation(instrumentType)
                ]);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return result;
    };
    return MeterProviderSharedState;
}();

},{"../utils":"ai7q3","../view/ViewRegistry":"1EZJX","./MeterSharedState":"jV7JN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1EZJX":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ViewRegistry", ()=>ViewRegistry);
var ViewRegistry = /** @class */ function() {
    function ViewRegistry() {
        this._registeredViews = [];
    }
    ViewRegistry.prototype.addView = function(view) {
        this._registeredViews.push(view);
    };
    ViewRegistry.prototype.findViews = function(instrument, meter) {
        var _this = this;
        var views = this._registeredViews.filter(function(registeredView) {
            return _this._matchInstrument(registeredView.instrumentSelector, instrument) && _this._matchMeter(registeredView.meterSelector, meter);
        });
        return views;
    };
    ViewRegistry.prototype._matchInstrument = function(selector, instrument) {
        return (selector.getType() === undefined || instrument.type === selector.getType()) && selector.getNameFilter().match(instrument.name) && selector.getUnitFilter().match(instrument.unit);
    };
    ViewRegistry.prototype._matchMeter = function(selector, meter) {
        return selector.getNameFilter().match(meter.name) && (meter.version === undefined || selector.getVersionFilter().match(meter.version)) && (meter.schemaUrl === undefined || selector.getSchemaUrlFilter().match(meter.schemaUrl));
    };
    return ViewRegistry;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jV7JN":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MeterSharedState", ()=>MeterSharedState);
var _instrumentDescriptor = require("../InstrumentDescriptor");
var _meter = require("../Meter");
var _utils = require("../utils");
var _asyncMetricStorage = require("./AsyncMetricStorage");
var _metricStorageRegistry = require("./MetricStorageRegistry");
var _multiWritableMetricStorage = require("./MultiWritableMetricStorage");
var _observableRegistry = require("./ObservableRegistry");
var _syncMetricStorage = require("./SyncMetricStorage");
var _attributesProcessor = require("../view/AttributesProcessor");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
/**
 * An internal record for shared meter provider states.
 */ var MeterSharedState = /** @class */ function() {
    function MeterSharedState(_meterProviderSharedState, _instrumentationScope) {
        this._meterProviderSharedState = _meterProviderSharedState;
        this._instrumentationScope = _instrumentationScope;
        this.metricStorageRegistry = new (0, _metricStorageRegistry.MetricStorageRegistry)();
        this.observableRegistry = new (0, _observableRegistry.ObservableRegistry)();
        this.meter = new (0, _meter.Meter)(this);
    }
    MeterSharedState.prototype.registerMetricStorage = function(descriptor) {
        var storages = this._registerMetricStorage(descriptor, (0, _syncMetricStorage.SyncMetricStorage));
        if (storages.length === 1) return storages[0];
        return new (0, _multiWritableMetricStorage.MultiMetricStorage)(storages);
    };
    MeterSharedState.prototype.registerAsyncMetricStorage = function(descriptor) {
        var storages = this._registerMetricStorage(descriptor, (0, _asyncMetricStorage.AsyncMetricStorage));
        return storages;
    };
    /**
     * @param collector opaque handle of {@link MetricCollector} which initiated the collection.
     * @param collectionTime the HrTime at which the collection was initiated.
     * @param options options for collection.
     * @returns the list of metric data collected.
     */ MeterSharedState.prototype.collect = function(collector, collectionTime, options) {
        return __awaiter(this, void 0, void 0, function() {
            var errors, storages, metricDataList;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.observableRegistry.observe(collectionTime, options === null || options === void 0 ? void 0 : options.timeoutMillis)
                        ];
                    case 1:
                        errors = _a.sent();
                        storages = this.metricStorageRegistry.getStorages(collector);
                        // prevent more allocations if there are no storages.
                        if (storages.length === 0) return [
                            2 /*return*/ ,
                            null
                        ];
                        metricDataList = storages.map(function(metricStorage) {
                            return metricStorage.collect(collector, collectionTime);
                        }).filter((0, _utils.isNotNullish));
                        // skip this scope if no data was collected (storage created, but no data observed)
                        if (metricDataList.length === 0) return [
                            2 /*return*/ ,
                            {
                                errors: errors
                            }
                        ];
                        return [
                            2 /*return*/ ,
                            {
                                scopeMetrics: {
                                    scope: this._instrumentationScope,
                                    metrics: metricDataList
                                },
                                errors: errors
                            }
                        ];
                }
            });
        });
    };
    MeterSharedState.prototype._registerMetricStorage = function(descriptor, MetricStorageType) {
        var _this = this;
        var views = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope);
        var storages = views.map(function(view) {
            var viewDescriptor = (0, _instrumentDescriptor.createInstrumentDescriptorWithView)(view, descriptor);
            var compatibleStorage = _this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
            if (compatibleStorage != null) return compatibleStorage;
            var aggregator = view.aggregation.createAggregator(viewDescriptor);
            var viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, _this._meterProviderSharedState.metricCollectors, view.aggregationCardinalityLimit);
            _this.metricStorageRegistry.register(viewStorage);
            return viewStorage;
        });
        // Fallback to the per-collector aggregations if no view is configured for the instrument.
        if (storages.length === 0) {
            var perCollectorAggregations = this._meterProviderSharedState.selectAggregations(descriptor.type);
            var collectorStorages = perCollectorAggregations.map(function(_a) {
                var _b = __read(_a, 2), collector = _b[0], aggregation = _b[1];
                var compatibleStorage = _this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);
                if (compatibleStorage != null) return compatibleStorage;
                var aggregator = aggregation.createAggregator(descriptor);
                var cardinalityLimit = collector.selectCardinalityLimit(descriptor.type);
                var storage = new MetricStorageType(descriptor, aggregator, (0, _attributesProcessor.AttributesProcessor).Noop(), [
                    collector
                ], cardinalityLimit);
                _this.metricStorageRegistry.registerForCollector(collector, storage);
                return storage;
            });
            storages = storages.concat(collectorStorages);
        }
        return storages;
    };
    return MeterSharedState;
}();

},{"../InstrumentDescriptor":"ibIoU","../Meter":"2Ncpi","../utils":"ai7q3","./AsyncMetricStorage":"iq0r5","./MetricStorageRegistry":"bRhIn","./MultiWritableMetricStorage":"lbysB","./ObservableRegistry":"7Hovj","./SyncMetricStorage":"2tXBR","../view/AttributesProcessor":"87C0N","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Ncpi":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Meter", ()=>Meter);
var _instrumentDescriptor = require("./InstrumentDescriptor");
var _instruments = require("./Instruments");
/**
 * This class implements the {@link IMeter} interface.
 */ var Meter = /** @class */ function() {
    function Meter(_meterSharedState) {
        this._meterSharedState = _meterSharedState;
    }
    /**
     * Create a {@link Gauge} instrument.
     */ Meter.prototype.createGauge = function(name, options) {
        var descriptor = (0, _instrumentDescriptor.createInstrumentDescriptor)(name, (0, _instrumentDescriptor.InstrumentType).GAUGE, options);
        var storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new (0, _instruments.GaugeInstrument)(storage, descriptor);
    };
    /**
     * Create a {@link Histogram} instrument.
     */ Meter.prototype.createHistogram = function(name, options) {
        var descriptor = (0, _instrumentDescriptor.createInstrumentDescriptor)(name, (0, _instrumentDescriptor.InstrumentType).HISTOGRAM, options);
        var storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new (0, _instruments.HistogramInstrument)(storage, descriptor);
    };
    /**
     * Create a {@link Counter} instrument.
     */ Meter.prototype.createCounter = function(name, options) {
        var descriptor = (0, _instrumentDescriptor.createInstrumentDescriptor)(name, (0, _instrumentDescriptor.InstrumentType).COUNTER, options);
        var storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new (0, _instruments.CounterInstrument)(storage, descriptor);
    };
    /**
     * Create a {@link UpDownCounter} instrument.
     */ Meter.prototype.createUpDownCounter = function(name, options) {
        var descriptor = (0, _instrumentDescriptor.createInstrumentDescriptor)(name, (0, _instrumentDescriptor.InstrumentType).UP_DOWN_COUNTER, options);
        var storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new (0, _instruments.UpDownCounterInstrument)(storage, descriptor);
    };
    /**
     * Create a {@link ObservableGauge} instrument.
     */ Meter.prototype.createObservableGauge = function(name, options) {
        var descriptor = (0, _instrumentDescriptor.createInstrumentDescriptor)(name, (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_GAUGE, options);
        var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new (0, _instruments.ObservableGaugeInstrument)(descriptor, storages, this._meterSharedState.observableRegistry);
    };
    /**
     * Create a {@link ObservableCounter} instrument.
     */ Meter.prototype.createObservableCounter = function(name, options) {
        var descriptor = (0, _instrumentDescriptor.createInstrumentDescriptor)(name, (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_COUNTER, options);
        var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new (0, _instruments.ObservableCounterInstrument)(descriptor, storages, this._meterSharedState.observableRegistry);
    };
    /**
     * Create a {@link ObservableUpDownCounter} instrument.
     */ Meter.prototype.createObservableUpDownCounter = function(name, options) {
        var descriptor = (0, _instrumentDescriptor.createInstrumentDescriptor)(name, (0, _instrumentDescriptor.InstrumentType).OBSERVABLE_UP_DOWN_COUNTER, options);
        var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new (0, _instruments.ObservableUpDownCounterInstrument)(descriptor, storages, this._meterSharedState.observableRegistry);
    };
    /**
     * @see {@link Meter.addBatchObservableCallback}
     */ Meter.prototype.addBatchObservableCallback = function(callback, observables) {
        this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
    };
    /**
     * @see {@link Meter.removeBatchObservableCallback}
     */ Meter.prototype.removeBatchObservableCallback = function(callback, observables) {
        this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
    };
    return Meter;
}();

},{"./InstrumentDescriptor":"ibIoU","./Instruments":"fAuRc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fAuRc":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SyncInstrument", ()=>SyncInstrument);
parcelHelpers.export(exports, "UpDownCounterInstrument", ()=>UpDownCounterInstrument);
parcelHelpers.export(exports, "CounterInstrument", ()=>CounterInstrument);
parcelHelpers.export(exports, "GaugeInstrument", ()=>GaugeInstrument);
parcelHelpers.export(exports, "HistogramInstrument", ()=>HistogramInstrument);
parcelHelpers.export(exports, "ObservableInstrument", ()=>ObservableInstrument);
parcelHelpers.export(exports, "ObservableCounterInstrument", ()=>ObservableCounterInstrument);
parcelHelpers.export(exports, "ObservableGaugeInstrument", ()=>ObservableGaugeInstrument);
parcelHelpers.export(exports, "ObservableUpDownCounterInstrument", ()=>ObservableUpDownCounterInstrument);
parcelHelpers.export(exports, "isObservableInstrument", ()=>isObservableInstrument);
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var SyncInstrument = /** @class */ function() {
    function SyncInstrument(_writableMetricStorage, _descriptor) {
        this._writableMetricStorage = _writableMetricStorage;
        this._descriptor = _descriptor;
    }
    SyncInstrument.prototype._record = function(value, attributes, context) {
        if (attributes === void 0) attributes = {};
        if (context === void 0) context = (0, _api.context).active();
        if (typeof value !== 'number') {
            (0, _api.diag).warn("non-number value provided to metric " + this._descriptor.name + ": " + value);
            return;
        }
        if (this._descriptor.valueType === (0, _api.ValueType).INT && !Number.isInteger(value)) {
            (0, _api.diag).warn("INT value type cannot accept a floating-point value for " + this._descriptor.name + ", ignoring the fractional digits.");
            value = Math.trunc(value);
            // ignore non-finite values.
            if (!Number.isInteger(value)) return;
        }
        this._writableMetricStorage.record(value, attributes, context, (0, _core.millisToHrTime)(Date.now()));
    };
    return SyncInstrument;
}();
/**
 * The class implements {@link UpDownCounter} interface.
 */ var UpDownCounterInstrument = /** @class */ function(_super) {
    __extends(UpDownCounterInstrument, _super);
    function UpDownCounterInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Increment value of counter by the input. Inputs may be negative.
     */ UpDownCounterInstrument.prototype.add = function(value, attributes, ctx) {
        this._record(value, attributes, ctx);
    };
    return UpDownCounterInstrument;
}(SyncInstrument);
/**
 * The class implements {@link Counter} interface.
 */ var CounterInstrument = /** @class */ function(_super) {
    __extends(CounterInstrument, _super);
    function CounterInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Increment value of counter by the input. Inputs may not be negative.
     */ CounterInstrument.prototype.add = function(value, attributes, ctx) {
        if (value < 0) {
            (0, _api.diag).warn("negative value provided to counter " + this._descriptor.name + ": " + value);
            return;
        }
        this._record(value, attributes, ctx);
    };
    return CounterInstrument;
}(SyncInstrument);
/**
 * The class implements {@link Gauge} interface.
 */ var GaugeInstrument = /** @class */ function(_super) {
    __extends(GaugeInstrument, _super);
    function GaugeInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Records a measurement.
     */ GaugeInstrument.prototype.record = function(value, attributes, ctx) {
        this._record(value, attributes, ctx);
    };
    return GaugeInstrument;
}(SyncInstrument);
/**
 * The class implements {@link Histogram} interface.
 */ var HistogramInstrument = /** @class */ function(_super) {
    __extends(HistogramInstrument, _super);
    function HistogramInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Records a measurement. Value of the measurement must not be negative.
     */ HistogramInstrument.prototype.record = function(value, attributes, ctx) {
        if (value < 0) {
            (0, _api.diag).warn("negative value provided to histogram " + this._descriptor.name + ": " + value);
            return;
        }
        this._record(value, attributes, ctx);
    };
    return HistogramInstrument;
}(SyncInstrument);
var ObservableInstrument = /** @class */ function() {
    function ObservableInstrument(descriptor, metricStorages, _observableRegistry) {
        this._observableRegistry = _observableRegistry;
        this._descriptor = descriptor;
        this._metricStorages = metricStorages;
    }
    /**
     * @see {Observable.addCallback}
     */ ObservableInstrument.prototype.addCallback = function(callback) {
        this._observableRegistry.addCallback(callback, this);
    };
    /**
     * @see {Observable.removeCallback}
     */ ObservableInstrument.prototype.removeCallback = function(callback) {
        this._observableRegistry.removeCallback(callback, this);
    };
    return ObservableInstrument;
}();
var ObservableCounterInstrument = /** @class */ function(_super) {
    __extends(ObservableCounterInstrument, _super);
    function ObservableCounterInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ObservableCounterInstrument;
}(ObservableInstrument);
var ObservableGaugeInstrument = /** @class */ function(_super) {
    __extends(ObservableGaugeInstrument, _super);
    function ObservableGaugeInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ObservableGaugeInstrument;
}(ObservableInstrument);
var ObservableUpDownCounterInstrument = /** @class */ function(_super) {
    __extends(ObservableUpDownCounterInstrument, _super);
    function ObservableUpDownCounterInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ObservableUpDownCounterInstrument;
}(ObservableInstrument);
function isObservableInstrument(it) {
    return it instanceof ObservableInstrument;
}

},{"@opentelemetry/api":"6AC4z","@opentelemetry/core":"5eoQV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iq0r5":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncMetricStorage", ()=>AsyncMetricStorage);
var _metricStorage = require("./MetricStorage");
var _deltaMetricProcessor = require("./DeltaMetricProcessor");
var _temporalMetricProcessor = require("./TemporalMetricProcessor");
var _hashMap = require("./HashMap");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
/**
 * Internal interface.
 *
 * Stores and aggregates {@link MetricData} for asynchronous instruments.
 */ var AsyncMetricStorage = /** @class */ function(_super) {
    __extends(AsyncMetricStorage, _super);
    function AsyncMetricStorage(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles, _aggregationCardinalityLimit) {
        var _this = _super.call(this, _instrumentDescriptor) || this;
        _this._attributesProcessor = _attributesProcessor;
        _this._aggregationCardinalityLimit = _aggregationCardinalityLimit;
        _this._deltaMetricStorage = new (0, _deltaMetricProcessor.DeltaMetricProcessor)(aggregator, _this._aggregationCardinalityLimit);
        _this._temporalMetricStorage = new (0, _temporalMetricProcessor.TemporalMetricProcessor)(aggregator, collectorHandles);
        return _this;
    }
    AsyncMetricStorage.prototype.record = function(measurements, observationTime) {
        var _this = this;
        var processed = new (0, _hashMap.AttributeHashMap)();
        Array.from(measurements.entries()).forEach(function(_a) {
            var _b = __read(_a, 2), attributes = _b[0], value = _b[1];
            processed.set(_this._attributesProcessor.process(attributes), value);
        });
        this._deltaMetricStorage.batchCumulate(processed, observationTime);
    };
    /**
     * Collects the metrics from this storage. The ObservableCallback is invoked
     * during the collection.
     *
     * Note: This is a stateful operation and may reset any interval-related
     * state for the MetricCollector.
     */ AsyncMetricStorage.prototype.collect = function(collector, collectionTime) {
        var accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
    };
    return AsyncMetricStorage;
}((0, _metricStorage.MetricStorage));

},{"./MetricStorage":"4ecsG","./DeltaMetricProcessor":"12gyp","./TemporalMetricProcessor":"1uLc2","./HashMap":"fbviK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ecsG":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricStorage", ()=>MetricStorage);
var _instrumentDescriptor = require("../InstrumentDescriptor");
/**
 * Internal interface.
 *
 * Represents a storage from which we can collect metrics.
 */ var MetricStorage = /** @class */ function() {
    function MetricStorage(_instrumentDescriptor) {
        this._instrumentDescriptor = _instrumentDescriptor;
    }
    MetricStorage.prototype.getInstrumentDescriptor = function() {
        return this._instrumentDescriptor;
    };
    MetricStorage.prototype.updateDescription = function(description) {
        this._instrumentDescriptor = (0, _instrumentDescriptor.createInstrumentDescriptor)(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
            description: description,
            valueType: this._instrumentDescriptor.valueType,
            unit: this._instrumentDescriptor.unit,
            advice: this._instrumentDescriptor.advice
        });
    };
    return MetricStorage;
}();

},{"../InstrumentDescriptor":"ibIoU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"12gyp":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DeltaMetricProcessor", ()=>DeltaMetricProcessor);
var _utils = require("../utils");
var _hashMap = require("./HashMap");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
/**
 * Internal interface.
 *
 * Allows synchronous collection of metrics. This processor should allow
 * allocation of new aggregation cells for metrics and convert cumulative
 * recording to delta data points.
 */ var DeltaMetricProcessor = /** @class */ function() {
    function DeltaMetricProcessor(_aggregator, aggregationCardinalityLimit) {
        this._aggregator = _aggregator;
        this._activeCollectionStorage = new (0, _hashMap.AttributeHashMap)();
        // TODO: find a reasonable mean to clean the memo;
        // https://github.com/open-telemetry/opentelemetry-specification/pull/2208
        this._cumulativeMemoStorage = new (0, _hashMap.AttributeHashMap)();
        this._overflowAttributes = {
            'otel.metric.overflow': true
        };
        this._cardinalityLimit = (aggregationCardinalityLimit !== null && aggregationCardinalityLimit !== void 0 ? aggregationCardinalityLimit : 2000) - 1;
        this._overflowHashCode = (0, _utils.hashAttributes)(this._overflowAttributes);
    }
    DeltaMetricProcessor.prototype.record = function(value, attributes, _context, collectionTime) {
        var _this = this;
        var accumulation = this._activeCollectionStorage.get(attributes);
        if (!accumulation) {
            if (this._activeCollectionStorage.size >= this._cardinalityLimit) {
                var overflowAccumulation = this._activeCollectionStorage.getOrDefault(this._overflowAttributes, function() {
                    return _this._aggregator.createAccumulation(collectionTime);
                });
                overflowAccumulation === null || overflowAccumulation === void 0 || overflowAccumulation.record(value);
                return;
            }
            accumulation = this._aggregator.createAccumulation(collectionTime);
            this._activeCollectionStorage.set(attributes, accumulation);
        }
        accumulation === null || accumulation === void 0 || accumulation.record(value);
    };
    DeltaMetricProcessor.prototype.batchCumulate = function(measurements, collectionTime) {
        var _this = this;
        Array.from(measurements.entries()).forEach(function(_a) {
            var _b = __read(_a, 3), attributes = _b[0], value = _b[1], hashCode = _b[2];
            var accumulation = _this._aggregator.createAccumulation(collectionTime);
            accumulation === null || accumulation === void 0 || accumulation.record(value);
            var delta = accumulation;
            // Diff with recorded cumulative memo.
            if (_this._cumulativeMemoStorage.has(attributes, hashCode)) {
                // has() returned true, previous is present.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var previous = _this._cumulativeMemoStorage.get(attributes, hashCode);
                delta = _this._aggregator.diff(previous, accumulation);
            } else // If the cardinality limit is reached, we need to change the attributes
            if (_this._cumulativeMemoStorage.size >= _this._cardinalityLimit) {
                attributes = _this._overflowAttributes;
                hashCode = _this._overflowHashCode;
                if (_this._cumulativeMemoStorage.has(attributes, hashCode)) {
                    var previous = _this._cumulativeMemoStorage.get(attributes, hashCode);
                    delta = _this._aggregator.diff(previous, accumulation);
                }
            }
            // Merge with uncollected active delta.
            if (_this._activeCollectionStorage.has(attributes, hashCode)) {
                // has() returned true, previous is present.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var active = _this._activeCollectionStorage.get(attributes, hashCode);
                delta = _this._aggregator.merge(active, delta);
            }
            // Save the current record and the delta record.
            _this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);
            _this._activeCollectionStorage.set(attributes, delta, hashCode);
        });
    };
    /**
     * Returns a collection of delta metrics. Start time is the when first
     * time event collected.
     */ DeltaMetricProcessor.prototype.collect = function() {
        var unreportedDelta = this._activeCollectionStorage;
        this._activeCollectionStorage = new (0, _hashMap.AttributeHashMap)();
        return unreportedDelta;
    };
    return DeltaMetricProcessor;
}();

},{"../utils":"ai7q3","./HashMap":"fbviK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fbviK":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HashMap", ()=>HashMap);
parcelHelpers.export(exports, "AttributeHashMap", ()=>AttributeHashMap);
var _utils = require("../utils");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var HashMap = /** @class */ function() {
    function HashMap(_hash) {
        this._hash = _hash;
        this._valueMap = new Map();
        this._keyMap = new Map();
    }
    HashMap.prototype.get = function(key, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : hashCode = this._hash(key);
        return this._valueMap.get(hashCode);
    };
    HashMap.prototype.getOrDefault = function(key, defaultFactory) {
        var hash = this._hash(key);
        if (this._valueMap.has(hash)) return this._valueMap.get(hash);
        var val = defaultFactory();
        if (!this._keyMap.has(hash)) this._keyMap.set(hash, key);
        this._valueMap.set(hash, val);
        return val;
    };
    HashMap.prototype.set = function(key, value, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : hashCode = this._hash(key);
        if (!this._keyMap.has(hashCode)) this._keyMap.set(hashCode, key);
        this._valueMap.set(hashCode, value);
    };
    HashMap.prototype.has = function(key, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : hashCode = this._hash(key);
        return this._valueMap.has(hashCode);
    };
    HashMap.prototype.keys = function() {
        var keyIterator, next;
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    keyIterator = this._keyMap.entries();
                    next = keyIterator.next();
                    _a.label = 1;
                case 1:
                    if (!(next.done !== true)) return [
                        3 /*break*/ ,
                        3
                    ];
                    return [
                        4 /*yield*/ ,
                        [
                            next.value[1],
                            next.value[0]
                        ]
                    ];
                case 2:
                    _a.sent();
                    next = keyIterator.next();
                    return [
                        3 /*break*/ ,
                        1
                    ];
                case 3:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    HashMap.prototype.entries = function() {
        var valueIterator, next;
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    valueIterator = this._valueMap.entries();
                    next = valueIterator.next();
                    _a.label = 1;
                case 1:
                    if (!(next.done !== true)) return [
                        3 /*break*/ ,
                        3
                    ];
                    // next.value[0] here can not be undefined
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    return [
                        4 /*yield*/ ,
                        [
                            this._keyMap.get(next.value[0]),
                            next.value[1],
                            next.value[0]
                        ]
                    ];
                case 2:
                    // next.value[0] here can not be undefined
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    _a.sent();
                    next = valueIterator.next();
                    return [
                        3 /*break*/ ,
                        1
                    ];
                case 3:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    Object.defineProperty(HashMap.prototype, "size", {
        get: function() {
            return this._valueMap.size;
        },
        enumerable: false,
        configurable: true
    });
    return HashMap;
}();
var AttributeHashMap = /** @class */ function(_super) {
    __extends(AttributeHashMap, _super);
    function AttributeHashMap() {
        return _super.call(this, (0, _utils.hashAttributes)) || this;
    }
    return AttributeHashMap;
}(HashMap);

},{"../utils":"ai7q3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1uLc2":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TemporalMetricProcessor", ()=>TemporalMetricProcessor);
var _aggregationTemporality = require("../export/AggregationTemporality");
var _hashMap = require("./HashMap");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
/**
 * Internal interface.
 *
 * Provides unique reporting for each collector. Allows synchronous collection
 * of metrics and reports given temporality values.
 */ var TemporalMetricProcessor = /** @class */ function() {
    function TemporalMetricProcessor(_aggregator, collectorHandles) {
        var _this = this;
        this._aggregator = _aggregator;
        this._unreportedAccumulations = new Map();
        this._reportHistory = new Map();
        collectorHandles.forEach(function(handle) {
            _this._unreportedAccumulations.set(handle, []);
        });
    }
    /**
     * Builds the {@link MetricData} streams to report against a specific MetricCollector.
     * @param collector The information of the MetricCollector.
     * @param collectors The registered collectors.
     * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.
     * @param currentAccumulations The current accumulation of metric data from instruments.
     * @param collectionTime The current collection timestamp.
     * @returns The {@link MetricData} points or `null`.
     */ TemporalMetricProcessor.prototype.buildMetrics = function(collector, instrumentDescriptor, currentAccumulations, collectionTime) {
        this._stashAccumulations(currentAccumulations);
        var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);
        var result = unreportedAccumulations;
        var aggregationTemporality;
        // Check our last report time.
        if (this._reportHistory.has(collector)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var last = this._reportHistory.get(collector);
            var lastCollectionTime = last.collectionTime;
            aggregationTemporality = last.aggregationTemporality;
            // Use aggregation temporality + instrument to determine if we do a merge or a diff of
            // previous. We have the following four scenarios:
            // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).
            //    Here we merge with our last record to get a cumulative aggregation.
            // 2. Cumulative Aggregation + Cumulative recording (async instrument).
            //    Cumulative records are converted to delta recording with DeltaMetricProcessor.
            //    Here we merge with our last record to get a cumulative aggregation.
            // 3. Delta Aggregation + Delta recording
            //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.
            // 4. Delta Aggregation + Cumulative recording.
            //    Cumulative records are converted to delta recording with DeltaMetricProcessor.
            //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.
            if (aggregationTemporality === (0, _aggregationTemporality.AggregationTemporality).CUMULATIVE) // We need to make sure the current delta recording gets merged into the previous cumulative
            // for the next cumulative recording.
            result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);
            else result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);
        } else // Call into user code to select aggregation temporality for the instrument.
        aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
        // Update last reported (cumulative) accumulation.
        this._reportHistory.set(collector, {
            accumulations: result,
            collectionTime: collectionTime,
            aggregationTemporality: aggregationTemporality
        });
        var accumulationRecords = AttributesMapToAccumulationRecords(result);
        // do not convert to metric data if there is nothing to convert.
        if (accumulationRecords.length === 0) return undefined;
        return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, accumulationRecords, /* endTime */ collectionTime);
    };
    TemporalMetricProcessor.prototype._stashAccumulations = function(currentAccumulation) {
        var e_1, _a;
        var registeredCollectors = this._unreportedAccumulations.keys();
        try {
            for(var registeredCollectors_1 = __values(registeredCollectors), registeredCollectors_1_1 = registeredCollectors_1.next(); !registeredCollectors_1_1.done; registeredCollectors_1_1 = registeredCollectors_1.next()){
                var collector = registeredCollectors_1_1.value;
                var stash = this._unreportedAccumulations.get(collector);
                if (stash === undefined) {
                    stash = [];
                    this._unreportedAccumulations.set(collector, stash);
                }
                stash.push(currentAccumulation);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (registeredCollectors_1_1 && !registeredCollectors_1_1.done && (_a = registeredCollectors_1.return)) _a.call(registeredCollectors_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    };
    TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function(collector) {
        var e_2, _a;
        var result = new (0, _hashMap.AttributeHashMap)();
        var unreportedList = this._unreportedAccumulations.get(collector);
        this._unreportedAccumulations.set(collector, []);
        if (unreportedList === undefined) return result;
        try {
            for(var unreportedList_1 = __values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()){
                var it_1 = unreportedList_1_1.value;
                result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
        return result;
    };
    TemporalMetricProcessor.merge = function(last, current, aggregator) {
        var result = last;
        var iterator = current.entries();
        var next = iterator.next();
        while(next.done !== true){
            var _a = __read(next.value, 3), key = _a[0], record = _a[1], hash = _a[2];
            if (last.has(key, hash)) {
                var lastAccumulation = last.get(key, hash);
                // last.has() returned true, lastAccumulation is present.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var accumulation = aggregator.merge(lastAccumulation, record);
                result.set(key, accumulation, hash);
            } else result.set(key, record, hash);
            next = iterator.next();
        }
        return result;
    };
    /**
     * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves
     * the new stream to be the initial observation time unchanged.
     */ TemporalMetricProcessor.calibrateStartTime = function(last, current, lastCollectionTime) {
        var e_3, _a;
        try {
            for(var _b = __values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()){
                var _d = __read(_c.value, 2), key = _d[0], hash = _d[1];
                var currentAccumulation = current.get(key, hash);
                currentAccumulation === null || currentAccumulation === void 0 || currentAccumulation.setStartTime(lastCollectionTime);
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        return current;
    };
    return TemporalMetricProcessor;
}();
// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.
function AttributesMapToAccumulationRecords(map) {
    return Array.from(map.entries());
}

},{"../export/AggregationTemporality":"Gkq0r","./HashMap":"fbviK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bRhIn":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricStorageRegistry", ()=>MetricStorageRegistry);
var _instrumentDescriptor = require("../InstrumentDescriptor");
var _api = require("@opentelemetry/api");
var _registrationConflicts = require("../view/RegistrationConflicts");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * Internal class for storing {@link MetricStorage}
 */ var MetricStorageRegistry = /** @class */ function() {
    function MetricStorageRegistry() {
        this._sharedRegistry = new Map();
        this._perCollectorRegistry = new Map();
    }
    MetricStorageRegistry.create = function() {
        return new MetricStorageRegistry();
    };
    MetricStorageRegistry.prototype.getStorages = function(collector) {
        var e_1, _a, e_2, _b;
        var storages = [];
        try {
            for(var _c = __values(this._sharedRegistry.values()), _d = _c.next(); !_d.done; _d = _c.next()){
                var metricStorages = _d.value;
                storages = storages.concat(metricStorages);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        var perCollectorStorages = this._perCollectorRegistry.get(collector);
        if (perCollectorStorages != null) try {
            for(var _e = __values(perCollectorStorages.values()), _f = _e.next(); !_f.done; _f = _e.next()){
                var metricStorages = _f.value;
                storages = storages.concat(metricStorages);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
        return storages;
    };
    MetricStorageRegistry.prototype.register = function(storage) {
        this._registerStorage(storage, this._sharedRegistry);
    };
    MetricStorageRegistry.prototype.registerForCollector = function(collector, storage) {
        var storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap == null) {
            storageMap = new Map();
            this._perCollectorRegistry.set(collector, storageMap);
        }
        this._registerStorage(storage, storageMap);
    };
    MetricStorageRegistry.prototype.findOrUpdateCompatibleStorage = function(expectedDescriptor) {
        var storages = this._sharedRegistry.get(expectedDescriptor.name);
        if (storages === undefined) return null;
        // If the descriptor is compatible, the type of their metric storage
        // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.
        return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
    };
    MetricStorageRegistry.prototype.findOrUpdateCompatibleCollectorStorage = function(collector, expectedDescriptor) {
        var storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap === undefined) return null;
        var storages = storageMap.get(expectedDescriptor.name);
        if (storages === undefined) return null;
        // If the descriptor is compatible, the type of their metric storage
        // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.
        return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
    };
    MetricStorageRegistry.prototype._registerStorage = function(storage, storageMap) {
        var descriptor = storage.getInstrumentDescriptor();
        var storages = storageMap.get(descriptor.name);
        if (storages === undefined) {
            storageMap.set(descriptor.name, [
                storage
            ]);
            return;
        }
        storages.push(storage);
    };
    MetricStorageRegistry.prototype._findOrUpdateCompatibleStorage = function(expectedDescriptor, existingStorages) {
        var e_3, _a;
        var compatibleStorage = null;
        try {
            for(var existingStorages_1 = __values(existingStorages), existingStorages_1_1 = existingStorages_1.next(); !existingStorages_1_1.done; existingStorages_1_1 = existingStorages_1.next()){
                var existingStorage = existingStorages_1_1.value;
                var existingDescriptor = existingStorage.getInstrumentDescriptor();
                if ((0, _instrumentDescriptor.isDescriptorCompatibleWith)(existingDescriptor, expectedDescriptor)) {
                    // Use the longer description if it does not match.
                    if (existingDescriptor.description !== expectedDescriptor.description) {
                        if (expectedDescriptor.description.length > existingDescriptor.description.length) existingStorage.updateDescription(expectedDescriptor.description);
                        _api.diag.warn('A view or instrument with the name ', expectedDescriptor.name, ' has already been registered, but has a different description and is incompatible with another registered view.\n', 'Details:\n', (0, _registrationConflicts.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), 'The longer description will be used.\nTo resolve the conflict:', (0, _registrationConflicts.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
                    }
                    // Storage is fully compatible. There will never be more than one pre-existing fully compatible storage.
                    compatibleStorage = existingStorage;
                } else // The implementation SHOULD warn about duplicate instrument registration
                // conflicts after applying View configuration.
                _api.diag.warn('A view or instrument with the name ', expectedDescriptor.name, ' has already been registered and is incompatible with another registered view.\n', 'Details:\n', (0, _registrationConflicts.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), 'To resolve the conflict:\n', (0, _registrationConflicts.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (existingStorages_1_1 && !existingStorages_1_1.done && (_a = existingStorages_1.return)) _a.call(existingStorages_1);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        return compatibleStorage;
    };
    return MetricStorageRegistry;
}();

},{"../InstrumentDescriptor":"ibIoU","@opentelemetry/api":"6AC4z","../view/RegistrationConflicts":"bkJ9Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bkJ9Y":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getIncompatibilityDetails", ()=>getIncompatibilityDetails);
parcelHelpers.export(exports, "getValueTypeConflictResolutionRecipe", ()=>getValueTypeConflictResolutionRecipe);
parcelHelpers.export(exports, "getUnitConflictResolutionRecipe", ()=>getUnitConflictResolutionRecipe);
parcelHelpers.export(exports, "getTypeConflictResolutionRecipe", ()=>getTypeConflictResolutionRecipe);
parcelHelpers.export(exports, "getDescriptionResolutionRecipe", ()=>getDescriptionResolutionRecipe);
parcelHelpers.export(exports, "getConflictResolutionRecipe", ()=>getConflictResolutionRecipe);
function getIncompatibilityDetails(existing, otherDescriptor) {
    var incompatibility = '';
    if (existing.unit !== otherDescriptor.unit) incompatibility += "\t- Unit '" + existing.unit + "' does not match '" + otherDescriptor.unit + "'\n";
    if (existing.type !== otherDescriptor.type) incompatibility += "\t- Type '" + existing.type + "' does not match '" + otherDescriptor.type + "'\n";
    if (existing.valueType !== otherDescriptor.valueType) incompatibility += "\t- Value Type '" + existing.valueType + "' does not match '" + otherDescriptor.valueType + "'\n";
    if (existing.description !== otherDescriptor.description) incompatibility += "\t- Description '" + existing.description + "' does not match '" + otherDescriptor.description + "'\n";
    return incompatibility;
}
function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
    return "\t- use valueType '" + existing.valueType + "' on instrument creation or use an instrument name other than '" + otherDescriptor.name + "'";
}
function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
    return "\t- use unit '" + existing.unit + "' on instrument creation or use an instrument name other than '" + otherDescriptor.name + "'";
}
function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
    var selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
    };
    var selectorString = JSON.stringify(selector);
    return "\t- create a new view with a name other than '" + existing.name + "' and InstrumentSelector '" + selectorString + "'";
}
function getDescriptionResolutionRecipe(existing, otherDescriptor) {
    var selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
    };
    var selectorString = JSON.stringify(selector);
    return "\t- create a new view with a name other than '" + existing.name + "' and InstrumentSelector '" + selectorString + "'\n    \t- OR - create a new view with the name " + existing.name + " and description '" + existing.description + "' and InstrumentSelector " + selectorString + "\n    \t- OR - create a new view with the name " + otherDescriptor.name + " and description '" + existing.description + "' and InstrumentSelector " + selectorString;
}
function getConflictResolutionRecipe(existing, otherDescriptor) {
    // Conflicts that cannot be solved via views.
    if (existing.valueType !== otherDescriptor.valueType) return getValueTypeConflictResolutionRecipe(existing, otherDescriptor);
    if (existing.unit !== otherDescriptor.unit) return getUnitConflictResolutionRecipe(existing, otherDescriptor);
    // Conflicts that can be solved via views.
    if (existing.type !== otherDescriptor.type) // this will automatically solve possible description conflicts.
    return getTypeConflictResolutionRecipe(existing, otherDescriptor);
    if (existing.description !== otherDescriptor.description) return getDescriptionResolutionRecipe(existing, otherDescriptor);
    return '';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbysB":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Internal interface.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MultiMetricStorage", ()=>MultiMetricStorage);
var MultiMetricStorage = /** @class */ function() {
    function MultiMetricStorage(_backingStorages) {
        this._backingStorages = _backingStorages;
    }
    MultiMetricStorage.prototype.record = function(value, attributes, context, recordTime) {
        this._backingStorages.forEach(function(it) {
            it.record(value, attributes, context, recordTime);
        });
    };
    return MultiMetricStorage;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Hovj":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ObservableRegistry", ()=>ObservableRegistry);
var _api = require("@opentelemetry/api");
var _instruments = require("../Instruments");
var _observableResult = require("../ObservableResult");
var _utils = require("../utils");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * An internal interface for managing ObservableCallbacks.
 *
 * Every registered callback associated with a set of instruments are be evaluated
 * exactly once during collection prior to reading data for that instrument.
 */ var ObservableRegistry = /** @class */ function() {
    function ObservableRegistry() {
        this._callbacks = [];
        this._batchCallbacks = [];
    }
    ObservableRegistry.prototype.addCallback = function(callback, instrument) {
        var idx = this._findCallback(callback, instrument);
        if (idx >= 0) return;
        this._callbacks.push({
            callback: callback,
            instrument: instrument
        });
    };
    ObservableRegistry.prototype.removeCallback = function(callback, instrument) {
        var idx = this._findCallback(callback, instrument);
        if (idx < 0) return;
        this._callbacks.splice(idx, 1);
    };
    ObservableRegistry.prototype.addBatchCallback = function(callback, instruments) {
        // Create a set of unique instruments.
        var observableInstruments = new Set(instruments.filter((0, _instruments.isObservableInstrument)));
        if (observableInstruments.size === 0) {
            (0, _api.diag).error('BatchObservableCallback is not associated with valid instruments', instruments);
            return;
        }
        var idx = this._findBatchCallback(callback, observableInstruments);
        if (idx >= 0) return;
        this._batchCallbacks.push({
            callback: callback,
            instruments: observableInstruments
        });
    };
    ObservableRegistry.prototype.removeBatchCallback = function(callback, instruments) {
        // Create a set of unique instruments.
        var observableInstruments = new Set(instruments.filter((0, _instruments.isObservableInstrument)));
        var idx = this._findBatchCallback(callback, observableInstruments);
        if (idx < 0) return;
        this._batchCallbacks.splice(idx, 1);
    };
    /**
     * @returns a promise of rejected reasons for invoking callbacks.
     */ ObservableRegistry.prototype.observe = function(collectionTime, timeoutMillis) {
        return __awaiter(this, void 0, void 0, function() {
            var callbackFutures, batchCallbackFutures, results, rejections;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);
                        batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
                        return [
                            4 /*yield*/ ,
                            (0, _utils.PromiseAllSettled)(__spreadArray(__spreadArray([], __read(callbackFutures), false), __read(batchCallbackFutures), false))
                        ];
                    case 1:
                        results = _a.sent();
                        rejections = results.filter((0, _utils.isPromiseAllSettledRejectionResult)).map(function(it) {
                            return it.reason;
                        });
                        return [
                            2 /*return*/ ,
                            rejections
                        ];
                }
            });
        });
    };
    ObservableRegistry.prototype._observeCallbacks = function(observationTime, timeoutMillis) {
        var _this = this;
        return this._callbacks.map(function(_a) {
            var callback = _a.callback, instrument = _a.instrument;
            return __awaiter(_this, void 0, void 0, function() {
                var observableResult, callPromise;
                return __generator(this, function(_b) {
                    switch(_b.label){
                        case 0:
                            observableResult = new (0, _observableResult.ObservableResultImpl)(instrument._descriptor.name, instrument._descriptor.valueType);
                            callPromise = Promise.resolve(callback(observableResult));
                            if (timeoutMillis != null) callPromise = (0, _utils.callWithTimeout)(callPromise, timeoutMillis);
                            return [
                                4 /*yield*/ ,
                                callPromise
                            ];
                        case 1:
                            _b.sent();
                            instrument._metricStorages.forEach(function(metricStorage) {
                                metricStorage.record(observableResult._buffer, observationTime);
                            });
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        });
    };
    ObservableRegistry.prototype._observeBatchCallbacks = function(observationTime, timeoutMillis) {
        var _this = this;
        return this._batchCallbacks.map(function(_a) {
            var callback = _a.callback, instruments = _a.instruments;
            return __awaiter(_this, void 0, void 0, function() {
                var observableResult, callPromise;
                return __generator(this, function(_b) {
                    switch(_b.label){
                        case 0:
                            observableResult = new (0, _observableResult.BatchObservableResultImpl)();
                            callPromise = Promise.resolve(callback(observableResult));
                            if (timeoutMillis != null) callPromise = (0, _utils.callWithTimeout)(callPromise, timeoutMillis);
                            return [
                                4 /*yield*/ ,
                                callPromise
                            ];
                        case 1:
                            _b.sent();
                            instruments.forEach(function(instrument) {
                                var buffer = observableResult._buffer.get(instrument);
                                if (buffer == null) return;
                                instrument._metricStorages.forEach(function(metricStorage) {
                                    metricStorage.record(buffer, observationTime);
                                });
                            });
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        });
    };
    ObservableRegistry.prototype._findCallback = function(callback, instrument) {
        return this._callbacks.findIndex(function(record) {
            return record.callback === callback && record.instrument === instrument;
        });
    };
    ObservableRegistry.prototype._findBatchCallback = function(callback, instruments) {
        return this._batchCallbacks.findIndex(function(record) {
            return record.callback === callback && (0, _utils.setEquals)(record.instruments, instruments);
        });
    };
    return ObservableRegistry;
}();

},{"@opentelemetry/api":"6AC4z","../Instruments":"fAuRc","../ObservableResult":"3Vov8","../utils":"ai7q3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Vov8":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ObservableResultImpl", ()=>ObservableResultImpl);
parcelHelpers.export(exports, "BatchObservableResultImpl", ()=>BatchObservableResultImpl);
var _api = require("@opentelemetry/api");
var _hashMap = require("./state/HashMap");
var _instruments = require("./Instruments");
/**
 * The class implements {@link ObservableResult} interface.
 */ var ObservableResultImpl = /** @class */ function() {
    function ObservableResultImpl(_instrumentName, _valueType) {
        this._instrumentName = _instrumentName;
        this._valueType = _valueType;
        /**
         * @internal
         */ this._buffer = new (0, _hashMap.AttributeHashMap)();
    }
    /**
     * Observe a measurement of the value associated with the given attributes.
     */ ObservableResultImpl.prototype.observe = function(value, attributes) {
        if (attributes === void 0) attributes = {};
        if (typeof value !== 'number') {
            (0, _api.diag).warn("non-number value provided to metric " + this._instrumentName + ": " + value);
            return;
        }
        if (this._valueType === (0, _api.ValueType).INT && !Number.isInteger(value)) {
            (0, _api.diag).warn("INT value type cannot accept a floating-point value for " + this._instrumentName + ", ignoring the fractional digits.");
            value = Math.trunc(value);
            // ignore non-finite values.
            if (!Number.isInteger(value)) return;
        }
        this._buffer.set(attributes, value);
    };
    return ObservableResultImpl;
}();
/**
 * The class implements {@link BatchObservableCallback} interface.
 */ var BatchObservableResultImpl = /** @class */ function() {
    function BatchObservableResultImpl() {
        /**
         * @internal
         */ this._buffer = new Map();
    }
    /**
     * Observe a measurement of the value associated with the given attributes.
     */ BatchObservableResultImpl.prototype.observe = function(metric, value, attributes) {
        if (attributes === void 0) attributes = {};
        if (!(0, _instruments.isObservableInstrument)(metric)) return;
        var map = this._buffer.get(metric);
        if (map == null) {
            map = new (0, _hashMap.AttributeHashMap)();
            this._buffer.set(metric, map);
        }
        if (typeof value !== 'number') {
            (0, _api.diag).warn("non-number value provided to metric " + metric._descriptor.name + ": " + value);
            return;
        }
        if (metric._descriptor.valueType === (0, _api.ValueType).INT && !Number.isInteger(value)) {
            (0, _api.diag).warn("INT value type cannot accept a floating-point value for " + metric._descriptor.name + ", ignoring the fractional digits.");
            value = Math.trunc(value);
            // ignore non-finite values.
            if (!Number.isInteger(value)) return;
        }
        map.set(attributes, value);
    };
    return BatchObservableResultImpl;
}();

},{"@opentelemetry/api":"6AC4z","./state/HashMap":"fbviK","./Instruments":"fAuRc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2tXBR":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SyncMetricStorage", ()=>SyncMetricStorage);
var _metricStorage = require("./MetricStorage");
var _deltaMetricProcessor = require("./DeltaMetricProcessor");
var _temporalMetricProcessor = require("./TemporalMetricProcessor");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Internal interface.
 *
 * Stores and aggregates {@link MetricData} for synchronous instruments.
 */ var SyncMetricStorage = /** @class */ function(_super) {
    __extends(SyncMetricStorage, _super);
    function SyncMetricStorage(instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles, _aggregationCardinalityLimit) {
        var _this = _super.call(this, instrumentDescriptor) || this;
        _this._attributesProcessor = _attributesProcessor;
        _this._aggregationCardinalityLimit = _aggregationCardinalityLimit;
        _this._deltaMetricStorage = new (0, _deltaMetricProcessor.DeltaMetricProcessor)(aggregator, _this._aggregationCardinalityLimit);
        _this._temporalMetricStorage = new (0, _temporalMetricProcessor.TemporalMetricProcessor)(aggregator, collectorHandles);
        return _this;
    }
    SyncMetricStorage.prototype.record = function(value, attributes, context, recordTime) {
        attributes = this._attributesProcessor.process(attributes, context);
        this._deltaMetricStorage.record(value, attributes, context, recordTime);
    };
    /**
     * Collects the metrics from this storage.
     *
     * Note: This is a stateful operation and may reset any interval-related
     * state for the MetricCollector.
     */ SyncMetricStorage.prototype.collect = function(collector, collectionTime) {
        var accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
    };
    return SyncMetricStorage;
}((0, _metricStorage.MetricStorage));

},{"./MetricStorage":"4ecsG","./DeltaMetricProcessor":"12gyp","./TemporalMetricProcessor":"1uLc2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"87C0N":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AttributesProcessor", ()=>AttributesProcessor);
parcelHelpers.export(exports, "NoopAttributesProcessor", ()=>NoopAttributesProcessor);
parcelHelpers.export(exports, "FilteringAttributesProcessor", ()=>FilteringAttributesProcessor);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * The {@link AttributesProcessor} is responsible for customizing which
 * attribute(s) are to be reported as metrics dimension(s) and adding
 * additional dimension(s) from the {@link Context}.
 */ var AttributesProcessor = /** @class */ function() {
    function AttributesProcessor() {}
    AttributesProcessor.Noop = function() {
        return NOOP;
    };
    return AttributesProcessor;
}();
var NoopAttributesProcessor = /** @class */ function(_super) {
    __extends(NoopAttributesProcessor, _super);
    function NoopAttributesProcessor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopAttributesProcessor.prototype.process = function(incoming, _context) {
        return incoming;
    };
    return NoopAttributesProcessor;
}(AttributesProcessor);
/**
 * {@link AttributesProcessor} that filters by allowed attribute names and drops any names that are not in the
 * allow list.
 */ var FilteringAttributesProcessor = /** @class */ function(_super) {
    __extends(FilteringAttributesProcessor, _super);
    function FilteringAttributesProcessor(_allowedAttributeNames) {
        var _this = _super.call(this) || this;
        _this._allowedAttributeNames = _allowedAttributeNames;
        return _this;
    }
    FilteringAttributesProcessor.prototype.process = function(incoming, _context) {
        var _this = this;
        var filteredAttributes = {};
        Object.keys(incoming).filter(function(attributeName) {
            return _this._allowedAttributeNames.includes(attributeName);
        }).forEach(function(attributeName) {
            return filteredAttributes[attributeName] = incoming[attributeName];
        });
        return filteredAttributes;
    };
    return FilteringAttributesProcessor;
}(AttributesProcessor);
var NOOP = new NoopAttributesProcessor();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jJEUh":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricCollector", ()=>MetricCollector);
var _core = require("@opentelemetry/core");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * An internal opaque interface that the MetricReader receives as
 * MetricProducer. It acts as the storage key to the internal metric stream
 * state for each MetricReader.
 */ var MetricCollector = /** @class */ function() {
    function MetricCollector(_sharedState, _metricReader) {
        this._sharedState = _sharedState;
        this._metricReader = _metricReader;
    }
    MetricCollector.prototype.collect = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            var collectionTime, scopeMetrics, errors, meterCollectionPromises;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        collectionTime = (0, _core.millisToHrTime)(Date.now());
                        scopeMetrics = [];
                        errors = [];
                        meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values()).map(function(meterSharedState) {
                            return __awaiter(_this, void 0, void 0, function() {
                                var current;
                                return __generator(this, function(_a) {
                                    switch(_a.label){
                                        case 0:
                                            return [
                                                4 /*yield*/ ,
                                                meterSharedState.collect(this, collectionTime, options)
                                            ];
                                        case 1:
                                            current = _a.sent();
                                            // only add scope metrics if available
                                            if ((current === null || current === void 0 ? void 0 : current.scopeMetrics) != null) scopeMetrics.push(current.scopeMetrics);
                                            // only add errors if available
                                            if ((current === null || current === void 0 ? void 0 : current.errors) != null) errors.push.apply(errors, __spreadArray([], __read(current.errors), false));
                                            return [
                                                2 /*return*/ 
                                            ];
                                    }
                                });
                            });
                        });
                        return [
                            4 /*yield*/ ,
                            Promise.all(meterCollectionPromises)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            {
                                resourceMetrics: {
                                    resource: this._sharedState.resource,
                                    scopeMetrics: scopeMetrics
                                },
                                errors: errors
                            }
                        ];
                }
            });
        });
    };
    /**
     * Delegates for MetricReader.forceFlush.
     */ MetricCollector.prototype.forceFlush = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this._metricReader.forceFlush(options)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Delegates for MetricReader.shutdown.
     */ MetricCollector.prototype.shutdown = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this._metricReader.shutdown(options)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    MetricCollector.prototype.selectAggregationTemporality = function(instrumentType) {
        return this._metricReader.selectAggregationTemporality(instrumentType);
    };
    MetricCollector.prototype.selectAggregation = function(instrumentType) {
        return this._metricReader.selectAggregation(instrumentType);
    };
    /**
     * Select the cardinality limit for the given {@link InstrumentType} for this
     * collector.
     */ MetricCollector.prototype.selectCardinalityLimit = function(instrumentType) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this._metricReader).selectCardinalityLimit) === null || _b === void 0 ? void 0 : _b.call(_a, instrumentType)) !== null && _c !== void 0 ? _c : 2000;
    };
    return MetricCollector;
}();

},{"@opentelemetry/core":"5eoQV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jYPe9":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XMLHttpRequestInstrumentation", ()=>(0, _xhr.XMLHttpRequestInstrumentation));
var _xhr = require("./xhr");

},{"./xhr":"3C1i1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3C1i1":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XMLHttpRequestInstrumentation", ()=>XMLHttpRequestInstrumentation);
var _api = require("@opentelemetry/api");
var _instrumentation = require("@opentelemetry/instrumentation");
var _core = require("@opentelemetry/core");
var _semanticConventions = require("@opentelemetry/semantic-conventions");
var _sdkTraceWeb = require("@opentelemetry/sdk-trace-web");
var _eventNames = require("./enums/EventNames");
var _utils = require("./utils");
var _version = require("./version");
var _attributeNames = require("./enums/AttributeNames");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
// how long to wait for observer to collect information about resources
// this is needed as event "load" is called before observer
// hard to say how long it should really wait, seems like 300ms is
// safe enough
var OBSERVER_WAIT_TIME_MS = 300;
/**
 * This class represents a XMLHttpRequest plugin for auto instrumentation
 */ var XMLHttpRequestInstrumentation = /** @class */ function(_super) {
    __extends(XMLHttpRequestInstrumentation, _super);
    function XMLHttpRequestInstrumentation(config) {
        if (config === void 0) config = {};
        var _this = _super.call(this, '@opentelemetry/instrumentation-xml-http-request', (0, _version.VERSION), config) || this;
        _this.component = 'xml-http-request';
        _this.version = (0, _version.VERSION);
        _this.moduleName = _this.component;
        _this._tasksCount = 0;
        _this._xhrMem = new WeakMap();
        _this._usedResources = new WeakSet();
        return _this;
    }
    XMLHttpRequestInstrumentation.prototype.init = function() {};
    /**
     * Adds custom headers to XMLHttpRequest
     * @param xhr
     * @param spanUrl
     * @private
     */ XMLHttpRequestInstrumentation.prototype._addHeaders = function(xhr, spanUrl) {
        var url = (0, _sdkTraceWeb.parseUrl)(spanUrl).href;
        if (!(0, _sdkTraceWeb.shouldPropagateTraceHeaders)(url, this.getConfig().propagateTraceHeaderCorsUrls)) {
            var headers_1 = {};
            _api.propagation.inject(_api.context.active(), headers_1);
            if (Object.keys(headers_1).length > 0) this._diag.debug('headers inject skipped due to CORS policy');
            return;
        }
        var headers = {};
        _api.propagation.inject(_api.context.active(), headers);
        Object.keys(headers).forEach(function(key) {
            xhr.setRequestHeader(key, String(headers[key]));
        });
    };
    /**
     * Add cors pre flight child span
     * @param span
     * @param corsPreFlightRequest
     * @private
     */ XMLHttpRequestInstrumentation.prototype._addChildSpan = function(span, corsPreFlightRequest) {
        var _this = this;
        _api.context.with(_api.trace.setSpan(_api.context.active(), span), function() {
            var childSpan = _this.tracer.startSpan('CORS Preflight', {
                startTime: corsPreFlightRequest[(0, _sdkTraceWeb.PerformanceTimingNames).FETCH_START]
            });
            if (!_this.getConfig().ignoreNetworkEvents) (0, _sdkTraceWeb.addSpanNetworkEvents)(childSpan, corsPreFlightRequest);
            childSpan.end(corsPreFlightRequest[(0, _sdkTraceWeb.PerformanceTimingNames).RESPONSE_END]);
        });
    };
    /**
     * Add attributes when span is going to end
     * @param span
     * @param xhr
     * @param spanUrl
     * @private
     */ XMLHttpRequestInstrumentation.prototype._addFinalSpanAttributes = function(span, xhrMem, spanUrl) {
        if (typeof spanUrl === 'string') {
            var parsedUrl = (0, _sdkTraceWeb.parseUrl)(spanUrl);
            if (xhrMem.status !== undefined) span.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_STATUS_CODE), xhrMem.status);
            if (xhrMem.statusText !== undefined) span.setAttribute((0, _attributeNames.AttributeNames).HTTP_STATUS_TEXT, xhrMem.statusText);
            span.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_HOST), parsedUrl.host);
            span.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_SCHEME), parsedUrl.protocol.replace(':', ''));
            // @TODO do we want to collect this or it will be collected earlier once only or
            //    maybe when parent span is not available ?
            span.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_USER_AGENT), navigator.userAgent);
        }
    };
    XMLHttpRequestInstrumentation.prototype._applyAttributesAfterXHR = function(span, xhr) {
        var _this = this;
        var applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
        if (typeof applyCustomAttributesOnSpan === 'function') (0, _instrumentation.safeExecuteInTheMiddle)(function() {
            return applyCustomAttributesOnSpan(span, xhr);
        }, function(error) {
            if (!error) return;
            _this._diag.error('applyCustomAttributesOnSpan', error);
        }, true);
    };
    /**
     * will collect information about all resources created
     * between "send" and "end" with additional waiting for main resource
     * @param xhr
     * @param spanUrl
     * @private
     */ XMLHttpRequestInstrumentation.prototype._addResourceObserver = function(xhr, spanUrl) {
        var xhrMem = this._xhrMem.get(xhr);
        if (!xhrMem || typeof PerformanceObserver !== 'function' || typeof PerformanceResourceTiming !== 'function') return;
        xhrMem.createdResources = {
            observer: new PerformanceObserver(function(list) {
                var entries = list.getEntries();
                var parsedUrl = (0, _sdkTraceWeb.parseUrl)(spanUrl);
                entries.forEach(function(entry) {
                    if (entry.initiatorType === 'xmlhttprequest' && entry.name === parsedUrl.href) {
                        if (xhrMem.createdResources) xhrMem.createdResources.entries.push(entry);
                    }
                });
            }),
            entries: []
        };
        xhrMem.createdResources.observer.observe({
            entryTypes: [
                'resource'
            ]
        });
    };
    /**
     * Clears the resource timings and all resources assigned with spans
     *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is
     *     set to true (default false)
     * @private
     */ XMLHttpRequestInstrumentation.prototype._clearResources = function() {
        if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
            (0, _core.otperformance).clearResourceTimings();
            this._xhrMem = new WeakMap();
            this._usedResources = new WeakSet();
        }
    };
    /**
     * Finds appropriate resource and add network events to the span
     * @param span
     */ XMLHttpRequestInstrumentation.prototype._findResourceAndAddNetworkEvents = function(xhrMem, span, spanUrl, startTime, endTime) {
        if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) return;
        var resources = xhrMem.createdResources.entries;
        if (!resources || !resources.length) // fallback - either Observer is not available or it took longer
        // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough
        // information
        // ts thinks this is the perf_hooks module, but it is the browser performance api
        resources = (0, _core.otperformance).getEntriesByType('resource');
        var resource = (0, _sdkTraceWeb.getResource)((0, _sdkTraceWeb.parseUrl)(spanUrl).href, startTime, endTime, resources, this._usedResources);
        if (resource.mainRequest) {
            var mainRequest = resource.mainRequest;
            this._markResourceAsUsed(mainRequest);
            var corsPreFlightRequest = resource.corsPreFlightRequest;
            if (corsPreFlightRequest) {
                this._addChildSpan(span, corsPreFlightRequest);
                this._markResourceAsUsed(corsPreFlightRequest);
            }
            if (!this.getConfig().ignoreNetworkEvents) (0, _sdkTraceWeb.addSpanNetworkEvents)(span, mainRequest);
        }
    };
    /**
     * Removes the previous information about span.
     * This might happened when the same xhr is used again.
     * @param xhr
     * @private
     */ XMLHttpRequestInstrumentation.prototype._cleanPreviousSpanInformation = function(xhr) {
        var xhrMem = this._xhrMem.get(xhr);
        if (xhrMem) {
            var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
            if (callbackToRemoveEvents) callbackToRemoveEvents();
            this._xhrMem.delete(xhr);
        }
    };
    /**
     * Creates a new span when method "open" is called
     * @param xhr
     * @param url
     * @param method
     * @private
     */ XMLHttpRequestInstrumentation.prototype._createSpan = function(xhr, url, method) {
        var _a;
        if ((0, _core.isUrlIgnored)(url, this.getConfig().ignoreUrls)) {
            this._diag.debug('ignoring span as url matches ignored url');
            return;
        }
        var spanName = method.toUpperCase();
        var currentSpan = this.tracer.startSpan(spanName, {
            kind: _api.SpanKind.CLIENT,
            attributes: (_a = {}, _a[0, _semanticConventions.SEMATTRS_HTTP_METHOD] = method, _a[0, _semanticConventions.SEMATTRS_HTTP_URL] = (0, _sdkTraceWeb.parseUrl)(url).toString(), _a)
        });
        currentSpan.addEvent((0, _eventNames.EventNames).METHOD_OPEN);
        this._cleanPreviousSpanInformation(xhr);
        this._xhrMem.set(xhr, {
            span: currentSpan,
            spanUrl: url
        });
        return currentSpan;
    };
    /**
     * Marks certain [resource]{@link PerformanceResourceTiming} when information
     * from this is used to add events to span.
     * This is done to avoid reusing the same resource again for next span
     * @param resource
     * @private
     */ XMLHttpRequestInstrumentation.prototype._markResourceAsUsed = function(resource) {
        this._usedResources.add(resource);
    };
    /**
     * Patches the method open
     * @private
     */ XMLHttpRequestInstrumentation.prototype._patchOpen = function() {
        var _this = this;
        return function(original) {
            var plugin = _this;
            return function patchOpen() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                var method = args[0];
                var url = args[1];
                plugin._createSpan(this, url, method);
                return original.apply(this, args);
            };
        };
    };
    /**
     * Patches the method send
     * @private
     */ XMLHttpRequestInstrumentation.prototype._patchSend = function() {
        var plugin = this;
        function endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime) {
            var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
            if (typeof callbackToRemoveEvents === 'function') callbackToRemoveEvents();
            var span = xhrMem.span, spanUrl = xhrMem.spanUrl, sendStartTime = xhrMem.sendStartTime;
            if (span) {
                plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, performanceEndTime);
                span.addEvent(eventName, endTime);
                plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);
                span.end(endTime);
                plugin._tasksCount--;
            }
            plugin._clearResources();
        }
        function endSpan(eventName, xhr) {
            var xhrMem = plugin._xhrMem.get(xhr);
            if (!xhrMem) return;
            xhrMem.status = xhr.status;
            xhrMem.statusText = xhr.statusText;
            plugin._xhrMem.delete(xhr);
            if (xhrMem.span) plugin._applyAttributesAfterXHR(xhrMem.span, xhr);
            var performanceEndTime = (0, _core.hrTime)();
            var endTime = Date.now();
            // the timeout is needed as observer doesn't have yet information
            // when event "load" is called. Also the time may differ depends on
            // browser and speed of computer
            setTimeout(function() {
                endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);
            }, OBSERVER_WAIT_TIME_MS);
        }
        function onError() {
            endSpan((0, _eventNames.EventNames).EVENT_ERROR, this);
        }
        function onAbort() {
            endSpan((0, _eventNames.EventNames).EVENT_ABORT, this);
        }
        function onTimeout() {
            endSpan((0, _eventNames.EventNames).EVENT_TIMEOUT, this);
        }
        function onLoad() {
            if (this.status < 299) endSpan((0, _eventNames.EventNames).EVENT_LOAD, this);
            else endSpan((0, _eventNames.EventNames).EVENT_ERROR, this);
        }
        function unregister(xhr) {
            xhr.removeEventListener('abort', onAbort);
            xhr.removeEventListener('error', onError);
            xhr.removeEventListener('load', onLoad);
            xhr.removeEventListener('timeout', onTimeout);
            var xhrMem = plugin._xhrMem.get(xhr);
            if (xhrMem) xhrMem.callbackToRemoveEvents = undefined;
        }
        return function(original) {
            return function patchSend() {
                var _this = this;
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                var xhrMem = plugin._xhrMem.get(this);
                if (!xhrMem) return original.apply(this, args);
                var currentSpan = xhrMem.span;
                var spanUrl = xhrMem.spanUrl;
                if (currentSpan && spanUrl) {
                    if (plugin.getConfig().measureRequestSize && (args === null || args === void 0 ? void 0 : args[0])) {
                        var body = args[0];
                        var bodyLength = (0, _utils.getXHRBodyLength)(body);
                        if (bodyLength !== undefined) currentSpan.setAttribute((0, _semanticConventions.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED), bodyLength);
                    }
                    _api.context.with(_api.trace.setSpan(_api.context.active(), currentSpan), function() {
                        plugin._tasksCount++;
                        xhrMem.sendStartTime = (0, _core.hrTime)();
                        currentSpan.addEvent((0, _eventNames.EventNames).METHOD_SEND);
                        _this.addEventListener('abort', onAbort);
                        _this.addEventListener('error', onError);
                        _this.addEventListener('load', onLoad);
                        _this.addEventListener('timeout', onTimeout);
                        xhrMem.callbackToRemoveEvents = function() {
                            unregister(_this);
                            if (xhrMem.createdResources) xhrMem.createdResources.observer.disconnect();
                        };
                        plugin._addHeaders(_this, spanUrl);
                        plugin._addResourceObserver(_this, spanUrl);
                    });
                }
                return original.apply(this, args);
            };
        };
    };
    /**
     * implements enable function
     */ XMLHttpRequestInstrumentation.prototype.enable = function() {
        this._diag.debug('applying patch to', this.moduleName, this.version);
        if ((0, _instrumentation.isWrapped)(XMLHttpRequest.prototype.open)) {
            this._unwrap(XMLHttpRequest.prototype, 'open');
            this._diag.debug('removing previous patch from method open');
        }
        if ((0, _instrumentation.isWrapped)(XMLHttpRequest.prototype.send)) {
            this._unwrap(XMLHttpRequest.prototype, 'send');
            this._diag.debug('removing previous patch from method send');
        }
        this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());
        this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());
    };
    /**
     * implements disable function
     */ XMLHttpRequestInstrumentation.prototype.disable = function() {
        this._diag.debug('removing patch from', this.moduleName, this.version);
        this._unwrap(XMLHttpRequest.prototype, 'open');
        this._unwrap(XMLHttpRequest.prototype, 'send');
        this._tasksCount = 0;
        this._xhrMem = new WeakMap();
        this._usedResources = new WeakSet();
    };
    return XMLHttpRequestInstrumentation;
}((0, _instrumentation.InstrumentationBase));

},{"@opentelemetry/api":"6AC4z","@opentelemetry/instrumentation":"hJDCH","@opentelemetry/core":"kxLey","@opentelemetry/semantic-conventions":"lCgfj","@opentelemetry/sdk-trace-web":"eXZZL","./enums/EventNames":"2ideG","./utils":"bVVLF","./version":"ce7eg","./enums/AttributeNames":"eLfrd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hJDCH":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerInstrumentations", ()=>(0, _autoLoader.registerInstrumentations));
parcelHelpers.export(exports, "InstrumentationBase", ()=>(0, _index.InstrumentationBase));
parcelHelpers.export(exports, "InstrumentationNodeModuleDefinition", ()=>(0, _instrumentationNodeModuleDefinition.InstrumentationNodeModuleDefinition));
parcelHelpers.export(exports, "InstrumentationNodeModuleFile", ()=>(0, _instrumentationNodeModuleFile.InstrumentationNodeModuleFile));
parcelHelpers.export(exports, "isWrapped", ()=>(0, _utils.isWrapped));
parcelHelpers.export(exports, "safeExecuteInTheMiddle", ()=>(0, _utils.safeExecuteInTheMiddle));
parcelHelpers.export(exports, "safeExecuteInTheMiddleAsync", ()=>(0, _utils.safeExecuteInTheMiddleAsync));
var _autoLoader = require("./autoLoader");
var _index = require("./platform/index");
var _instrumentationNodeModuleDefinition = require("./instrumentationNodeModuleDefinition");
var _instrumentationNodeModuleFile = require("./instrumentationNodeModuleFile");
var _utils = require("./utils");

},{"./autoLoader":false,"./platform/index":"8229B","./instrumentationNodeModuleDefinition":false,"./instrumentationNodeModuleFile":false,"./utils":"f2nhK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8229B":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationBase", ()=>(0, _instrumentation.InstrumentationBase));
parcelHelpers.export(exports, "normalize", ()=>(0, _noopNormalize.normalize));
var _instrumentation = require("./instrumentation");
var _noopNormalize = require("./noop-normalize");

},{"./instrumentation":"czOzA","./noop-normalize":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"czOzA":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationBase", ()=>InstrumentationBase);
var _instrumentation = require("../../instrumentation");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Base abstract class for instrumenting web plugins
 */ var InstrumentationBase = /** @class */ function(_super) {
    __extends(InstrumentationBase, _super);
    function InstrumentationBase(instrumentationName, instrumentationVersion, config) {
        var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
        if (_this._config.enabled) _this.enable();
        return _this;
    }
    return InstrumentationBase;
}((0, _instrumentation.InstrumentationAbstract));

},{"../../instrumentation":"kIVhr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kIVhr":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationAbstract", ()=>InstrumentationAbstract);
var _api = require("@opentelemetry/api");
var _apiLogs = require("@opentelemetry/api-logs");
var _shimmer = require("shimmer");
var __assign = undefined && undefined.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * Base abstract internal class for instrumenting node and web plugins
 */ var InstrumentationAbstract = /** @class */ function() {
    function InstrumentationAbstract(instrumentationName, instrumentationVersion, config) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        this._config = {};
        /* Api to wrap instrumented method */ this._wrap = _shimmer.wrap;
        /* Api to unwrap instrumented methods */ this._unwrap = _shimmer.unwrap;
        /* Api to mass wrap instrumented method */ this._massWrap = _shimmer.massWrap;
        /* Api to mass unwrap instrumented methods */ this._massUnwrap = _shimmer.massUnwrap;
        this.setConfig(config);
        this._diag = (0, _api.diag).createComponentLogger({
            namespace: instrumentationName
        });
        this._tracer = (0, _api.trace).getTracer(instrumentationName, instrumentationVersion);
        this._meter = (0, _api.metrics).getMeter(instrumentationName, instrumentationVersion);
        this._logger = (0, _apiLogs.logs).getLogger(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
    }
    Object.defineProperty(InstrumentationAbstract.prototype, "meter", {
        /* Returns meter */ get: function() {
            return this._meter;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets MeterProvider to this plugin
     * @param meterProvider
     */ InstrumentationAbstract.prototype.setMeterProvider = function(meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
    };
    Object.defineProperty(InstrumentationAbstract.prototype, "logger", {
        /* Returns logger */ get: function() {
            return this._logger;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets LoggerProvider to this plugin
     * @param loggerProvider
     */ InstrumentationAbstract.prototype.setLoggerProvider = function(loggerProvider) {
        this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    };
    /**
     * @experimental
     *
     * Get module definitions defined by {@link init}.
     * This can be used for experimental compile-time instrumentation.
     *
     * @returns an array of {@link InstrumentationModuleDefinition}
     */ InstrumentationAbstract.prototype.getModuleDefinitions = function() {
        var _a;
        var initResult = (_a = this.init()) !== null && _a !== void 0 ? _a : [];
        if (!Array.isArray(initResult)) return [
            initResult
        ];
        return initResult;
    };
    /**
     * Sets the new metric instruments with the current Meter.
     */ InstrumentationAbstract.prototype._updateMetricInstruments = function() {
        return;
    };
    /* Returns InstrumentationConfig */ InstrumentationAbstract.prototype.getConfig = function() {
        return this._config;
    };
    /**
     * Sets InstrumentationConfig to this plugin
     * @param config
     */ InstrumentationAbstract.prototype.setConfig = function(config) {
        // copy config first level properties to ensure they are immutable.
        // nested properties are not copied, thus are mutable from the outside.
        this._config = __assign({
            enabled: true
        }, config);
    };
    /**
     * Sets TraceProvider to this plugin
     * @param tracerProvider
     */ InstrumentationAbstract.prototype.setTracerProvider = function(tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    };
    Object.defineProperty(InstrumentationAbstract.prototype, "tracer", {
        /* Returns tracer */ get: function() {
            return this._tracer;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Execute span customization hook, if configured, and log any errors.
     * Any semantics of the trigger and info are defined by the specific instrumentation.
     * @param hookHandler The optional hook handler which the user has configured via instrumentation config
     * @param triggerName The name of the trigger for executing the hook for logging purposes
     * @param span The span to which the hook should be applied
     * @param info The info object to be passed to the hook, with useful data the hook may use
     */ InstrumentationAbstract.prototype._runSpanCustomizationHook = function(hookHandler, triggerName, span, info) {
        if (!hookHandler) return;
        try {
            hookHandler(span, info);
        } catch (e) {
            this._diag.error("Error running span customization hook due to exception in handler", {
                triggerName: triggerName
            }, e);
        }
    };
    return InstrumentationAbstract;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/api-logs":"87P2Y","shimmer":"kGpxk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"87P2Y":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SeverityNumber", ()=>(0, _logRecord.SeverityNumber));
parcelHelpers.export(exports, "NOOP_LOGGER", ()=>(0, _noopLogger.NOOP_LOGGER));
parcelHelpers.export(exports, "NoopLogger", ()=>(0, _noopLogger.NoopLogger));
parcelHelpers.export(exports, "NOOP_LOGGER_PROVIDER", ()=>(0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER));
parcelHelpers.export(exports, "NoopLoggerProvider", ()=>(0, _noopLoggerProvider.NoopLoggerProvider));
parcelHelpers.export(exports, "ProxyLogger", ()=>(0, _proxyLogger.ProxyLogger));
parcelHelpers.export(exports, "ProxyLoggerProvider", ()=>(0, _proxyLoggerProvider.ProxyLoggerProvider));
parcelHelpers.export(exports, "logs", ()=>logs);
var _logRecord = require("./types/LogRecord");
var _noopLogger = require("./NoopLogger");
var _noopLoggerProvider = require("./NoopLoggerProvider");
var _proxyLogger = require("./ProxyLogger");
var _proxyLoggerProvider = require("./ProxyLoggerProvider");
var _logs = require("./api/logs");
var logs = (0, _logs.LogsAPI).getInstance();

},{"./types/LogRecord":false,"./NoopLogger":false,"./NoopLoggerProvider":false,"./ProxyLogger":false,"./ProxyLoggerProvider":false,"./api/logs":"fqrBu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lQrnw":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopLogger", ()=>NoopLogger);
parcelHelpers.export(exports, "NOOP_LOGGER", ()=>NOOP_LOGGER);
var NoopLogger = /** @class */ function() {
    function NoopLogger() {}
    NoopLogger.prototype.emit = function(_logRecord) {};
    return NoopLogger;
}();
var NOOP_LOGGER = new NoopLogger();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gplIY":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopLoggerProvider", ()=>NoopLoggerProvider);
parcelHelpers.export(exports, "NOOP_LOGGER_PROVIDER", ()=>NOOP_LOGGER_PROVIDER);
var _noopLogger = require("./NoopLogger");
var NoopLoggerProvider = /** @class */ function() {
    function NoopLoggerProvider() {}
    NoopLoggerProvider.prototype.getLogger = function(_name, _version, _options) {
        return new (0, _noopLogger.NoopLogger)();
    };
    return NoopLoggerProvider;
}();
var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

},{"./NoopLogger":"lQrnw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bYD3F":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProxyLogger", ()=>ProxyLogger);
var _noopLogger = require("./NoopLogger");
var ProxyLogger = /** @class */ function() {
    function ProxyLogger(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    /**
     * Emit a log record. This method should only be used by log appenders.
     *
     * @param logRecord
     */ ProxyLogger.prototype.emit = function(logRecord) {
        this._getLogger().emit(logRecord);
    };
    /**
     * Try to get a logger from the proxy logger provider.
     * If the proxy logger provider has no delegate, return a noop logger.
     */ ProxyLogger.prototype._getLogger = function() {
        if (this._delegate) return this._delegate;
        var logger = this._provider.getDelegateLogger(this.name, this.version, this.options);
        if (!logger) return 0, _noopLogger.NOOP_LOGGER;
        this._delegate = logger;
        return this._delegate;
    };
    return ProxyLogger;
}();

},{"./NoopLogger":"lQrnw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7h1Ky":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProxyLoggerProvider", ()=>ProxyLoggerProvider);
var _noopLoggerProvider = require("./NoopLoggerProvider");
var _proxyLogger = require("./ProxyLogger");
var ProxyLoggerProvider = /** @class */ function() {
    function ProxyLoggerProvider() {}
    ProxyLoggerProvider.prototype.getLogger = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new (0, _proxyLogger.ProxyLogger)(this, name, version, options);
    };
    ProxyLoggerProvider.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : (0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER);
    };
    /**
     * Set the delegate logger provider
     */ ProxyLoggerProvider.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyLoggerProvider.prototype.getDelegateLogger = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
    };
    return ProxyLoggerProvider;
}();

},{"./NoopLoggerProvider":"gplIY","./ProxyLogger":"bYD3F","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fqrBu":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LogsAPI", ()=>LogsAPI);
var _globalUtils = require("../internal/global-utils");
var _noopLoggerProvider = require("../NoopLoggerProvider");
var _proxyLoggerProvider = require("../ProxyLoggerProvider");
var LogsAPI = /** @class */ function() {
    function LogsAPI() {
        this._proxyLoggerProvider = new (0, _proxyLoggerProvider.ProxyLoggerProvider)();
    }
    LogsAPI.getInstance = function() {
        if (!this._instance) this._instance = new LogsAPI();
        return this._instance;
    };
    LogsAPI.prototype.setGlobalLoggerProvider = function(provider) {
        if ((0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY]) return this.getLoggerProvider();
        (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY] = (0, _globalUtils.makeGetter)((0, _globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION), provider, (0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER));
        this._proxyLoggerProvider.setDelegate(provider);
        return provider;
    };
    /**
     * Returns the global logger provider.
     *
     * @returns LoggerProvider
     */ LogsAPI.prototype.getLoggerProvider = function() {
        var _a, _b;
        return (_b = (_a = (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call((0, _globalUtils._global), (0, _globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION))) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
    };
    /**
     * Returns a logger from the global logger provider.
     *
     * @returns Logger
     */ LogsAPI.prototype.getLogger = function(name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
    };
    /** Remove the global logger provider */ LogsAPI.prototype.disable = function() {
        delete (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY];
        this._proxyLoggerProvider = new (0, _proxyLoggerProvider.ProxyLoggerProvider)();
    };
    return LogsAPI;
}();

},{"../internal/global-utils":"1DZTv","../NoopLoggerProvider":"gplIY","../ProxyLoggerProvider":"7h1Ky","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1DZTv":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GLOBAL_LOGS_API_KEY", ()=>GLOBAL_LOGS_API_KEY);
parcelHelpers.export(exports, "_global", ()=>_global);
/**
 * Make a function which accepts a version integer and returns the instance of an API if the version
 * is compatible, or a fallback version (usually NOOP) if it is not.
 *
 * @param requiredVersion Backwards compatibility version which is required to return the instance
 * @param instance Instance which should be returned if the required version is compatible
 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
 */ parcelHelpers.export(exports, "makeGetter", ()=>makeGetter);
parcelHelpers.export(exports, "API_BACKWARDS_COMPATIBILITY_VERSION", ()=>API_BACKWARDS_COMPATIBILITY_VERSION);
var _platform = require("../platform");
var GLOBAL_LOGS_API_KEY = Symbol.for('io.opentelemetry.js.api.logs');
var _global = (0, _platform._globalThis);
function makeGetter(requiredVersion, instance, fallback) {
    return function(version) {
        return version === requiredVersion ? instance : fallback;
    };
}
var API_BACKWARDS_COMPATIBILITY_VERSION = 1;

},{"../platform":"bSbFF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSbFF":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>(0, _globalThis._globalThis));
var _globalThis = require("./globalThis");

},{"./globalThis":"d1k7v","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d1k7v":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */ /** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>_globalThis);
var global = arguments[3];
var _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f2nhK":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * function to execute patched function and being able to catch errors
 * @param execute - function to be executed
 * @param onFinish - callback to run when execute finishes
 */ parcelHelpers.export(exports, "safeExecuteInTheMiddle", ()=>safeExecuteInTheMiddle);
/**
 * Async function to execute patched function and being able to catch errors
 * @param execute - function to be executed
 * @param onFinish - callback to run when execute finishes
 */ parcelHelpers.export(exports, "safeExecuteInTheMiddleAsync", ()=>safeExecuteInTheMiddleAsync);
/**
 * Checks if certain function has been already wrapped
 * @param func
 */ parcelHelpers.export(exports, "isWrapped", ()=>isWrapped);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    var error;
    var result;
    try {
        result = execute();
    } catch (e) {
        error = e;
    } finally{
        onFinish(error, result);
        if (error && !preventThrowingError) // eslint-disable-next-line no-unsafe-finally
        throw error;
        // eslint-disable-next-line no-unsafe-finally
        return result;
    }
}
function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    return __awaiter(this, void 0, void 0, function() {
        var error, result, e_1;
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    _a.trys.push([
                        0,
                        2,
                        3,
                        4
                    ]);
                    return [
                        4 /*yield*/ ,
                        execute()
                    ];
                case 1:
                    result = _a.sent();
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 2:
                    e_1 = _a.sent();
                    error = e_1;
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 3:
                    onFinish(error, result);
                    if (error && !preventThrowingError) // eslint-disable-next-line no-unsafe-finally
                    throw error;
                    // eslint-disable-next-line no-unsafe-finally
                    return [
                        2 /*return*/ ,
                        result
                    ];
                case 4:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
function isWrapped(func) {
    return typeof func === 'function' && typeof func.__original === 'function' && typeof func.__unwrap === 'function' && func.__wrapped === true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kxLey":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "W3CBaggagePropagator", ()=>(0, _w3CbaggagePropagator.W3CBaggagePropagator));
parcelHelpers.export(exports, "AnchoredClock", ()=>(0, _anchoredClock.AnchoredClock));
parcelHelpers.export(exports, "isAttributeKey", ()=>(0, _attributes.isAttributeKey));
parcelHelpers.export(exports, "isAttributeValue", ()=>(0, _attributes.isAttributeValue));
parcelHelpers.export(exports, "sanitizeAttributes", ()=>(0, _attributes.sanitizeAttributes));
parcelHelpers.export(exports, "globalErrorHandler", ()=>(0, _globalErrorHandler.globalErrorHandler));
parcelHelpers.export(exports, "setGlobalErrorHandler", ()=>(0, _globalErrorHandler.setGlobalErrorHandler));
parcelHelpers.export(exports, "loggingErrorHandler", ()=>(0, _loggingErrorHandler.loggingErrorHandler));
parcelHelpers.export(exports, "addHrTimes", ()=>(0, _time.addHrTimes));
parcelHelpers.export(exports, "getTimeOrigin", ()=>(0, _time.getTimeOrigin));
parcelHelpers.export(exports, "hrTime", ()=>(0, _time.hrTime));
parcelHelpers.export(exports, "hrTimeDuration", ()=>(0, _time.hrTimeDuration));
parcelHelpers.export(exports, "hrTimeToMicroseconds", ()=>(0, _time.hrTimeToMicroseconds));
parcelHelpers.export(exports, "hrTimeToMilliseconds", ()=>(0, _time.hrTimeToMilliseconds));
parcelHelpers.export(exports, "hrTimeToNanoseconds", ()=>(0, _time.hrTimeToNanoseconds));
parcelHelpers.export(exports, "hrTimeToTimeStamp", ()=>(0, _time.hrTimeToTimeStamp));
parcelHelpers.export(exports, "isTimeInput", ()=>(0, _time.isTimeInput));
parcelHelpers.export(exports, "isTimeInputHrTime", ()=>(0, _time.isTimeInputHrTime));
parcelHelpers.export(exports, "millisToHrTime", ()=>(0, _time.millisToHrTime));
parcelHelpers.export(exports, "timeInputToHrTime", ()=>(0, _time.timeInputToHrTime));
parcelHelpers.export(exports, "hexToBinary", ()=>(0, _hexToBinary.hexToBinary));
parcelHelpers.export(exports, "ExportResultCode", ()=>(0, _exportResult.ExportResultCode));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _platform.RandomIdGenerator));
parcelHelpers.export(exports, "SDK_INFO", ()=>(0, _platform.SDK_INFO));
parcelHelpers.export(exports, "_globalThis", ()=>(0, _platform._globalThis));
parcelHelpers.export(exports, "getEnv", ()=>(0, _platform.getEnv));
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>(0, _platform.getEnvWithoutDefaults));
parcelHelpers.export(exports, "hexToBase64", ()=>(0, _platform.hexToBase64));
parcelHelpers.export(exports, "otperformance", ()=>(0, _platform.otperformance));
parcelHelpers.export(exports, "unrefTimer", ()=>(0, _platform.unrefTimer));
parcelHelpers.export(exports, "CompositePropagator", ()=>(0, _composite.CompositePropagator));
parcelHelpers.export(exports, "TRACE_PARENT_HEADER", ()=>(0, _w3CtraceContextPropagator.TRACE_PARENT_HEADER));
parcelHelpers.export(exports, "TRACE_STATE_HEADER", ()=>(0, _w3CtraceContextPropagator.TRACE_STATE_HEADER));
parcelHelpers.export(exports, "W3CTraceContextPropagator", ()=>(0, _w3CtraceContextPropagator.W3CTraceContextPropagator));
parcelHelpers.export(exports, "parseTraceParent", ()=>(0, _w3CtraceContextPropagator.parseTraceParent));
parcelHelpers.export(exports, "RPCType", ()=>(0, _rpcMetadata.RPCType));
parcelHelpers.export(exports, "deleteRPCMetadata", ()=>(0, _rpcMetadata.deleteRPCMetadata));
parcelHelpers.export(exports, "getRPCMetadata", ()=>(0, _rpcMetadata.getRPCMetadata));
parcelHelpers.export(exports, "setRPCMetadata", ()=>(0, _rpcMetadata.setRPCMetadata));
parcelHelpers.export(exports, "AlwaysOffSampler", ()=>(0, _alwaysOffSampler.AlwaysOffSampler));
parcelHelpers.export(exports, "AlwaysOnSampler", ()=>(0, _alwaysOnSampler.AlwaysOnSampler));
parcelHelpers.export(exports, "ParentBasedSampler", ()=>(0, _parentBasedSampler.ParentBasedSampler));
parcelHelpers.export(exports, "TraceIdRatioBasedSampler", ()=>(0, _traceIdRatioBasedSampler.TraceIdRatioBasedSampler));
parcelHelpers.export(exports, "isTracingSuppressed", ()=>(0, _suppressTracing.isTracingSuppressed));
parcelHelpers.export(exports, "suppressTracing", ()=>(0, _suppressTracing.suppressTracing));
parcelHelpers.export(exports, "unsuppressTracing", ()=>(0, _suppressTracing.unsuppressTracing));
parcelHelpers.export(exports, "TraceState", ()=>(0, _traceState.TraceState));
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_ATTRIBUTE_COUNT_LIMIT));
parcelHelpers.export(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", ()=>(0, _environment.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT));
parcelHelpers.export(exports, "DEFAULT_ENVIRONMENT", ()=>(0, _environment.DEFAULT_ENVIRONMENT));
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT));
parcelHelpers.export(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", ()=>(0, _environment.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT));
parcelHelpers.export(exports, "parseEnvironment", ()=>(0, _environment.parseEnvironment));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "TracesSamplerValues", ()=>(0, _sampling.TracesSamplerValues));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _timeout.TimeoutError));
parcelHelpers.export(exports, "callWithTimeout", ()=>(0, _timeout.callWithTimeout));
parcelHelpers.export(exports, "isUrlIgnored", ()=>(0, _url.isUrlIgnored));
parcelHelpers.export(exports, "urlMatches", ()=>(0, _url.urlMatches));
parcelHelpers.export(exports, "isWrapped", ()=>(0, _wrap.isWrapped));
parcelHelpers.export(exports, "BindOnceFuture", ()=>(0, _callback.BindOnceFuture));
parcelHelpers.export(exports, "VERSION", ()=>(0, _version.VERSION));
parcelHelpers.export(exports, "baggageUtils", ()=>baggageUtils);
parcelHelpers.export(exports, "internal", ()=>internal);
var _w3CbaggagePropagator = require("./baggage/propagation/W3CBaggagePropagator");
var _anchoredClock = require("./common/anchored-clock");
var _attributes = require("./common/attributes");
var _globalErrorHandler = require("./common/global-error-handler");
var _loggingErrorHandler = require("./common/logging-error-handler");
var _time = require("./common/time");
var _hexToBinary = require("./common/hex-to-binary");
var _exportResult = require("./ExportResult");
var _utils = require("./baggage/utils");
var _platform = require("./platform");
var _composite = require("./propagation/composite");
var _w3CtraceContextPropagator = require("./trace/W3CTraceContextPropagator");
var _rpcMetadata = require("./trace/rpc-metadata");
var _alwaysOffSampler = require("./trace/sampler/AlwaysOffSampler");
var _alwaysOnSampler = require("./trace/sampler/AlwaysOnSampler");
var _parentBasedSampler = require("./trace/sampler/ParentBasedSampler");
var _traceIdRatioBasedSampler = require("./trace/sampler/TraceIdRatioBasedSampler");
var _suppressTracing = require("./trace/suppress-tracing");
var _traceState = require("./trace/TraceState");
var _environment = require("./utils/environment");
var _merge = require("./utils/merge");
var _sampling = require("./utils/sampling");
var _timeout = require("./utils/timeout");
var _url = require("./utils/url");
var _wrap = require("./utils/wrap");
var _callback = require("./utils/callback");
var _version = require("./version");
var _exporter = require("./internal/exporter");
var baggageUtils = {
    getKeyPairs: (0, _utils.getKeyPairs),
    serializeKeyPairs: (0, _utils.serializeKeyPairs),
    parseKeyPairsIntoRecord: (0, _utils.parseKeyPairsIntoRecord),
    parsePairKeyValue: (0, _utils.parsePairKeyValue)
};
var internal = {
    _export: (0, _exporter._export)
};

},{"./baggage/propagation/W3CBaggagePropagator":false,"./common/anchored-clock":false,"./common/attributes":false,"./common/global-error-handler":false,"./common/logging-error-handler":false,"./common/time":"e1CUA","./common/hex-to-binary":false,"./ExportResult":false,"./baggage/utils":"3NKz3","./platform":"59dWe","./propagation/composite":false,"./trace/W3CTraceContextPropagator":false,"./trace/rpc-metadata":false,"./trace/sampler/AlwaysOffSampler":false,"./trace/sampler/AlwaysOnSampler":false,"./trace/sampler/ParentBasedSampler":false,"./trace/sampler/TraceIdRatioBasedSampler":false,"./trace/suppress-tracing":false,"./trace/TraceState":false,"./utils/environment":false,"./utils/merge":false,"./utils/sampling":false,"./utils/timeout":false,"./utils/url":"lgGOw","./utils/wrap":false,"./utils/callback":false,"./version":false,"./internal/exporter":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e1CUA":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */ parcelHelpers.export(exports, "millisToHrTime", ()=>millisToHrTime);
parcelHelpers.export(exports, "getTimeOrigin", ()=>getTimeOrigin);
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */ parcelHelpers.export(exports, "hrTime", ()=>hrTime);
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */ parcelHelpers.export(exports, "timeInputToHrTime", ()=>timeInputToHrTime);
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */ parcelHelpers.export(exports, "hrTimeDuration", ()=>hrTimeDuration);
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToTimeStamp", ()=>hrTimeToTimeStamp);
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToNanoseconds", ()=>hrTimeToNanoseconds);
/**
 * Convert hrTime to milliseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToMilliseconds", ()=>hrTimeToMilliseconds);
/**
 * Convert hrTime to microseconds.
 * @param time
 */ parcelHelpers.export(exports, "hrTimeToMicroseconds", ()=>hrTimeToMicroseconds);
/**
 * check if time is HrTime
 * @param value
 */ parcelHelpers.export(exports, "isTimeInputHrTime", ()=>isTimeInputHrTime);
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */ parcelHelpers.export(exports, "isTimeInput", ()=>isTimeInput);
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */ parcelHelpers.export(exports, "addHrTimes", ()=>addHrTimes);
var _platform = require("../platform");
var NANOSECOND_DIGITS = 9;
var NANOSECOND_DIGITS_IN_MILLIS = 6;
var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
function millisToHrTime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
    return [
        seconds,
        nanos
    ];
}
function getTimeOrigin() {
    var timeOrigin = (0, _platform.otperformance).timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = (0, _platform.otperformance);
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
function hrTime(performanceNow) {
    var timeOrigin = millisToHrTime(getTimeOrigin());
    var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : (0, _platform.otperformance).now());
    return addHrTimes(timeOrigin, now);
}
function timeInputToHrTime(time) {
    // process.hrtime
    if (isTimeInputHrTime(time)) return time;
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < getTimeOrigin()) return hrTime(time);
        else // epoch milliseconds or performance.timeOrigin
        return millisToHrTime(time);
    } else if (time instanceof Date) return millisToHrTime(time.getTime());
    else throw TypeError('Invalid input type');
}
function hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS;
    }
    return [
        seconds,
        nanos
    ];
}
function hrTimeToTimeStamp(time) {
    var precision = NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substring(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
function hrTimeToMilliseconds(time) {
    return time[0] * 1e3 + time[1] / 1e6;
}
function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1e3;
}
function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
}
function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;
}
function addHrTimes(time1, time2) {
    var out = [
        time1[0] + time2[0],
        time1[1] + time2[1]
    ];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
    }
    return out;
}

},{"../platform":"59dWe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59dWe":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEnvWithoutDefaults", ()=>(0, _environment.getEnvWithoutDefaults));
parcelHelpers.export(exports, "getEnv", ()=>(0, _environment.getEnv));
parcelHelpers.export(exports, "_globalThis", ()=>(0, _globalThis._globalThis));
parcelHelpers.export(exports, "hexToBase64", ()=>(0, _hexToBase64.hexToBase64));
parcelHelpers.export(exports, "RandomIdGenerator", ()=>(0, _randomIdGenerator.RandomIdGenerator));
parcelHelpers.export(exports, "otperformance", ()=>(0, _performance.otperformance));
parcelHelpers.export(exports, "SDK_INFO", ()=>(0, _sdkInfo.SDK_INFO));
parcelHelpers.export(exports, "unrefTimer", ()=>(0, _timerUtil.unrefTimer));
var _environment = require("./environment");
var _globalThis = require("./globalThis");
var _hexToBase64 = require("./hex-to-base64");
var _randomIdGenerator = require("./RandomIdGenerator");
var _performance = require("./performance");
var _sdkInfo = require("./sdk-info");
var _timerUtil = require("./timer-util");

},{"./environment":false,"./globalThis":false,"./hex-to-base64":false,"./RandomIdGenerator":false,"./performance":"1bI9K","./sdk-info":false,"./timer-util":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1bI9K":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "otperformance", ()=>otperformance);
var otperformance = performance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3NKz3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeKeyPairs", ()=>serializeKeyPairs);
parcelHelpers.export(exports, "getKeyPairs", ()=>getKeyPairs);
parcelHelpers.export(exports, "parsePairKeyValue", ()=>parsePairKeyValue);
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */ parcelHelpers.export(exports, "parseKeyPairsIntoRecord", ()=>parseKeyPairsIntoRecord);
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var _api = require("@opentelemetry/api");
var _constants = require("./constants");
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function(hValue, current) {
        var value = "" + hValue + (hValue !== '' ? (0, _constants.BAGGAGE_ITEMS_SEPARATOR) : '') + current;
        return value.length > (0, _constants.BAGGAGE_MAX_TOTAL_LENGTH) ? hValue : value;
    }, '');
}
function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) entry += (0, _constants.BAGGAGE_PROPERTIES_SEPARATOR) + value.metadata.toString();
        return entry;
    });
}
function parsePairKeyValue(entry) {
    var valueProps = entry.split((0, _constants.BAGGAGE_PROPERTIES_SEPARATOR));
    if (valueProps.length <= 0) return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart) return;
    var separatorIndex = keyPairPart.indexOf((0, _constants.BAGGAGE_KEY_PAIR_SEPARATOR));
    if (separatorIndex <= 0) return;
    var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    var metadata;
    if (valueProps.length > 0) metadata = (0, _api.baggageEntryMetadataFromString)(valueProps.join((0, _constants.BAGGAGE_PROPERTIES_SEPARATOR)));
    return {
        key: key,
        value: value,
        metadata: metadata
    };
}
function parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0) return {};
    return value.split((0, _constants.BAGGAGE_ITEMS_SEPARATOR)).map(function(entry) {
        return parsePairKeyValue(entry);
    }).filter(function(keyPair) {
        return keyPair !== undefined && keyPair.value.length > 0;
    }).reduce(function(headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}

},{"@opentelemetry/api":"6AC4z","./constants":"1OGEd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1OGEd":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BAGGAGE_KEY_PAIR_SEPARATOR", ()=>BAGGAGE_KEY_PAIR_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_PROPERTIES_SEPARATOR", ()=>BAGGAGE_PROPERTIES_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_ITEMS_SEPARATOR", ()=>BAGGAGE_ITEMS_SEPARATOR);
parcelHelpers.export(exports, "BAGGAGE_HEADER", ()=>BAGGAGE_HEADER);
parcelHelpers.export(exports, "BAGGAGE_MAX_NAME_VALUE_PAIRS", ()=>BAGGAGE_MAX_NAME_VALUE_PAIRS);
parcelHelpers.export(exports, "BAGGAGE_MAX_PER_NAME_VALUE_PAIRS", ()=>BAGGAGE_MAX_PER_NAME_VALUE_PAIRS);
parcelHelpers.export(exports, "BAGGAGE_MAX_TOTAL_LENGTH", ()=>BAGGAGE_MAX_TOTAL_LENGTH);
var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var BAGGAGE_PROPERTIES_SEPARATOR = ';';
var BAGGAGE_ITEMS_SEPARATOR = ',';
var BAGGAGE_HEADER = 'baggage';
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lgGOw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ parcelHelpers.export(exports, "urlMatches", ()=>urlMatches);
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */ parcelHelpers.export(exports, "isUrlIgnored", ()=>isUrlIgnored);
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') return url === urlToMatch;
    else return !!url.match(urlToMatch);
}
function isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) return false;
    try {
        for(var ignoredUrls_1 = __values(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()){
            var ignoreUrl = ignoredUrls_1_1.value;
            if (urlMatches(url, ignoreUrl)) return true;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ideG":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EventNames", ()=>EventNames);
var EventNames;
(function(EventNames) {
    EventNames["METHOD_OPEN"] = "open";
    EventNames["METHOD_SEND"] = "send";
    EventNames["EVENT_ABORT"] = "abort";
    EventNames["EVENT_ERROR"] = "error";
    EventNames["EVENT_LOAD"] = "loaded";
    EventNames["EVENT_TIMEOUT"] = "timeout";
})(EventNames || (EventNames = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bVVLF":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Helper function to determine payload content length for XHR requests
 * @param body
 * @returns content length
 */ parcelHelpers.export(exports, "getXHRBodyLength", ()=>getXHRBodyLength);
// Much of the logic here overlaps with the same utils file in opentelemetry-instrumentation-fetch
// These may be unified in the future.
var _api = require("@opentelemetry/api");
var __values = undefined && undefined.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var DIAG_LOGGER = _api.diag.createComponentLogger({
    namespace: '@opentelemetry/opentelemetry-instrumentation-xml-http-request/utils'
});
function getXHRBodyLength(body) {
    if (typeof Document !== 'undefined' && body instanceof Document) return new XMLSerializer().serializeToString(document).length;
    // XMLHttpRequestBodyInit expands to the following:
    if (body instanceof Blob) return body.size;
    // ArrayBuffer | ArrayBufferView
    if (body.byteLength !== undefined) return body.byteLength;
    if (body instanceof FormData) return getFormDataSize(body);
    if (body instanceof URLSearchParams) return getByteLength(body.toString());
    if (typeof body === 'string') return getByteLength(body);
    DIAG_LOGGER.warn('unknown body type');
    return undefined;
}
var TEXT_ENCODER = new TextEncoder();
function getByteLength(s) {
    return TEXT_ENCODER.encode(s).byteLength;
}
function getFormDataSize(formData) {
    var e_1, _a;
    var size = 0;
    try {
        for(var _b = __values(formData.entries()), _c = _b.next(); !_c.done; _c = _b.next()){
            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
            size += key.length;
            if (value instanceof Blob) size += value.size;
            else size += value.length;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return size;
}

},{"@opentelemetry/api":"6AC4z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ce7eg":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // this is autogenerated file, see scripts/version-update.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
var VERSION = '0.56.0';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLfrd":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AttributeNames", ()=>AttributeNames);
var AttributeNames;
(function(AttributeNames) {
    AttributeNames["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames || (AttributeNames = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lOen7":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instrumentation = require("./instrumentation");
parcelHelpers.exportAll(_instrumentation, exports);
var _types = require("./types");
parcelHelpers.exportAll(_types, exports);
var _attributeNames = require("./enums/AttributeNames");
parcelHelpers.exportAll(_attributeNames, exports);

},{"./instrumentation":"5EeMl","./types":false,"./enums/AttributeNames":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5EeMl":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UserInteractionInstrumentation", ()=>UserInteractionInstrumentation);
/// <reference types="zone.js" />
var _instrumentation = require("@opentelemetry/instrumentation");
var _api = require("@opentelemetry/api");
var _core = require("@opentelemetry/core");
var _sdkTraceWeb = require("@opentelemetry/sdk-trace-web");
var _attributeNames = require("./enums/AttributeNames");
/** @knipignore */ var _version = require("./version");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';
var EVENT_NAVIGATION_NAME = 'Navigation:';
var DEFAULT_EVENT_NAMES = [
    'click'
];
function defaultShouldPreventSpanCreation() {
    return false;
}
/**
 * This class represents a UserInteraction plugin for auto instrumentation.
 * If zone.js is available then it patches the zone otherwise it patches
 * addEventListener of HTMLElement
 */ var UserInteractionInstrumentation = /** @class */ function(_super) {
    __extends(UserInteractionInstrumentation, _super);
    function UserInteractionInstrumentation(config) {
        if (config === void 0) config = {};
        var _a;
        var _this = _super.call(this, (0, _version.PACKAGE_NAME), (0, _version.PACKAGE_VERSION), config) || this;
        _this.version = (0, _version.PACKAGE_VERSION);
        _this.moduleName = 'user-interaction';
        _this._spansData = new WeakMap();
        // for addEventListener/removeEventListener state
        _this._wrappedListeners = new WeakMap();
        // for event bubbling
        _this._eventsSpanMap = new WeakMap();
        _this._eventNames = new Set((_a = config === null || config === void 0 ? void 0 : config.eventNames) !== null && _a !== void 0 ? _a : DEFAULT_EVENT_NAMES);
        _this._shouldPreventSpanCreation = typeof (config === null || config === void 0 ? void 0 : config.shouldPreventSpanCreation) === 'function' ? config.shouldPreventSpanCreation : defaultShouldPreventSpanCreation;
        return _this;
    }
    UserInteractionInstrumentation.prototype.init = function() {};
    /**
     * This will check if last task was timeout and will save the time to
     * fix the user interaction when nothing happens
     * This timeout comes from xhr plugin which is needed to collect information
     * about last xhr main request from observer
     * @param task
     * @param span
     */ UserInteractionInstrumentation.prototype._checkForTimeout = function(task, span) {
        var spanData = this._spansData.get(span);
        if (spanData) {
            if (task.source === 'setTimeout') spanData.hrTimeLastTimeout = (0, _core.hrTime)();
            else if (task.source !== 'Promise.then' && task.source !== 'setTimeout') spanData.hrTimeLastTimeout = undefined;
        }
    };
    /**
     * Controls whether or not to create a span, based on the event type.
     */ UserInteractionInstrumentation.prototype._allowEventName = function(eventName) {
        return this._eventNames.has(eventName);
    };
    /**
     * Creates a new span
     * @param element
     * @param eventName
     * @param parentSpan
     */ UserInteractionInstrumentation.prototype._createSpan = function(element, eventName, parentSpan) {
        var _a;
        if (!(element instanceof HTMLElement)) return undefined;
        if (!element.getAttribute) return undefined;
        if (element.hasAttribute('disabled')) return undefined;
        if (!this._allowEventName(eventName)) return undefined;
        var xpath = (0, _sdkTraceWeb.getElementXPath)(element, true);
        try {
            var span = this.tracer.startSpan(eventName, {
                attributes: (_a = {}, _a[(0, _attributeNames.AttributeNames).EVENT_TYPE] = eventName, _a[(0, _attributeNames.AttributeNames).TARGET_ELEMENT] = element.tagName, _a[(0, _attributeNames.AttributeNames).TARGET_XPATH] = xpath, _a[(0, _attributeNames.AttributeNames).HTTP_URL] = window.location.href, _a)
            }, parentSpan ? _api.trace.setSpan(_api.context.active(), parentSpan) : undefined);
            if (this._shouldPreventSpanCreation(eventName, element, span) === true) return undefined;
            this._spansData.set(span, {
                taskCount: 0
            });
            return span;
        } catch (e) {
            this._diag.error('failed to start create new user interaction span', e);
        }
        return undefined;
    };
    /**
     * Decrement number of tasks that left in zone,
     * This is needed to be able to end span when no more tasks left
     * @param span
     */ UserInteractionInstrumentation.prototype._decrementTask = function(span) {
        var spanData = this._spansData.get(span);
        if (spanData) {
            spanData.taskCount--;
            if (spanData.taskCount === 0) this._tryToEndSpan(span, spanData.hrTimeLastTimeout);
        }
    };
    /**
     * Return the current span
     * @param zone
     * @private
     */ UserInteractionInstrumentation.prototype._getCurrentSpan = function(zone) {
        var context = zone.get(ZONE_CONTEXT_KEY);
        if (context) return _api.trace.getSpan(context);
        return context;
    };
    /**
     * Increment number of tasks that are run within the same zone.
     *     This is needed to be able to end span when no more tasks left
     * @param span
     */ UserInteractionInstrumentation.prototype._incrementTask = function(span) {
        var spanData = this._spansData.get(span);
        if (spanData) spanData.taskCount++;
    };
    /**
     * Returns true iff we should use the patched callback; false if it's already been patched
     */ UserInteractionInstrumentation.prototype.addPatchedListener = function(on, type, listener, wrappedListener) {
        var listener2Type = this._wrappedListeners.get(listener);
        if (!listener2Type) {
            listener2Type = new Map();
            this._wrappedListeners.set(listener, listener2Type);
        }
        var element2patched = listener2Type.get(type);
        if (!element2patched) {
            element2patched = new Map();
            listener2Type.set(type, element2patched);
        }
        if (element2patched.has(on)) return false;
        element2patched.set(on, wrappedListener);
        return true;
    };
    /**
     * Returns the patched version of the callback (or undefined)
     */ UserInteractionInstrumentation.prototype.removePatchedListener = function(on, type, listener) {
        var listener2Type = this._wrappedListeners.get(listener);
        if (!listener2Type) return undefined;
        var element2patched = listener2Type.get(type);
        if (!element2patched) return undefined;
        var patched = element2patched.get(on);
        if (patched) {
            element2patched.delete(on);
            if (element2patched.size === 0) {
                listener2Type.delete(type);
                if (listener2Type.size === 0) this._wrappedListeners.delete(listener);
            }
        }
        return patched;
    };
    // utility method to deal with the Function|EventListener nature of addEventListener
    UserInteractionInstrumentation.prototype._invokeListener = function(listener, target, args) {
        if (typeof listener === 'function') return listener.apply(target, args);
        else return listener.handleEvent(args[0]);
    };
    /**
     * This patches the addEventListener of HTMLElement to be able to
     * auto instrument the click events
     * This is done when zone is not available
     */ UserInteractionInstrumentation.prototype._patchAddEventListener = function() {
        var plugin = this;
        return function(original) {
            return function addEventListenerPatched(type, listener, useCapture) {
                // Forward calls with listener = null
                if (!listener) return original.call(this, type, listener, useCapture);
                // filter out null (typeof null === 'object')
                var once = useCapture && typeof useCapture === 'object' && useCapture.once;
                var patchedListener = function() {
                    var _this = this;
                    var args = [];
                    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                    var parentSpan;
                    var event = args[0];
                    var target = event === null || event === void 0 ? void 0 : event.target;
                    if (event) parentSpan = plugin._eventsSpanMap.get(event);
                    if (once) plugin.removePatchedListener(this, type, listener);
                    var span = plugin._createSpan(target, type, parentSpan);
                    if (span) {
                        if (event) plugin._eventsSpanMap.set(event, span);
                        return _api.context.with(_api.trace.setSpan(_api.context.active(), span), function() {
                            var result = plugin._invokeListener(listener, _this, args);
                            // no zone so end span immediately
                            span.end();
                            return result;
                        });
                    } else return plugin._invokeListener(listener, this, args);
                };
                if (plugin.addPatchedListener(this, type, listener, patchedListener)) return original.call(this, type, patchedListener, useCapture);
            };
        };
    };
    /**
     * This patches the removeEventListener of HTMLElement to handle the fact that
     * we patched the original callbacks
     * This is done when zone is not available
     */ UserInteractionInstrumentation.prototype._patchRemoveEventListener = function() {
        var plugin = this;
        return function(original) {
            return function removeEventListenerPatched(type, listener, useCapture) {
                var wrappedListener = plugin.removePatchedListener(this, type, listener);
                if (wrappedListener) return original.call(this, type, wrappedListener, useCapture);
                else return original.call(this, type, listener, useCapture);
            };
        };
    };
    /**
     * Most browser provide event listener api via EventTarget in prototype chain.
     * Exception to this is IE 11 which has it on the prototypes closest to EventTarget:
     *
     * * - has addEventListener in IE
     * ** - has addEventListener in all other browsers
     * ! - missing in IE
     *
     * HTMLElement -> Element -> Node * -> EventTarget **! -> Object
     * Document -> Node * -> EventTarget **! -> Object
     * Window * -> WindowProperties ! -> EventTarget **! -> Object
     */ UserInteractionInstrumentation.prototype._getPatchableEventTargets = function() {
        return window.EventTarget ? [
            EventTarget.prototype
        ] : [
            Node.prototype,
            Window.prototype
        ];
    };
    /**
     * Patches the history api
     */ UserInteractionInstrumentation.prototype._patchHistoryApi = function() {
        this._unpatchHistoryApi();
        this._wrap(history, 'replaceState', this._patchHistoryMethod());
        this._wrap(history, 'pushState', this._patchHistoryMethod());
        this._wrap(history, 'back', this._patchHistoryMethod());
        this._wrap(history, 'forward', this._patchHistoryMethod());
        this._wrap(history, 'go', this._patchHistoryMethod());
    };
    /**
     * Patches the certain history api method
     */ UserInteractionInstrumentation.prototype._patchHistoryMethod = function() {
        var plugin = this;
        return function(original) {
            return function patchHistoryMethod() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                var url = "" + location.pathname + location.hash + location.search;
                var result = original.apply(this, args);
                var urlAfter = "" + location.pathname + location.hash + location.search;
                if (url !== urlAfter) plugin._updateInteractionName(urlAfter);
                return result;
            };
        };
    };
    /**
     * unpatch the history api methods
     */ UserInteractionInstrumentation.prototype._unpatchHistoryApi = function() {
        if ((0, _instrumentation.isWrapped)(history.replaceState)) this._unwrap(history, 'replaceState');
        if ((0, _instrumentation.isWrapped)(history.pushState)) this._unwrap(history, 'pushState');
        if ((0, _instrumentation.isWrapped)(history.back)) this._unwrap(history, 'back');
        if ((0, _instrumentation.isWrapped)(history.forward)) this._unwrap(history, 'forward');
        if ((0, _instrumentation.isWrapped)(history.go)) this._unwrap(history, 'go');
    };
    /**
     * Updates interaction span name
     * @param url
     */ UserInteractionInstrumentation.prototype._updateInteractionName = function(url) {
        var span = _api.trace.getSpan(_api.context.active());
        if (span && typeof span.updateName === 'function') span.updateName(EVENT_NAVIGATION_NAME + " " + url);
    };
    /**
     * Patches zone cancel task - this is done to be able to correctly
     * decrement the number of remaining tasks
     */ UserInteractionInstrumentation.prototype._patchZoneCancelTask = function() {
        var plugin = this;
        return function(original) {
            return function patchCancelTask(task) {
                var currentZone = Zone.current;
                var currentSpan = plugin._getCurrentSpan(currentZone);
                if (currentSpan && plugin._shouldCountTask(task, currentZone)) plugin._decrementTask(currentSpan);
                return original.call(this, task);
            };
        };
    };
    /**
     * Patches zone schedule task - this is done to be able to correctly
     * increment the number of tasks running within current zone but also to
     * save time in case of timeout running from xhr plugin when waiting for
     * main request from PerformanceResourceTiming
     */ UserInteractionInstrumentation.prototype._patchZoneScheduleTask = function() {
        var plugin = this;
        return function(original) {
            return function patchScheduleTask(task) {
                var currentZone = Zone.current;
                var currentSpan = plugin._getCurrentSpan(currentZone);
                if (currentSpan && plugin._shouldCountTask(task, currentZone)) {
                    plugin._incrementTask(currentSpan);
                    plugin._checkForTimeout(task, currentSpan);
                }
                return original.call(this, task);
            };
        };
    };
    /**
     * Patches zone run task - this is done to be able to create a span when
     * user interaction starts
     * @private
     */ UserInteractionInstrumentation.prototype._patchZoneRunTask = function() {
        var plugin = this;
        return function(original) {
            return function patchRunTask(task, applyThis, applyArgs) {
                var event = Array.isArray(applyArgs) && applyArgs[0] instanceof Event ? applyArgs[0] : undefined;
                var target = event === null || event === void 0 ? void 0 : event.target;
                var span;
                var activeZone = this;
                if (target) {
                    span = plugin._createSpan(target, task.eventName);
                    if (span) {
                        plugin._incrementTask(span);
                        return activeZone.run(function() {
                            try {
                                return _api.context.with(_api.trace.setSpan(_api.context.active(), span), function() {
                                    var currentZone = Zone.current;
                                    task._zone = currentZone;
                                    return original.call(currentZone, task, applyThis, applyArgs);
                                });
                            } finally{
                                plugin._decrementTask(span);
                            }
                        });
                    }
                } else span = plugin._getCurrentSpan(activeZone);
                try {
                    return original.call(activeZone, task, applyThis, applyArgs);
                } finally{
                    if (span && plugin._shouldCountTask(task, activeZone)) plugin._decrementTask(span);
                }
            };
        };
    };
    /**
     * Decides if task should be counted.
     * @param task
     * @param currentZone
     * @private
     */ UserInteractionInstrumentation.prototype._shouldCountTask = function(task, currentZone) {
        if (task._zone) currentZone = task._zone;
        if (!currentZone || !task.data || task.data.isPeriodic) return false;
        var currentSpan = this._getCurrentSpan(currentZone);
        if (!currentSpan) return false;
        if (!this._spansData.get(currentSpan)) return false;
        return task.type === 'macroTask' || task.type === 'microTask';
    };
    /**
     * Will try to end span when such span still exists.
     * @param span
     * @param endTime
     * @private
     */ UserInteractionInstrumentation.prototype._tryToEndSpan = function(span, endTime) {
        if (span) {
            var spanData = this._spansData.get(span);
            if (spanData) {
                span.end(endTime);
                this._spansData.delete(span);
            }
        }
    };
    /**
     * implements enable function
     */ UserInteractionInstrumentation.prototype.enable = function() {
        var _this = this;
        var ZoneWithPrototype = this.getZoneWithPrototype();
        this._diag.debug('applying patch to', this.moduleName, this.version, 'zone:', !!ZoneWithPrototype);
        if (ZoneWithPrototype) {
            if ((0, _instrumentation.isWrapped)(ZoneWithPrototype.prototype.runTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'runTask');
                this._diag.debug('removing previous patch from method runTask');
            }
            if ((0, _instrumentation.isWrapped)(ZoneWithPrototype.prototype.scheduleTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'scheduleTask');
                this._diag.debug('removing previous patch from method scheduleTask');
            }
            if ((0, _instrumentation.isWrapped)(ZoneWithPrototype.prototype.cancelTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'cancelTask');
                this._diag.debug('removing previous patch from method cancelTask');
            }
            this._zonePatched = true;
            this._wrap(ZoneWithPrototype.prototype, 'runTask', this._patchZoneRunTask());
            this._wrap(ZoneWithPrototype.prototype, 'scheduleTask', this._patchZoneScheduleTask());
            this._wrap(ZoneWithPrototype.prototype, 'cancelTask', this._patchZoneCancelTask());
        } else {
            this._zonePatched = false;
            var targets = this._getPatchableEventTargets();
            targets.forEach(function(target) {
                if ((0, _instrumentation.isWrapped)(target.addEventListener)) {
                    _this._unwrap(target, 'addEventListener');
                    _this._diag.debug('removing previous patch from method addEventListener');
                }
                if ((0, _instrumentation.isWrapped)(target.removeEventListener)) {
                    _this._unwrap(target, 'removeEventListener');
                    _this._diag.debug('removing previous patch from method removeEventListener');
                }
                _this._wrap(target, 'addEventListener', _this._patchAddEventListener());
                _this._wrap(target, 'removeEventListener', _this._patchRemoveEventListener());
            });
        }
        this._patchHistoryApi();
    };
    /**
     * implements unpatch function
     */ UserInteractionInstrumentation.prototype.disable = function() {
        var _this = this;
        var ZoneWithPrototype = this.getZoneWithPrototype();
        this._diag.debug('removing patch from', this.moduleName, this.version, 'zone:', !!ZoneWithPrototype);
        if (ZoneWithPrototype && this._zonePatched) {
            if ((0, _instrumentation.isWrapped)(ZoneWithPrototype.prototype.runTask)) this._unwrap(ZoneWithPrototype.prototype, 'runTask');
            if ((0, _instrumentation.isWrapped)(ZoneWithPrototype.prototype.scheduleTask)) this._unwrap(ZoneWithPrototype.prototype, 'scheduleTask');
            if ((0, _instrumentation.isWrapped)(ZoneWithPrototype.prototype.cancelTask)) this._unwrap(ZoneWithPrototype.prototype, 'cancelTask');
        } else {
            var targets = this._getPatchableEventTargets();
            targets.forEach(function(target) {
                if ((0, _instrumentation.isWrapped)(target.addEventListener)) _this._unwrap(target, 'addEventListener');
                if ((0, _instrumentation.isWrapped)(target.removeEventListener)) _this._unwrap(target, 'removeEventListener');
            });
        }
        this._unpatchHistoryApi();
    };
    /**
     * returns Zone
     */ UserInteractionInstrumentation.prototype.getZoneWithPrototype = function() {
        var _window = window;
        return _window.Zone;
    };
    return UserInteractionInstrumentation;
}((0, _instrumentation.InstrumentationBase));

},{"@opentelemetry/instrumentation":"klru4","@opentelemetry/api":"6AC4z","@opentelemetry/core":"dBsXh","@opentelemetry/sdk-trace-web":"eXZZL","./enums/AttributeNames":"50VYj","./version":"6PVqs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klru4":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerInstrumentations", ()=>(0, _autoLoader.registerInstrumentations));
parcelHelpers.export(exports, "InstrumentationBase", ()=>(0, _index.InstrumentationBase));
parcelHelpers.export(exports, "InstrumentationNodeModuleDefinition", ()=>(0, _instrumentationNodeModuleDefinition.InstrumentationNodeModuleDefinition));
parcelHelpers.export(exports, "InstrumentationNodeModuleFile", ()=>(0, _instrumentationNodeModuleFile.InstrumentationNodeModuleFile));
parcelHelpers.export(exports, "isWrapped", ()=>(0, _utils.isWrapped));
parcelHelpers.export(exports, "safeExecuteInTheMiddle", ()=>(0, _utils.safeExecuteInTheMiddle));
parcelHelpers.export(exports, "safeExecuteInTheMiddleAsync", ()=>(0, _utils.safeExecuteInTheMiddleAsync));
var _autoLoader = require("./autoLoader");
var _index = require("./platform/index");
var _instrumentationNodeModuleDefinition = require("./instrumentationNodeModuleDefinition");
var _instrumentationNodeModuleFile = require("./instrumentationNodeModuleFile");
var _utils = require("./utils");

},{"./autoLoader":false,"./platform/index":"eJuKe","./instrumentationNodeModuleDefinition":false,"./instrumentationNodeModuleFile":false,"./utils":"7dlb1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eJuKe":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationBase", ()=>(0, _instrumentation.InstrumentationBase));
parcelHelpers.export(exports, "normalize", ()=>(0, _noopNormalize.normalize));
var _instrumentation = require("./instrumentation");
var _noopNormalize = require("./noop-normalize");

},{"./instrumentation":"aiKFm","./noop-normalize":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aiKFm":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationBase", ()=>InstrumentationBase);
var _instrumentation = require("../../instrumentation");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Base abstract class for instrumenting web plugins
 */ var InstrumentationBase = /** @class */ function(_super) {
    __extends(InstrumentationBase, _super);
    function InstrumentationBase(instrumentationName, instrumentationVersion, config) {
        var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
        if (_this._config.enabled) _this.enable();
        return _this;
    }
    return InstrumentationBase;
}((0, _instrumentation.InstrumentationAbstract));

},{"../../instrumentation":"iHQG2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iHQG2":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InstrumentationAbstract", ()=>InstrumentationAbstract);
var _api = require("@opentelemetry/api");
var _apiLogs = require("@opentelemetry/api-logs");
var _shimmer = require("shimmer");
var __assign = undefined && undefined.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * Base abstract internal class for instrumenting node and web plugins
 */ var InstrumentationAbstract = /** @class */ function() {
    function InstrumentationAbstract(instrumentationName, instrumentationVersion, config) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        this._config = {};
        /* Api to wrap instrumented method */ this._wrap = _shimmer.wrap;
        /* Api to unwrap instrumented methods */ this._unwrap = _shimmer.unwrap;
        /* Api to mass wrap instrumented method */ this._massWrap = _shimmer.massWrap;
        /* Api to mass unwrap instrumented methods */ this._massUnwrap = _shimmer.massUnwrap;
        this.setConfig(config);
        this._diag = (0, _api.diag).createComponentLogger({
            namespace: instrumentationName
        });
        this._tracer = (0, _api.trace).getTracer(instrumentationName, instrumentationVersion);
        this._meter = (0, _api.metrics).getMeter(instrumentationName, instrumentationVersion);
        this._logger = (0, _apiLogs.logs).getLogger(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
    }
    Object.defineProperty(InstrumentationAbstract.prototype, "meter", {
        /* Returns meter */ get: function() {
            return this._meter;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets MeterProvider to this plugin
     * @param meterProvider
     */ InstrumentationAbstract.prototype.setMeterProvider = function(meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
    };
    Object.defineProperty(InstrumentationAbstract.prototype, "logger", {
        /* Returns logger */ get: function() {
            return this._logger;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets LoggerProvider to this plugin
     * @param loggerProvider
     */ InstrumentationAbstract.prototype.setLoggerProvider = function(loggerProvider) {
        this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    };
    /**
     * @experimental
     *
     * Get module definitions defined by {@link init}.
     * This can be used for experimental compile-time instrumentation.
     *
     * @returns an array of {@link InstrumentationModuleDefinition}
     */ InstrumentationAbstract.prototype.getModuleDefinitions = function() {
        var _a;
        var initResult = (_a = this.init()) !== null && _a !== void 0 ? _a : [];
        if (!Array.isArray(initResult)) return [
            initResult
        ];
        return initResult;
    };
    /**
     * Sets the new metric instruments with the current Meter.
     */ InstrumentationAbstract.prototype._updateMetricInstruments = function() {
        return;
    };
    /* Returns InstrumentationConfig */ InstrumentationAbstract.prototype.getConfig = function() {
        return this._config;
    };
    /**
     * Sets InstrumentationConfig to this plugin
     * @param config
     */ InstrumentationAbstract.prototype.setConfig = function(config) {
        // copy config first level properties to ensure they are immutable.
        // nested properties are not copied, thus are mutable from the outside.
        this._config = __assign({
            enabled: true
        }, config);
    };
    /**
     * Sets TraceProvider to this plugin
     * @param tracerProvider
     */ InstrumentationAbstract.prototype.setTracerProvider = function(tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    };
    Object.defineProperty(InstrumentationAbstract.prototype, "tracer", {
        /* Returns tracer */ get: function() {
            return this._tracer;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Execute span customization hook, if configured, and log any errors.
     * Any semantics of the trigger and info are defined by the specific instrumentation.
     * @param hookHandler The optional hook handler which the user has configured via instrumentation config
     * @param triggerName The name of the trigger for executing the hook for logging purposes
     * @param span The span to which the hook should be applied
     * @param info The info object to be passed to the hook, with useful data the hook may use
     */ InstrumentationAbstract.prototype._runSpanCustomizationHook = function(hookHandler, triggerName, span, info) {
        if (!hookHandler) return;
        try {
            hookHandler(span, info);
        } catch (e) {
            this._diag.error("Error running span customization hook due to exception in handler", {
                triggerName: triggerName
            }, e);
        }
    };
    return InstrumentationAbstract;
}();

},{"@opentelemetry/api":"6AC4z","@opentelemetry/api-logs":"lp8J5","shimmer":"kGpxk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lp8J5":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SeverityNumber", ()=>(0, _logRecord.SeverityNumber));
parcelHelpers.export(exports, "NOOP_LOGGER", ()=>(0, _noopLogger.NOOP_LOGGER));
parcelHelpers.export(exports, "NoopLogger", ()=>(0, _noopLogger.NoopLogger));
parcelHelpers.export(exports, "NOOP_LOGGER_PROVIDER", ()=>(0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER));
parcelHelpers.export(exports, "NoopLoggerProvider", ()=>(0, _noopLoggerProvider.NoopLoggerProvider));
parcelHelpers.export(exports, "ProxyLogger", ()=>(0, _proxyLogger.ProxyLogger));
parcelHelpers.export(exports, "ProxyLoggerProvider", ()=>(0, _proxyLoggerProvider.ProxyLoggerProvider));
parcelHelpers.export(exports, "logs", ()=>logs);
var _logRecord = require("./types/LogRecord");
var _noopLogger = require("./NoopLogger");
var _noopLoggerProvider = require("./NoopLoggerProvider");
var _proxyLogger = require("./ProxyLogger");
var _proxyLoggerProvider = require("./ProxyLoggerProvider");
var _logs = require("./api/logs");
var logs = (0, _logs.LogsAPI).getInstance();

},{"./types/LogRecord":false,"./NoopLogger":false,"./NoopLoggerProvider":false,"./ProxyLogger":false,"./ProxyLoggerProvider":false,"./api/logs":"aSjuD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iMIkr":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopLogger", ()=>NoopLogger);
parcelHelpers.export(exports, "NOOP_LOGGER", ()=>NOOP_LOGGER);
var NoopLogger = /** @class */ function() {
    function NoopLogger() {}
    NoopLogger.prototype.emit = function(_logRecord) {};
    return NoopLogger;
}();
var NOOP_LOGGER = new NoopLogger();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eMQTl":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopLoggerProvider", ()=>NoopLoggerProvider);
parcelHelpers.export(exports, "NOOP_LOGGER_PROVIDER", ()=>NOOP_LOGGER_PROVIDER);
var _noopLogger = require("./NoopLogger");
var NoopLoggerProvider = /** @class */ function() {
    function NoopLoggerProvider() {}
    NoopLoggerProvider.prototype.getLogger = function(_name, _version, _options) {
        return new (0, _noopLogger.NoopLogger)();
    };
    return NoopLoggerProvider;
}();
var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

},{"./NoopLogger":"iMIkr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eeHGI":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProxyLogger", ()=>ProxyLogger);
var _noopLogger = require("./NoopLogger");
var ProxyLogger = /** @class */ function() {
    function ProxyLogger(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    /**
     * Emit a log record. This method should only be used by log appenders.
     *
     * @param logRecord
     */ ProxyLogger.prototype.emit = function(logRecord) {
        this._getLogger().emit(logRecord);
    };
    /**
     * Try to get a logger from the proxy logger provider.
     * If the proxy logger provider has no delegate, return a noop logger.
     */ ProxyLogger.prototype._getLogger = function() {
        if (this._delegate) return this._delegate;
        var logger = this._provider.getDelegateLogger(this.name, this.version, this.options);
        if (!logger) return 0, _noopLogger.NOOP_LOGGER;
        this._delegate = logger;
        return this._delegate;
    };
    return ProxyLogger;
}();

},{"./NoopLogger":"iMIkr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kCvWX":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProxyLoggerProvider", ()=>ProxyLoggerProvider);
var _noopLoggerProvider = require("./NoopLoggerProvider");
var _proxyLogger = require("./ProxyLogger");
var ProxyLoggerProvider = /** @class */ function() {
    function ProxyLoggerProvider() {}
    ProxyLoggerProvider.prototype.getLogger = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new (0, _proxyLogger.ProxyLogger)(this, name, version, options);
    };
    ProxyLoggerProvider.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : (0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER);
    };
    /**
     * Set the delegate logger provider
     */ ProxyLoggerProvider.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyLoggerProvider.prototype.getDelegateLogger = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
    };
    return ProxyLoggerProvider;
}();

},{"./NoopLoggerProvider":"eMQTl","./ProxyLogger":"eeHGI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aSjuD":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LogsAPI", ()=>LogsAPI);
var _globalUtils = require("../internal/global-utils");
var _noopLoggerProvider = require("../NoopLoggerProvider");
var _proxyLoggerProvider = require("../ProxyLoggerProvider");
var LogsAPI = /** @class */ function() {
    function LogsAPI() {
        this._proxyLoggerProvider = new (0, _proxyLoggerProvider.ProxyLoggerProvider)();
    }
    LogsAPI.getInstance = function() {
        if (!this._instance) this._instance = new LogsAPI();
        return this._instance;
    };
    LogsAPI.prototype.setGlobalLoggerProvider = function(provider) {
        if ((0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY]) return this.getLoggerProvider();
        (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY] = (0, _globalUtils.makeGetter)((0, _globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION), provider, (0, _noopLoggerProvider.NOOP_LOGGER_PROVIDER));
        this._proxyLoggerProvider.setDelegate(provider);
        return provider;
    };
    /**
     * Returns the global logger provider.
     *
     * @returns LoggerProvider
     */ LogsAPI.prototype.getLoggerProvider = function() {
        var _a, _b;
        return (_b = (_a = (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call((0, _globalUtils._global), (0, _globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION))) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
    };
    /**
     * Returns a logger from the global logger provider.
     *
     * @returns Logger
     */ LogsAPI.prototype.getLogger = function(name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
    };
    /** Remove the global logger provider */ LogsAPI.prototype.disable = function() {
        delete (0, _globalUtils._global)[0, _globalUtils.GLOBAL_LOGS_API_KEY];
        this._proxyLoggerProvider = new (0, _proxyLoggerProvider.ProxyLoggerProvider)();
    };
    return LogsAPI;
}();

},{"../internal/global-utils":"lGvbS","../NoopLoggerProvider":"eMQTl","../ProxyLoggerProvider":"kCvWX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lGvbS":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GLOBAL_LOGS_API_KEY", ()=>GLOBAL_LOGS_API_KEY);
parcelHelpers.export(exports, "_global", ()=>_global);
/**
 * Make a function which accepts a version integer and returns the instance of an API if the version
 * is compatible, or a fallback version (usually NOOP) if it is not.
 *
 * @param requiredVersion Backwards compatibility version which is required to return the instance
 * @param instance Instance which should be returned if the required version is compatible
 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
 */ parcelHelpers.export(exports, "makeGetter", ()=>makeGetter);
parcelHelpers.export(exports, "API_BACKWARDS_COMPATIBILITY_VERSION", ()=>API_BACKWARDS_COMPATIBILITY_VERSION);
var _platform = require("../platform");
var GLOBAL_LOGS_API_KEY = Symbol.for('io.opentelemetry.js.api.logs');
var _global = (0, _platform._globalThis);
function makeGetter(requiredVersion, instance, fallback) {
    return function(version) {
        return version === requiredVersion ? instance : fallback;
    };
}
var API_BACKWARDS_COMPATIBILITY_VERSION = 1;

},{"../platform":"5cUs7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cUs7":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>(0, _globalThis._globalThis));
var _globalThis = require("./globalThis");

},{"./globalThis":"2H8vI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2H8vI":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */ /** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_globalThis", ()=>_globalThis);
var global = arguments[3];
var _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7dlb1":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * function to execute patched function and being able to catch errors
 * @param execute - function to be executed
 * @param onFinish - callback to run when execute finishes
 */ parcelHelpers.export(exports, "safeExecuteInTheMiddle", ()=>safeExecuteInTheMiddle);
/**
 * Async function to execute patched function and being able to catch errors
 * @param execute - function to be executed
 * @param onFinish - callback to run when execute finishes
 */ parcelHelpers.export(exports, "safeExecuteInTheMiddleAsync", ()=>safeExecuteInTheMiddleAsync);
/**
 * Checks if certain function has been already wrapped
 * @param func
 */ parcelHelpers.export(exports, "isWrapped", ()=>isWrapped);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    var error;
    var result;
    try {
        result = execute();
    } catch (e) {
        error = e;
    } finally{
        onFinish(error, result);
        if (error && !preventThrowingError) // eslint-disable-next-line no-unsafe-finally
        throw error;
        // eslint-disable-next-line no-unsafe-finally
        return result;
    }
}
function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    return __awaiter(this, void 0, void 0, function() {
        var error, result, e_1;
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    _a.trys.push([
                        0,
                        2,
                        3,
                        4
                    ]);
                    return [
                        4 /*yield*/ ,
                        execute()
                    ];
                case 1:
                    result = _a.sent();
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 2:
                    e_1 = _a.sent();
                    error = e_1;
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 3:
                    onFinish(error, result);
                    if (error && !preventThrowingError) // eslint-disable-next-line no-unsafe-finally
                    throw error;
                    // eslint-disable-next-line no-unsafe-finally
                    return [
                        2 /*return*/ ,
                        result
                    ];
                case 4:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}
function isWrapped(func) {
    return typeof func === 'function' && typeof func.__original === 'function' && typeof func.__unwrap === 'function' && func.__wrapped === true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"50VYj":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AttributeNames", ()=>AttributeNames);
var AttributeNames;
(function(AttributeNames) {
    AttributeNames["EVENT_TYPE"] = "event_type";
    AttributeNames["TARGET_ELEMENT"] = "target_element";
    AttributeNames["TARGET_XPATH"] = "target_xpath";
    AttributeNames["HTTP_URL"] = "http.url";
})(AttributeNames || (AttributeNames = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6PVqs":[function(require,module,exports,__globalThis) {
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // this is autogenerated file, see scripts/version-update.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PACKAGE_VERSION", ()=>PACKAGE_VERSION);
parcelHelpers.export(exports, "PACKAGE_NAME", ()=>PACKAGE_NAME);
var PACKAGE_VERSION = '0.43.0';
var PACKAGE_NAME = '@opentelemetry/instrumentation-user-interaction';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["4hJLU","5NY2J"], "5NY2J", "parcelRequire94c2")

//# sourceMappingURL=index.af4559fd.js.map
